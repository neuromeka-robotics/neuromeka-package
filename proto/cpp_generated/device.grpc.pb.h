// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: device.proto
#ifndef GRPC_device_2eproto__INCLUDED
#define GRPC_device_2eproto__INCLUDED

#include "device.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace Nrmk {
namespace IndyFramework {

class Device final {
 public:
  static constexpr char const* service_full_name() {
    return "Nrmk.IndyFramework.Device";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetBrakesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetBrakesRaw(context, request, cq));
    }
    virtual ::grpc::Status SetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetServoAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetServoAllRaw(context, request, cq));
    }
    virtual ::grpc::Status SetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetServoRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetDIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndDIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetAIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetAORaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndAIRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndAORaw(context, request, cq));
    }
    virtual ::grpc::Status ExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncExecuteToolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncExecuteToolRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetEndRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndRS485RxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>> AsyncGetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(AsyncGetEndRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>> PrepareAsyncGetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(PrepareAsyncGetEndRS485RxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>> AsyncGetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(AsyncGetEndRS485TxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>> PrepareAsyncGetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(PrepareAsyncGetEndRS485TxRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndLedDimRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndLedDimRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::DigitalList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>> AsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>>(AsyncGetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>> PrepareAsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>>(PrepareAsyncGetDIRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::DigitalList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>> AsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>>(AsyncGetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>> PrepareAsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>>(PrepareAsyncGetDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolSignalList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>> AsyncGetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>>(AsyncGetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>> PrepareAsyncGetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>>(PrepareAsyncGetEndDIRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolSignalList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>> AsyncGetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>>(AsyncGetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>> PrepareAsyncGetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>>(PrepareAsyncGetEndDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> AsyncGetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetAIRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> AsyncGetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetAORaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> AsyncGetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetEndAIRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> AsyncGetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetEndAORaw(context, request, cq));
    }
    // beckhoff_conv
    virtual ::grpc::Status GetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GetEL5001Data* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5001Data>> AsyncGetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5001Data>>(AsyncGetEL5001Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5001Data>> PrepareAsyncGetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5001Data>>(PrepareAsyncGetEL5001Raw(context, request, cq));
    }
    virtual ::grpc::Status GetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GetEL5101Data* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5101Data>> AsyncGetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5101Data>>(AsyncGetEL5101Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5101Data>> PrepareAsyncGetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5101Data>>(PrepareAsyncGetEL5101Raw(context, request, cq));
    }
    virtual ::grpc::Status GetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::DeviceInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DeviceInfo>> AsyncGetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DeviceInfo>>(AsyncGetDeviceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DeviceInfo>> PrepareAsyncGetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DeviceInfo>>(PrepareAsyncGetDeviceInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::BrakeControlStyle* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BrakeControlStyle>> AsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BrakeControlStyle>>(AsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BrakeControlStyle>> PrepareAsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BrakeControlStyle>>(PrepareAsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    // ///////////// Sander ////////////////
    virtual ::grpc::Status SetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetSanderCommandRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SanderCommand* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SanderCommand>> AsyncGetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SanderCommand>>(AsyncGetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SanderCommand>> PrepareAsyncGetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SanderCommand>>(PrepareAsyncGetSanderCommandRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::FTSensorData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FTSensorData>> AsyncGetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FTSensorData>>(AsyncGetFTSensorDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FTSensorData>> PrepareAsyncGetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FTSensorData>>(PrepareAsyncGetFTSensorDataRaw(context, request, cq));
    }
    // ///////////// Conveyor ///////////////
    virtual ::grpc::Status GetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Conveyor* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Conveyor>> AsyncGetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Conveyor>>(AsyncGetConveyorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Conveyor>> PrepareAsyncGetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Conveyor>>(PrepareAsyncGetConveyorRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorNameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorByNameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorEncoderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorEncoderRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorTriggerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorTriggerRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::ConveyorState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ConveyorState>> AsyncGetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ConveyorState>>(AsyncGetConveyorStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ConveyorState>> PrepareAsyncGetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ConveyorState>>(PrepareAsyncGetConveyorStateRaw(context, request, cq));
    }
    // ///////////// Safety ////////////////
    virtual ::grpc::Status GetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetLoadFactorsRes>> AsyncGetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetLoadFactorsRes>>(AsyncGetLoadFactorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetLoadFactorsRes>> PrepareAsyncGetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetLoadFactorsRes>>(PrepareAsyncGetLoadFactorsRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::Nrmk::IndyFramework::SetAutoModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SetAutoModeRes>> AsyncSetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SetAutoModeRes>>(AsyncSetAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SetAutoModeRes>> PrepareAsyncSetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SetAutoModeRes>>(PrepareAsyncSetAutoModeRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::CheckAutoModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAutoModeRes>> AsyncCheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAutoModeRes>>(AsyncCheckAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAutoModeRes>> PrepareAsyncCheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAutoModeRes>>(PrepareAsyncCheckAutoModeRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::CheckReducedModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckReducedModeRes>> AsyncCheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckReducedModeRes>>(AsyncCheckReducedModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckReducedModeRes>> PrepareAsyncCheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckReducedModeRes>>(PrepareAsyncCheckReducedModeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SafetyFunctionState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyFunctionState>> AsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyFunctionState>>(AsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyFunctionState>> PrepareAsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyFunctionState>>(PrepareAsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    virtual ::grpc::Status RequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SafetyControlData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyControlData>> AsyncGetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyControlData>>(AsyncGetSafetyControlDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyControlData>> PrepareAsyncGetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyControlData>>(PrepareAsyncGetSafetyControlDataRaw(context, request, cq));
    }
    // /////////////485Gripper//////////////////////
    virtual ::grpc::Status GetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GripperData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GripperData>> AsyncGetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GripperData>>(AsyncGetGripperDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GripperData>> PrepareAsyncGetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GripperData>>(PrepareAsyncGetGripperDataRaw(context, request, cq));
    }
    virtual ::grpc::Status SetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetGripperCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetGripperCommandRaw(context, request, cq));
    }
    // /////////////Photoneo Calibration//////////////////////
    virtual ::grpc::Status AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    // /////////////Photoneo Get Detection Retrieval//////////////////////
    virtual ::grpc::Status GetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::Nrmk::IndyFramework::VisionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>> AsyncGetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>>(AsyncGetPhotoneoDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>> PrepareAsyncGetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>>(PrepareAsyncGetPhotoneoDetectionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::Nrmk::IndyFramework::VisionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>> AsyncGetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>>(AsyncGetPhotoneoRetrievalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>> PrepareAsyncGetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>>(PrepareAsyncGetPhotoneoRetrievalRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void SetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // beckhoff_conv
      virtual void GetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5001Data* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5001Data* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5101Data* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5101Data* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DeviceInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DeviceInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BrakeControlStyle* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BrakeControlStyle* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ///////////// Sander ////////////////
      virtual void SetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SanderCommand* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SanderCommand* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FTSensorData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FTSensorData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ///////////// Conveyor ///////////////
      virtual void GetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Conveyor* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Conveyor* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ConveyorState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ConveyorState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ///////////// Safety ////////////////
      virtual void GetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq* request, ::Nrmk::IndyFramework::SetAutoModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq* request, ::Nrmk::IndyFramework::SetAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckAutoModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckReducedModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckReducedModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyFunctionState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyFunctionState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyControlData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyControlData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // /////////////485Gripper//////////////////////
      virtual void GetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GripperData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GripperData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // /////////////Photoneo Calibration//////////////////////
      virtual void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // /////////////Photoneo Get Detection Retrieval//////////////////////
      virtual void GetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetBrakesRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetBrakesRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetServoAllRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetServoAllRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncExecuteToolRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncExecuteToolRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>* AsyncGetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>* PrepareAsyncGetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>* AsyncGetEndRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>* PrepareAsyncGetEndRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetEndLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>* AsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>* PrepareAsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>* AsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DigitalList>* PrepareAsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>* AsyncGetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>* PrepareAsyncGetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>* AsyncGetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolSignalList>* PrepareAsyncGetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* AsyncGetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* AsyncGetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* AsyncGetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* AsyncGetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5001Data>* AsyncGetEL5001Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5001Data>* PrepareAsyncGetEL5001Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5101Data>* AsyncGetEL5101Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetEL5101Data>* PrepareAsyncGetEL5101Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DeviceInfo>* AsyncGetDeviceInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DeviceInfo>* PrepareAsyncGetDeviceInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BrakeControlStyle>* AsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BrakeControlStyle>* PrepareAsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SanderCommand>* AsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SanderCommand>* PrepareAsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FTSensorData>* AsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FTSensorData>* PrepareAsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Conveyor>* AsyncGetConveyorRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Conveyor>* PrepareAsyncGetConveyorRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ConveyorState>* AsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ConveyorState>* PrepareAsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetLoadFactorsRes>* AsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetLoadFactorsRes>* PrepareAsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SetAutoModeRes>* AsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SetAutoModeRes>* PrepareAsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAutoModeRes>* AsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAutoModeRes>* PrepareAsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckReducedModeRes>* AsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckReducedModeRes>* PrepareAsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyFunctionState>* AsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyFunctionState>* PrepareAsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyControlData>* AsyncGetSafetyControlDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SafetyControlData>* PrepareAsyncGetSafetyControlDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GripperData>* AsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GripperData>* PrepareAsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>* AsyncGetPhotoneoDetectionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>* PrepareAsyncGetPhotoneoDetectionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>* AsyncGetPhotoneoRetrievalRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::VisionResult>* PrepareAsyncGetPhotoneoRetrievalRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetBrakesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetBrakesRaw(context, request, cq));
    }
    ::grpc::Status SetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetServoAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetServoAllRaw(context, request, cq));
    }
    ::grpc::Status SetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetServoRaw(context, request, cq));
    }
    ::grpc::Status SetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetDIRaw(context, request, cq));
    }
    ::grpc::Status SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    ::grpc::Status SetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndDIRaw(context, request, cq));
    }
    ::grpc::Status SetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndDORaw(context, request, cq));
    }
    ::grpc::Status SetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetAIRaw(context, request, cq));
    }
    ::grpc::Status SetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetAORaw(context, request, cq));
    }
    ::grpc::Status SetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndAIRaw(context, request, cq));
    }
    ::grpc::Status SetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndAORaw(context, request, cq));
    }
    ::grpc::Status ExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncExecuteToolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncExecuteToolRaw(context, request, cq));
    }
    ::grpc::Status SetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetEndRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetEndRS485RxRaw(context, request, cq));
    }
    ::grpc::Status GetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>> AsyncGetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(AsyncGetEndRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>> PrepareAsyncGetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(PrepareAsyncGetEndRS485RxRaw(context, request, cq));
    }
    ::grpc::Status GetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>> AsyncGetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(AsyncGetEndRS485TxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>> PrepareAsyncGetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(PrepareAsyncGetEndRS485TxRaw(context, request, cq));
    }
    ::grpc::Status SetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndLedDimRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndLedDimRaw(context, request, cq));
    }
    ::grpc::Status GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::DigitalList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>> AsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>>(AsyncGetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>> PrepareAsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>>(PrepareAsyncGetDIRaw(context, request, cq));
    }
    ::grpc::Status GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::DigitalList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>> AsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>>(AsyncGetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>> PrepareAsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>>(PrepareAsyncGetDORaw(context, request, cq));
    }
    ::grpc::Status GetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolSignalList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>> AsyncGetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>>(AsyncGetEndDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>> PrepareAsyncGetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>>(PrepareAsyncGetEndDIRaw(context, request, cq));
    }
    ::grpc::Status GetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolSignalList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>> AsyncGetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>>(AsyncGetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>> PrepareAsyncGetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>>(PrepareAsyncGetEndDORaw(context, request, cq));
    }
    ::grpc::Status GetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> AsyncGetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetAIRaw(context, request, cq));
    }
    ::grpc::Status GetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> AsyncGetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetAORaw(context, request, cq));
    }
    ::grpc::Status GetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> AsyncGetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetEndAIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetEndAIRaw(context, request, cq));
    }
    ::grpc::Status GetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AnalogList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> AsyncGetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(AsyncGetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>> PrepareAsyncGetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>>(PrepareAsyncGetEndAORaw(context, request, cq));
    }
    ::grpc::Status GetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GetEL5001Data* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5001Data>> AsyncGetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5001Data>>(AsyncGetEL5001Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5001Data>> PrepareAsyncGetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5001Data>>(PrepareAsyncGetEL5001Raw(context, request, cq));
    }
    ::grpc::Status GetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GetEL5101Data* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5101Data>> AsyncGetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5101Data>>(AsyncGetEL5101Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5101Data>> PrepareAsyncGetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5101Data>>(PrepareAsyncGetEL5101Raw(context, request, cq));
    }
    ::grpc::Status GetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::DeviceInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DeviceInfo>> AsyncGetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DeviceInfo>>(AsyncGetDeviceInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DeviceInfo>> PrepareAsyncGetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DeviceInfo>>(PrepareAsyncGetDeviceInfoRaw(context, request, cq));
    }
    ::grpc::Status GetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::BrakeControlStyle* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BrakeControlStyle>> AsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BrakeControlStyle>>(AsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BrakeControlStyle>> PrepareAsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BrakeControlStyle>>(PrepareAsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    ::grpc::Status SetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetSanderCommandRaw(context, request, cq));
    }
    ::grpc::Status GetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SanderCommand* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SanderCommand>> AsyncGetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SanderCommand>>(AsyncGetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SanderCommand>> PrepareAsyncGetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SanderCommand>>(PrepareAsyncGetSanderCommandRaw(context, request, cq));
    }
    ::grpc::Status GetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::FTSensorData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FTSensorData>> AsyncGetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FTSensorData>>(AsyncGetFTSensorDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FTSensorData>> PrepareAsyncGetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FTSensorData>>(PrepareAsyncGetFTSensorDataRaw(context, request, cq));
    }
    ::grpc::Status GetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Conveyor* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Conveyor>> AsyncGetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Conveyor>>(AsyncGetConveyorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Conveyor>> PrepareAsyncGetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Conveyor>>(PrepareAsyncGetConveyorRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorNameRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorByNameRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorEncoderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorEncoderRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorTriggerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorTriggerRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorOffsetRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    ::grpc::Status GetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::ConveyorState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ConveyorState>> AsyncGetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ConveyorState>>(AsyncGetConveyorStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ConveyorState>> PrepareAsyncGetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ConveyorState>>(PrepareAsyncGetConveyorStateRaw(context, request, cq));
    }
    ::grpc::Status GetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetLoadFactorsRes>> AsyncGetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetLoadFactorsRes>>(AsyncGetLoadFactorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetLoadFactorsRes>> PrepareAsyncGetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetLoadFactorsRes>>(PrepareAsyncGetLoadFactorsRaw(context, request, cq));
    }
    ::grpc::Status SetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::Nrmk::IndyFramework::SetAutoModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SetAutoModeRes>> AsyncSetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SetAutoModeRes>>(AsyncSetAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SetAutoModeRes>> PrepareAsyncSetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SetAutoModeRes>>(PrepareAsyncSetAutoModeRaw(context, request, cq));
    }
    ::grpc::Status CheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::CheckAutoModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAutoModeRes>> AsyncCheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAutoModeRes>>(AsyncCheckAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAutoModeRes>> PrepareAsyncCheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAutoModeRes>>(PrepareAsyncCheckAutoModeRaw(context, request, cq));
    }
    ::grpc::Status CheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::CheckReducedModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckReducedModeRes>> AsyncCheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckReducedModeRes>>(AsyncCheckReducedModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckReducedModeRes>> PrepareAsyncCheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckReducedModeRes>>(PrepareAsyncCheckReducedModeRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SafetyFunctionState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyFunctionState>> AsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyFunctionState>>(AsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyFunctionState>> PrepareAsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyFunctionState>>(PrepareAsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    ::grpc::Status RequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SafetyControlData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyControlData>> AsyncGetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyControlData>>(AsyncGetSafetyControlDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyControlData>> PrepareAsyncGetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyControlData>>(PrepareAsyncGetSafetyControlDataRaw(context, request, cq));
    }
    ::grpc::Status GetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::GripperData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GripperData>> AsyncGetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GripperData>>(AsyncGetGripperDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GripperData>> PrepareAsyncGetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GripperData>>(PrepareAsyncGetGripperDataRaw(context, request, cq));
    }
    ::grpc::Status SetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetGripperCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetGripperCommandRaw(context, request, cq));
    }
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    ::grpc::Status GetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::Nrmk::IndyFramework::VisionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>> AsyncGetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>>(AsyncGetPhotoneoDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>> PrepareAsyncGetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>>(PrepareAsyncGetPhotoneoDetectionRaw(context, request, cq));
    }
    ::grpc::Status GetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::Nrmk::IndyFramework::VisionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>> AsyncGetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>>(AsyncGetPhotoneoRetrievalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>> PrepareAsyncGetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>>(PrepareAsyncGetPhotoneoRetrievalRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetBrakes(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetServoAll(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void ExecuteTool(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, std::function<void(::grpc::Status)>) override;
      void GetEndRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, std::function<void(::grpc::Status)>) override;
      void GetEndRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetEndLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, std::function<void(::grpc::Status)>) override;
      void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, std::function<void(::grpc::Status)>) override;
      void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, std::function<void(::grpc::Status)>) override;
      void GetEndDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, std::function<void(::grpc::Status)>) override;
      void GetEndDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) override;
      void GetAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) override;
      void GetAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) override;
      void GetEndAI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, std::function<void(::grpc::Status)>) override;
      void GetEndAO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5001Data* response, std::function<void(::grpc::Status)>) override;
      void GetEL5001(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5001Data* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5101Data* response, std::function<void(::grpc::Status)>) override;
      void GetEL5101(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5101Data* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DeviceInfo* response, std::function<void(::grpc::Status)>) override;
      void GetDeviceInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DeviceInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BrakeControlStyle* response, std::function<void(::grpc::Status)>) override;
      void GetBrakeControlStyle(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BrakeControlStyle* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SanderCommand* response, std::function<void(::grpc::Status)>) override;
      void GetSanderCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SanderCommand* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FTSensorData* response, std::function<void(::grpc::Status)>) override;
      void GetFTSensorData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FTSensorData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Conveyor* response, std::function<void(::grpc::Status)>) override;
      void GetConveyor(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Conveyor* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorByName(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorEncoder(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorTrigger(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorOffset(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorStartingPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ConveyorState* response, std::function<void(::grpc::Status)>) override;
      void GetConveyorState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ConveyorState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response, std::function<void(::grpc::Status)>) override;
      void GetLoadFactors(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq* request, ::Nrmk::IndyFramework::SetAutoModeRes* response, std::function<void(::grpc::Status)>) override;
      void SetAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq* request, ::Nrmk::IndyFramework::SetAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckAutoModeRes* response, std::function<void(::grpc::Status)>) override;
      void CheckAutoMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckReducedModeRes* response, std::function<void(::grpc::Status)>) override;
      void CheckReducedMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckReducedModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyFunctionState* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyFunctionState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyFunctionState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void RequestSafetyFunction(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyControlData* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyControlData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyControlData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GripperData* response, std::function<void(::grpc::Status)>) override;
      void GetGripperData(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GripperData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetGripperCommand(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, std::function<void(::grpc::Status)>) override;
      void GetPhotoneoDetection(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, std::function<void(::grpc::Status)>) override;
      void GetPhotoneoRetrieval(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetBrakesRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetBrakesRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MotorList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetServoAllRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetServoAllRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Servo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DigitalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AnalogList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncExecuteToolRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncExecuteToolRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>* AsyncGetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>* PrepareAsyncGetEndRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>* AsyncGetEndRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>* PrepareAsyncGetEndRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetEndLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndLedDim& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>* AsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>* PrepareAsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>* AsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DigitalList>* PrepareAsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>* AsyncGetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>* PrepareAsyncGetEndDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>* AsyncGetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolSignalList>* PrepareAsyncGetEndDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* AsyncGetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* AsyncGetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* AsyncGetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetEndAIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* AsyncGetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AnalogList>* PrepareAsyncGetEndAORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5001Data>* AsyncGetEL5001Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5001Data>* PrepareAsyncGetEL5001Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5101Data>* AsyncGetEL5101Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetEL5101Data>* PrepareAsyncGetEL5101Raw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DeviceInfo>* AsyncGetDeviceInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DeviceInfo>* PrepareAsyncGetDeviceInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BrakeControlStyle>* AsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BrakeControlStyle>* PrepareAsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SanderCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SanderCommand>* AsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SanderCommand>* PrepareAsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FTSensorData>* AsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FTSensorData>* PrepareAsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Conveyor>* AsyncGetConveyorRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Conveyor>* PrepareAsyncGetConveyorRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Encoder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Trigger& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Float& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ConveyorState>* AsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ConveyorState>* PrepareAsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetLoadFactorsRes>* AsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetLoadFactorsRes>* PrepareAsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SetAutoModeRes>* AsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SetAutoModeRes>* PrepareAsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAutoModeRes>* AsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAutoModeRes>* PrepareAsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckReducedModeRes>* AsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckReducedModeRes>* PrepareAsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyFunctionState>* AsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyFunctionState>* PrepareAsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyControlData>* AsyncGetSafetyControlDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SafetyControlData>* PrepareAsyncGetSafetyControlDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GripperData>* AsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GripperData>* PrepareAsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GripperCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>* AsyncGetPhotoneoDetectionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>* PrepareAsyncGetPhotoneoDetectionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>* AsyncGetPhotoneoRetrievalRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::VisionResult>* PrepareAsyncGetPhotoneoRetrievalRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetBrakes_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServoAll_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServo_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndDI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndAI_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndAO_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteTool_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndRS485Rx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndRS485Rx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndRS485Tx_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndLedDim_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndDI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndAI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndAO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEL5001_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEL5101_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDeviceInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBrakeControlStyle_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSanderCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSanderCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFTSensorData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConveyor_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorName_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorByName_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorEncoder_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorTrigger_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorStartingPose_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorTerminalPose_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConveyorState_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLoadFactors_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAutoMode_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckAutoMode_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckReducedMode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyFunctionState_;
    const ::grpc::internal::RpcMethod rpcmethod_RequestSafetyFunction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyControlData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGripperData_;
    const ::grpc::internal::RpcMethod rpcmethod_SetGripperCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_AddPhotoneoCalibPoint_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPhotoneoDetection_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPhotoneoRetrieval_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SetBrakes(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MotorList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetServoAll(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetServo(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Servo* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetDI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetEndDI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetEndDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetAI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetAO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetEndAI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetEndAO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status ExecuteTool(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SetEndRS485Rx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status GetEndRS485Rx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response);
    virtual ::grpc::Status GetEndRS485Tx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response);
    virtual ::grpc::Status SetEndLedDim(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EndLedDim* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetDI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response);
    virtual ::grpc::Status GetDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response);
    virtual ::grpc::Status GetEndDI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response);
    virtual ::grpc::Status GetEndDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response);
    virtual ::grpc::Status GetAI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response);
    virtual ::grpc::Status GetAO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response);
    virtual ::grpc::Status GetEndAI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response);
    virtual ::grpc::Status GetEndAO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response);
    // beckhoff_conv
    virtual ::grpc::Status GetEL5001(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5001Data* response);
    virtual ::grpc::Status GetEL5101(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5101Data* response);
    virtual ::grpc::Status GetDeviceInfo(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DeviceInfo* response);
    virtual ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BrakeControlStyle* response);
    // ///////////// Sander ////////////////
    virtual ::grpc::Status SetSanderCommand(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::SanderCommand* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status GetSanderCommand(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SanderCommand* response);
    virtual ::grpc::Status GetFTSensorData(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FTSensorData* response);
    // ///////////// Conveyor ///////////////
    virtual ::grpc::Status GetConveyor(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Conveyor* response);
    virtual ::grpc::Status SetConveyorName(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetConveyorByName(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Encoder* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Trigger* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetConveyorOffset(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Float* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status GetConveyorState(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ConveyorState* response);
    // ///////////// Safety ////////////////
    virtual ::grpc::Status GetLoadFactors(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response);
    virtual ::grpc::Status SetAutoMode(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq* request, ::Nrmk::IndyFramework::SetAutoModeRes* response);
    virtual ::grpc::Status CheckAutoMode(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckAutoModeRes* response);
    virtual ::grpc::Status CheckReducedMode(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckReducedModeRes* response);
    virtual ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyFunctionState* response);
    virtual ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status GetSafetyControlData(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyControlData* response);
    // /////////////485Gripper//////////////////////
    virtual ::grpc::Status GetGripperData(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GripperData* response);
    virtual ::grpc::Status SetGripperCommand(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::GripperCommand* request, ::Nrmk::IndyFramework::Empty* response);
    // /////////////Photoneo Calibration//////////////////////
    virtual ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* request, ::Nrmk::IndyFramework::Response* response);
    // /////////////Photoneo Get Detection Retrieval//////////////////////
    virtual ::grpc::Status GetPhotoneoDetection(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response);
    virtual ::grpc::Status GetPhotoneoRetrieval(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetBrakes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetBrakes() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetBrakes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrakes(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MotorList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetBrakes(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MotorList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServoAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServoAll() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SetServoAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoAll(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoAll(::grpc::ServerContext* context, ::Nrmk::IndyFramework::State* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServo() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Servo* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServo(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Servo* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDI() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::DigitalList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDO() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::DigitalList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndDI() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EndtoolSignalList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndDO() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EndtoolSignalList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAI() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::AnalogList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAO() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::AnalogList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndAI() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::AnalogList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndAO() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::AnalogList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteTool(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Name* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndRS485Rx() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_SetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndRS485Rx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndRS485Rx() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndRS485Rx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolRS485Rx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndRS485Tx() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetEndRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndRS485Tx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolRS485Tx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndLedDim() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SetEndLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndLedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndLedDim(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EndLedDim* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDI() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::DigitalList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDO() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::DigitalList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndDI() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolSignalList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndDO() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolSignalList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAI() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::AnalogList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAO() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::AnalogList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndAI() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::AnalogList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndAO() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::AnalogList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEL5001() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5001Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5001(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::GetEL5001Data>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEL5101() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5101Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5101(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::GetEL5101Data>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDeviceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDeviceInfo() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_GetDeviceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DeviceInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDeviceInfo(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::DeviceInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBrakeControlStyle(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::BrakeControlStyle>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SanderCommand* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSanderCommand(::grpc::ServerContext* context, ::Nrmk::IndyFramework::SanderCommand* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSanderCommand(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SanderCommand>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFTSensorData(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::FTSensorData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConveyor() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyor(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Conveyor>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorName(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Name* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorByName(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Name* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Encoder* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorEncoder(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Encoder* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Trigger* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTrigger(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Trigger* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Float* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorOffset(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Float* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorStartingPose(::grpc::ServerContext* context, ::Nrmk::IndyFramework::PosePair* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTerminalPose(::grpc::ServerContext* context, ::Nrmk::IndyFramework::PosePair* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyorState(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ConveyorState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoadFactors(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::GetLoadFactorsRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SetAutoModeReq* /*request*/, ::Nrmk::IndyFramework::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoMode(::grpc::ServerContext* context, ::Nrmk::IndyFramework::SetAutoModeReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SetAutoModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAutoMode(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::CheckAutoModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckReducedMode(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::CheckReducedModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyFunctionState(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SafetyFunctionState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SafetyFunctionState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestSafetyFunction(::grpc::ServerContext* context, ::Nrmk::IndyFramework::SafetyFunctionState* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyControlData() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_GetSafetyControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyControlData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyControlData(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SafetyControlData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGripperData() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGripperData(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::GripperData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GripperCommand* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetGripperCommand(::grpc::ServerContext* context, ::Nrmk::IndyFramework::GripperCommand* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPhotoneoCalibPoint(::grpc::ServerContext* context, ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPhotoneoDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPhotoneoDetection() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_GetPhotoneoDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoDetection(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPhotoneoDetection(::grpc::ServerContext* context, ::Nrmk::IndyFramework::VisionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::VisionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPhotoneoRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPhotoneoRetrieval() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_GetPhotoneoRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoRetrieval(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPhotoneoRetrieval(::grpc::ServerContext* context, ::Nrmk::IndyFramework::VisionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::VisionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetBrakes<WithAsyncMethod_SetServoAll<WithAsyncMethod_SetServo<WithAsyncMethod_SetDI<WithAsyncMethod_SetDO<WithAsyncMethod_SetEndDI<WithAsyncMethod_SetEndDO<WithAsyncMethod_SetAI<WithAsyncMethod_SetAO<WithAsyncMethod_SetEndAI<WithAsyncMethod_SetEndAO<WithAsyncMethod_ExecuteTool<WithAsyncMethod_SetEndRS485Rx<WithAsyncMethod_GetEndRS485Rx<WithAsyncMethod_GetEndRS485Tx<WithAsyncMethod_SetEndLedDim<WithAsyncMethod_GetDI<WithAsyncMethod_GetDO<WithAsyncMethod_GetEndDI<WithAsyncMethod_GetEndDO<WithAsyncMethod_GetAI<WithAsyncMethod_GetAO<WithAsyncMethod_GetEndAI<WithAsyncMethod_GetEndAO<WithAsyncMethod_GetEL5001<WithAsyncMethod_GetEL5101<WithAsyncMethod_GetDeviceInfo<WithAsyncMethod_GetBrakeControlStyle<WithAsyncMethod_SetSanderCommand<WithAsyncMethod_GetSanderCommand<WithAsyncMethod_GetFTSensorData<WithAsyncMethod_GetConveyor<WithAsyncMethod_SetConveyorName<WithAsyncMethod_SetConveyorByName<WithAsyncMethod_SetConveyorEncoder<WithAsyncMethod_SetConveyorTrigger<WithAsyncMethod_SetConveyorOffset<WithAsyncMethod_SetConveyorStartingPose<WithAsyncMethod_SetConveyorTerminalPose<WithAsyncMethod_GetConveyorState<WithAsyncMethod_GetLoadFactors<WithAsyncMethod_SetAutoMode<WithAsyncMethod_CheckAutoMode<WithAsyncMethod_CheckReducedMode<WithAsyncMethod_GetSafetyFunctionState<WithAsyncMethod_RequestSafetyFunction<WithAsyncMethod_GetSafetyControlData<WithAsyncMethod_GetGripperData<WithAsyncMethod_SetGripperCommand<WithAsyncMethod_AddPhotoneoCalibPoint<WithAsyncMethod_GetPhotoneoDetection<WithAsyncMethod_GetPhotoneoRetrieval<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SetBrakes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetBrakes() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MotorList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MotorList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetBrakes(context, request, response); }));}
    void SetMessageAllocatorFor_SetBrakes(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MotorList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MotorList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetBrakes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrakes(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MotorList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetBrakes(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MotorList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServoAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServoAll() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response) { return this->SetServoAll(context, request, response); }));}
    void SetMessageAllocatorFor_SetServoAll(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServoAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoAll(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoAll(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServo() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Servo, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Servo* request, ::Nrmk::IndyFramework::Response* response) { return this->SetServo(context, request, response); }));}
    void SetMessageAllocatorFor_SetServo(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Servo, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Servo, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Servo* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServo(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Servo* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDI() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetDI(context, request, response); }));}
    void SetMessageAllocatorFor_SetDI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDO() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::DigitalList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndDI() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetEndDI(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndDI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndDI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndDO() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EndtoolSignalList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetEndDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAI() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetAI(context, request, response); }));}
    void SetMessageAllocatorFor_SetAI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAO() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetAO(context, request, response); }));}
    void SetMessageAllocatorFor_SetAO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndAI() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetEndAI(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndAI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndAI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndAO() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::AnalogList* request, ::Nrmk::IndyFramework::Response* response) { return this->SetEndAO(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndAO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndAO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Empty* response) { return this->ExecuteTool(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteTool(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteTool(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndRS485Rx() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Response* response) { return this->SetEndRS485Rx(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndRS485Rx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndRS485Rx() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response) { return this->GetEndRS485Rx(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndRS485Rx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndRS485Tx() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response) { return this->GetEndRS485Tx(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndRS485Tx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndRS485Tx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndLedDim() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndLedDim, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EndLedDim* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetEndLedDim(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndLedDim(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EndLedDim, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndLedDim, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndLedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndLedDim(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EndLedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDI() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response) { return this->GetDI(context, request, response); }));}
    void SetMessageAllocatorFor_GetDI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDO() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DigitalList* response) { return this->GetDO(context, request, response); }));}
    void SetMessageAllocatorFor_GetDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndDI() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response) { return this->GetEndDI(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndDI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndDI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndDO() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolSignalList* response) { return this->GetEndDO(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAI() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response) { return this->GetAI(context, request, response); }));}
    void SetMessageAllocatorFor_GetAI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAO() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response) { return this->GetAO(context, request, response); }));}
    void SetMessageAllocatorFor_GetAO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndAI() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response) { return this->GetEndAI(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndAI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndAI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndAO() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AnalogList* response) { return this->GetEndAO(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndAO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndAO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEL5001() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5001Data>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5001Data* response) { return this->GetEL5001(context, request, response); }));}
    void SetMessageAllocatorFor_GetEL5001(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5001Data>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5001Data>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5001Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEL5001(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5001Data* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEL5101() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5101Data>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetEL5101Data* response) { return this->GetEL5101(context, request, response); }));}
    void SetMessageAllocatorFor_GetEL5101(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5101Data>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5101Data>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5101Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEL5101(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5101Data* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDeviceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDeviceInfo() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DeviceInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::DeviceInfo* response) { return this->GetDeviceInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetDeviceInfo(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DeviceInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DeviceInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDeviceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DeviceInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDeviceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DeviceInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BrakeControlStyle>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BrakeControlStyle* response) { return this->GetBrakeControlStyle(context, request, response); }));}
    void SetMessageAllocatorFor_GetBrakeControlStyle(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BrakeControlStyle>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BrakeControlStyle>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBrakeControlStyle(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BrakeControlStyle* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SanderCommand, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::SanderCommand* request, ::Nrmk::IndyFramework::Response* response) { return this->SetSanderCommand(context, request, response); }));}
    void SetMessageAllocatorFor_SetSanderCommand(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::SanderCommand, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SanderCommand, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SanderCommand* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::SanderCommand* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SanderCommand>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SanderCommand* response) { return this->GetSanderCommand(context, request, response); }));}
    void SetMessageAllocatorFor_GetSanderCommand(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SanderCommand>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SanderCommand>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SanderCommand* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FTSensorData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FTSensorData* response) { return this->GetFTSensorData(context, request, response); }));}
    void SetMessageAllocatorFor_GetFTSensorData(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FTSensorData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FTSensorData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFTSensorData(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FTSensorData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConveyor() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Conveyor>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Conveyor* response) { return this->GetConveyor(context, request, response); }));}
    void SetMessageAllocatorFor_GetConveyor(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Conveyor>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Conveyor>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyor(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Conveyor* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response) { return this->SetConveyorName(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorName(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorName(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Name* request, ::Nrmk::IndyFramework::Response* response) { return this->SetConveyorByName(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorByName(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorByName(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Encoder, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Encoder* request, ::Nrmk::IndyFramework::Response* response) { return this->SetConveyorEncoder(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorEncoder(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Encoder, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Encoder, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Encoder* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorEncoder(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Encoder* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Trigger, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Trigger* request, ::Nrmk::IndyFramework::Response* response) { return this->SetConveyorTrigger(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorTrigger(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Trigger, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Trigger, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Trigger* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTrigger(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Trigger* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Float, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Float* request, ::Nrmk::IndyFramework::Response* response) { return this->SetConveyorOffset(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorOffset(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Float, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Float, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Float* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Float* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response) { return this->SetConveyorStartingPose(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorStartingPose(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorStartingPose(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::PosePair* request, ::Nrmk::IndyFramework::Response* response) { return this->SetConveyorTerminalPose(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorTerminalPose(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTerminalPose(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ConveyorState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ConveyorState* response) { return this->GetConveyorState(context, request, response); }));}
    void SetMessageAllocatorFor_GetConveyorState(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ConveyorState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ConveyorState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyorState(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ConveyorState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetLoadFactorsRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GetLoadFactorsRes* response) { return this->GetLoadFactors(context, request, response); }));}
    void SetMessageAllocatorFor_GetLoadFactors(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetLoadFactorsRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetLoadFactorsRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLoadFactors(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetLoadFactorsRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SetAutoModeReq, ::Nrmk::IndyFramework::SetAutoModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::SetAutoModeReq* request, ::Nrmk::IndyFramework::SetAutoModeRes* response) { return this->SetAutoMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetAutoMode(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::SetAutoModeReq, ::Nrmk::IndyFramework::SetAutoModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SetAutoModeReq, ::Nrmk::IndyFramework::SetAutoModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SetAutoModeReq* /*request*/, ::Nrmk::IndyFramework::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::SetAutoModeReq* /*request*/, ::Nrmk::IndyFramework::SetAutoModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckAutoModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckAutoModeRes* response) { return this->CheckAutoMode(context, request, response); }));}
    void SetMessageAllocatorFor_CheckAutoMode(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckAutoModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckAutoModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckAutoModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckReducedModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::CheckReducedModeRes* response) { return this->CheckReducedMode(context, request, response); }));}
    void SetMessageAllocatorFor_CheckReducedMode(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckReducedModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckReducedModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckReducedMode(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckReducedModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyFunctionState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyFunctionState* response) { return this->GetSafetyFunctionState(context, request, response); }));}
    void SetMessageAllocatorFor_GetSafetyFunctionState(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyFunctionState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyFunctionState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyFunctionState(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyFunctionState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SafetyFunctionState, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::SafetyFunctionState* request, ::Nrmk::IndyFramework::Response* response) { return this->RequestSafetyFunction(context, request, response); }));}
    void SetMessageAllocatorFor_RequestSafetyFunction(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::SafetyFunctionState, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SafetyFunctionState, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SafetyFunctionState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestSafetyFunction(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::SafetyFunctionState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSafetyControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSafetyControlData() {
      ::grpc::Service::MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyControlData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SafetyControlData* response) { return this->GetSafetyControlData(context, request, response); }));}
    void SetMessageAllocatorFor_GetSafetyControlData(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyControlData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyControlData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSafetyControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyControlData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyControlData(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyControlData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGripperData() {
      ::grpc::Service::MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GripperData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::GripperData* response) { return this->GetGripperData(context, request, response); }));}
    void SetMessageAllocatorFor_GetGripperData(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GripperData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GripperData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGripperData(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GripperData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::GripperCommand, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::GripperCommand* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetGripperCommand(context, request, response); }));}
    void SetMessageAllocatorFor_SetGripperCommand(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::GripperCommand, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::GripperCommand, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GripperCommand* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetGripperCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::GripperCommand* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* request, ::Nrmk::IndyFramework::Response* response) { return this->AddPhotoneoCalibPoint(context, request, response); }));}
    void SetMessageAllocatorFor_AddPhotoneoCalibPoint(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPhotoneoCalibPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPhotoneoDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPhotoneoDetection() {
      ::grpc::Service::MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response) { return this->GetPhotoneoDetection(context, request, response); }));}
    void SetMessageAllocatorFor_GetPhotoneoDetection(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPhotoneoDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoDetection(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPhotoneoDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPhotoneoRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPhotoneoRetrieval() {
      ::grpc::Service::MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::VisionRequest* request, ::Nrmk::IndyFramework::VisionResult* response) { return this->GetPhotoneoRetrieval(context, request, response); }));}
    void SetMessageAllocatorFor_GetPhotoneoRetrieval(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPhotoneoRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoRetrieval(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPhotoneoRetrieval(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SetBrakes<WithCallbackMethod_SetServoAll<WithCallbackMethod_SetServo<WithCallbackMethod_SetDI<WithCallbackMethod_SetDO<WithCallbackMethod_SetEndDI<WithCallbackMethod_SetEndDO<WithCallbackMethod_SetAI<WithCallbackMethod_SetAO<WithCallbackMethod_SetEndAI<WithCallbackMethod_SetEndAO<WithCallbackMethod_ExecuteTool<WithCallbackMethod_SetEndRS485Rx<WithCallbackMethod_GetEndRS485Rx<WithCallbackMethod_GetEndRS485Tx<WithCallbackMethod_SetEndLedDim<WithCallbackMethod_GetDI<WithCallbackMethod_GetDO<WithCallbackMethod_GetEndDI<WithCallbackMethod_GetEndDO<WithCallbackMethod_GetAI<WithCallbackMethod_GetAO<WithCallbackMethod_GetEndAI<WithCallbackMethod_GetEndAO<WithCallbackMethod_GetEL5001<WithCallbackMethod_GetEL5101<WithCallbackMethod_GetDeviceInfo<WithCallbackMethod_GetBrakeControlStyle<WithCallbackMethod_SetSanderCommand<WithCallbackMethod_GetSanderCommand<WithCallbackMethod_GetFTSensorData<WithCallbackMethod_GetConveyor<WithCallbackMethod_SetConveyorName<WithCallbackMethod_SetConveyorByName<WithCallbackMethod_SetConveyorEncoder<WithCallbackMethod_SetConveyorTrigger<WithCallbackMethod_SetConveyorOffset<WithCallbackMethod_SetConveyorStartingPose<WithCallbackMethod_SetConveyorTerminalPose<WithCallbackMethod_GetConveyorState<WithCallbackMethod_GetLoadFactors<WithCallbackMethod_SetAutoMode<WithCallbackMethod_CheckAutoMode<WithCallbackMethod_CheckReducedMode<WithCallbackMethod_GetSafetyFunctionState<WithCallbackMethod_RequestSafetyFunction<WithCallbackMethod_GetSafetyControlData<WithCallbackMethod_GetGripperData<WithCallbackMethod_SetGripperCommand<WithCallbackMethod_AddPhotoneoCalibPoint<WithCallbackMethod_GetPhotoneoDetection<WithCallbackMethod_GetPhotoneoRetrieval<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetBrakes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetBrakes() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetBrakes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrakes(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MotorList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServoAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServoAll() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SetServoAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoAll(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServo() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Servo* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDI() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDO() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndDI() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndDO() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAI() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAO() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndAI() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndAO() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndRS485Rx() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_SetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndRS485Rx() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndRS485Tx() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetEndRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndLedDim() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SetEndLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndLedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDI() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDO() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndDI() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndDO() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAI() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAO() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndAI() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndAO() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEL5001() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5001Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEL5101() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5101Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDeviceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDeviceInfo() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_GetDeviceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DeviceInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SanderCommand* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConveyor() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Encoder* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Trigger* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Float* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SetAutoModeReq* /*request*/, ::Nrmk::IndyFramework::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SafetyFunctionState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyControlData() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_GetSafetyControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyControlData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGripperData() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GripperCommand* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPhotoneoDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPhotoneoDetection() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_GetPhotoneoDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoDetection(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPhotoneoRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPhotoneoRetrieval() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_GetPhotoneoRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoRetrieval(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetBrakes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetBrakes() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetBrakes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrakes(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MotorList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetBrakes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServoAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServoAll() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SetServoAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoAll(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServo() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Servo* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDI() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDO() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndDI() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndDO() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAI() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAO() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndAI() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndAO() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteTool(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndRS485Rx() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_SetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndRS485Rx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndRS485Rx() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndRS485Rx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndRS485Tx() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetEndRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndRS485Tx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndLedDim() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SetEndLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndLedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndLedDim(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDI() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDO() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndDI() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndDO() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAI() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAO() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndAI() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndAO() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEL5001() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5001Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5001(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEL5101() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5101Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEL5101(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDeviceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDeviceInfo() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_GetDeviceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DeviceInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDeviceInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBrakeControlStyle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SanderCommand* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSanderCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSanderCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFTSensorData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConveyor() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorByName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Encoder* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorEncoder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Trigger* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTrigger(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Float* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorStartingPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTerminalPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyorState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoadFactors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SetAutoModeReq* /*request*/, ::Nrmk::IndyFramework::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAutoMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckReducedMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyFunctionState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SafetyFunctionState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestSafetyFunction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyControlData() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_GetSafetyControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyControlData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyControlData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGripperData() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGripperData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GripperCommand* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetGripperCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPhotoneoCalibPoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPhotoneoDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPhotoneoDetection() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_GetPhotoneoDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoDetection(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPhotoneoDetection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPhotoneoRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPhotoneoRetrieval() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_GetPhotoneoRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoRetrieval(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPhotoneoRetrieval(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetBrakes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetBrakes() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetBrakes(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetBrakes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrakes(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MotorList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetBrakes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServoAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServoAll() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServoAll(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServoAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoAll(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServo() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServo(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Servo* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDI() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDI(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDO() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndDI() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndDI(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndDI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndDO() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAI() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAI(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAO() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndAI() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndAI(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndAI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndAO() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndAO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndAO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteTool(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteTool(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndRS485Rx() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndRS485Rx(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndRS485Rx() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndRS485Rx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndRS485Tx() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndRS485Tx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndRS485Tx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndLedDim() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndLedDim(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndLedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndLedDim(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDI() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDI(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDO() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndDI() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndDI(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndDI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndDO() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAI() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAI(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAO() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndAI() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndAI(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndAI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndAO() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndAO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndAO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEL5001() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEL5001(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5001Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEL5001(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEL5101() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEL5101(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5101Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEL5101(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDeviceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDeviceInfo() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDeviceInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDeviceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DeviceInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDeviceInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBrakeControlStyle(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBrakeControlStyle(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSanderCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SanderCommand* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSanderCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFTSensorData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFTSensorData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConveyor() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConveyor(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorName(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorByName(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorByName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorEncoder(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Encoder* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorEncoder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorTrigger(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Trigger* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTrigger(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorOffset(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Float* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorStartingPose(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorStartingPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorTerminalPose(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTerminalPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConveyorState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyorState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLoadFactors(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLoadFactors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAutoMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SetAutoModeReq* /*request*/, ::Nrmk::IndyFramework::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckAutoMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckReducedMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckReducedMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSafetyFunctionState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyFunctionState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RequestSafetyFunction(context, request, response); }));
    }
    ~WithRawCallbackMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SafetyFunctionState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestSafetyFunction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSafetyControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSafetyControlData() {
      ::grpc::Service::MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSafetyControlData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSafetyControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyControlData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyControlData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGripperData() {
      ::grpc::Service::MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGripperData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGripperData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetGripperCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GripperCommand* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetGripperCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddPhotoneoCalibPoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPhotoneoCalibPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPhotoneoDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPhotoneoDetection() {
      ::grpc::Service::MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPhotoneoDetection(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPhotoneoDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoDetection(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPhotoneoDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPhotoneoRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPhotoneoRetrieval() {
      ::grpc::Service::MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPhotoneoRetrieval(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPhotoneoRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPhotoneoRetrieval(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPhotoneoRetrieval(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetBrakes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetBrakes() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MotorList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MotorList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetBrakes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetBrakes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetBrakes(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MotorList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetBrakes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MotorList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServoAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServoAll() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetServoAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServoAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServoAll(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServoAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::State,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServo() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Servo, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Servo, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetServo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Servo* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Servo,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDI() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetDI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::DigitalList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDO() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::DigitalList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DigitalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::DigitalList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndDI() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetEndDI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EndtoolSignalList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndDO() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EndtoolSignalList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetEndDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolSignalList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EndtoolSignalList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAI() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetAI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::AnalogList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAO() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetAO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::AnalogList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndAI() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetEndAI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::AnalogList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndAO() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::AnalogList, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetEndAO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AnalogList* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::AnalogList,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedExecuteTool(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteTool(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Name,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndRS485Rx() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetEndRS485Rx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndRS485Rx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EndtoolRS485Rx,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndRS485Rx() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>* streamer) {
                       return this->StreamedGetEndRS485Rx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndRS485Rx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolRS485Rx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndRS485Tx() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>* streamer) {
                       return this->StreamedGetEndRS485Tx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndRS485Tx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolRS485Tx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndLedDim() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EndLedDim, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EndLedDim, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetEndLedDim(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndLedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndLedDim(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EndLedDim,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDI() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>* streamer) {
                       return this->StreamedGetDI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::DigitalList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDO() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DigitalList>* streamer) {
                       return this->StreamedGetDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DigitalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::DigitalList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndDI() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>* streamer) {
                       return this->StreamedGetEndDI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolSignalList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndDO() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolSignalList>* streamer) {
                       return this->StreamedGetEndDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolSignalList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolSignalList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAI() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* streamer) {
                       return this->StreamedGetAI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::AnalogList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAO() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* streamer) {
                       return this->StreamedGetAO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::AnalogList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndAI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndAI() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* streamer) {
                       return this->StreamedGetEndAI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndAI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndAI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndAI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::AnalogList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndAO() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AnalogList>* streamer) {
                       return this->StreamedGetEndAO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndAO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AnalogList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::AnalogList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEL5001 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEL5001() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5001Data>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5001Data>* streamer) {
                       return this->StreamedGetEL5001(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEL5001() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEL5001(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5001Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEL5001(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::GetEL5001Data>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEL5101 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEL5101() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5101Data>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetEL5101Data>* streamer) {
                       return this->StreamedGetEL5101(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEL5101() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEL5101(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetEL5101Data* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEL5101(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::GetEL5101Data>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDeviceInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDeviceInfo() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DeviceInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::DeviceInfo>* streamer) {
                       return this->StreamedGetDeviceInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDeviceInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDeviceInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::DeviceInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDeviceInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::DeviceInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BrakeControlStyle>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BrakeControlStyle>* streamer) {
                       return this->StreamedGetBrakeControlStyle(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBrakeControlStyle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::BrakeControlStyle>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::SanderCommand, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::SanderCommand, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetSanderCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SanderCommand* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSanderCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::SanderCommand,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SanderCommand>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SanderCommand>* streamer) {
                       return this->StreamedGetSanderCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSanderCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::SanderCommand>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FTSensorData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FTSensorData>* streamer) {
                       return this->StreamedGetFTSensorData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFTSensorData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::FTSensorData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConveyor() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Conveyor>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Conveyor>* streamer) {
                       return this->StreamedGetConveyor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConveyor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Conveyor>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetConveyorName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Name,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Name, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetConveyorByName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Name* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorByName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Name,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Encoder, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Encoder, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetConveyorEncoder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Encoder* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorEncoder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Encoder,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Trigger, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Trigger, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetConveyorTrigger(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Trigger* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorTrigger(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Trigger,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Float, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Float, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetConveyorOffset(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Float* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorOffset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Float,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetConveyorStartingPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorStartingPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::PosePair,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::PosePair, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetConveyorTerminalPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PosePair* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorTerminalPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::PosePair,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ConveyorState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ConveyorState>* streamer) {
                       return this->StreamedGetConveyorState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConveyorState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::ConveyorState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetLoadFactorsRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GetLoadFactorsRes>* streamer) {
                       return this->StreamedGetLoadFactors(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLoadFactors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::GetLoadFactorsRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::SetAutoModeReq, ::Nrmk::IndyFramework::SetAutoModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::SetAutoModeReq, ::Nrmk::IndyFramework::SetAutoModeRes>* streamer) {
                       return this->StreamedSetAutoMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SetAutoModeReq* /*request*/, ::Nrmk::IndyFramework::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAutoMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::SetAutoModeReq,::Nrmk::IndyFramework::SetAutoModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckAutoModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckAutoModeRes>* streamer) {
                       return this->StreamedCheckAutoMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckAutoMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::CheckAutoModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckReducedModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::CheckReducedModeRes>* streamer) {
                       return this->StreamedCheckReducedMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckReducedMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::CheckReducedModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyFunctionState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyFunctionState>* streamer) {
                       return this->StreamedGetSafetyFunctionState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyFunctionState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::SafetyFunctionState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::SafetyFunctionState, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::SafetyFunctionState, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedRequestSafetyFunction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SafetyFunctionState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestSafetyFunction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::SafetyFunctionState,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyControlData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyControlData() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyControlData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SafetyControlData>* streamer) {
                       return this->StreamedGetSafetyControlData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSafetyControlData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyControlData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SafetyControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyControlData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::SafetyControlData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGripperData() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GripperData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::GripperData>* streamer) {
                       return this->StreamedGetGripperData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGripperData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::GripperData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::GripperCommand, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::GripperCommand, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetGripperCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GripperCommand* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetGripperCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::GripperCommand,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedAddPhotoneoCalibPoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddPhotoneoCalibPoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::AddPhotoneoCalibPointReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPhotoneoDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPhotoneoDetection() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>* streamer) {
                       return this->StreamedGetPhotoneoDetection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPhotoneoDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPhotoneoDetection(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPhotoneoDetection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::VisionRequest,::Nrmk::IndyFramework::VisionResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPhotoneoRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPhotoneoRetrieval() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::VisionRequest, ::Nrmk::IndyFramework::VisionResult>* streamer) {
                       return this->StreamedGetPhotoneoRetrieval(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPhotoneoRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPhotoneoRetrieval(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::VisionRequest* /*request*/, ::Nrmk::IndyFramework::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPhotoneoRetrieval(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::VisionRequest,::Nrmk::IndyFramework::VisionResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetBrakes<WithStreamedUnaryMethod_SetServoAll<WithStreamedUnaryMethod_SetServo<WithStreamedUnaryMethod_SetDI<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_SetEndDI<WithStreamedUnaryMethod_SetEndDO<WithStreamedUnaryMethod_SetAI<WithStreamedUnaryMethod_SetAO<WithStreamedUnaryMethod_SetEndAI<WithStreamedUnaryMethod_SetEndAO<WithStreamedUnaryMethod_ExecuteTool<WithStreamedUnaryMethod_SetEndRS485Rx<WithStreamedUnaryMethod_GetEndRS485Rx<WithStreamedUnaryMethod_GetEndRS485Tx<WithStreamedUnaryMethod_SetEndLedDim<WithStreamedUnaryMethod_GetDI<WithStreamedUnaryMethod_GetDO<WithStreamedUnaryMethod_GetEndDI<WithStreamedUnaryMethod_GetEndDO<WithStreamedUnaryMethod_GetAI<WithStreamedUnaryMethod_GetAO<WithStreamedUnaryMethod_GetEndAI<WithStreamedUnaryMethod_GetEndAO<WithStreamedUnaryMethod_GetEL5001<WithStreamedUnaryMethod_GetEL5101<WithStreamedUnaryMethod_GetDeviceInfo<WithStreamedUnaryMethod_GetBrakeControlStyle<WithStreamedUnaryMethod_SetSanderCommand<WithStreamedUnaryMethod_GetSanderCommand<WithStreamedUnaryMethod_GetFTSensorData<WithStreamedUnaryMethod_GetConveyor<WithStreamedUnaryMethod_SetConveyorName<WithStreamedUnaryMethod_SetConveyorByName<WithStreamedUnaryMethod_SetConveyorEncoder<WithStreamedUnaryMethod_SetConveyorTrigger<WithStreamedUnaryMethod_SetConveyorOffset<WithStreamedUnaryMethod_SetConveyorStartingPose<WithStreamedUnaryMethod_SetConveyorTerminalPose<WithStreamedUnaryMethod_GetConveyorState<WithStreamedUnaryMethod_GetLoadFactors<WithStreamedUnaryMethod_SetAutoMode<WithStreamedUnaryMethod_CheckAutoMode<WithStreamedUnaryMethod_CheckReducedMode<WithStreamedUnaryMethod_GetSafetyFunctionState<WithStreamedUnaryMethod_RequestSafetyFunction<WithStreamedUnaryMethod_GetSafetyControlData<WithStreamedUnaryMethod_GetGripperData<WithStreamedUnaryMethod_SetGripperCommand<WithStreamedUnaryMethod_AddPhotoneoCalibPoint<WithStreamedUnaryMethod_GetPhotoneoDetection<WithStreamedUnaryMethod_GetPhotoneoRetrieval<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetBrakes<WithStreamedUnaryMethod_SetServoAll<WithStreamedUnaryMethod_SetServo<WithStreamedUnaryMethod_SetDI<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_SetEndDI<WithStreamedUnaryMethod_SetEndDO<WithStreamedUnaryMethod_SetAI<WithStreamedUnaryMethod_SetAO<WithStreamedUnaryMethod_SetEndAI<WithStreamedUnaryMethod_SetEndAO<WithStreamedUnaryMethod_ExecuteTool<WithStreamedUnaryMethod_SetEndRS485Rx<WithStreamedUnaryMethod_GetEndRS485Rx<WithStreamedUnaryMethod_GetEndRS485Tx<WithStreamedUnaryMethod_SetEndLedDim<WithStreamedUnaryMethod_GetDI<WithStreamedUnaryMethod_GetDO<WithStreamedUnaryMethod_GetEndDI<WithStreamedUnaryMethod_GetEndDO<WithStreamedUnaryMethod_GetAI<WithStreamedUnaryMethod_GetAO<WithStreamedUnaryMethod_GetEndAI<WithStreamedUnaryMethod_GetEndAO<WithStreamedUnaryMethod_GetEL5001<WithStreamedUnaryMethod_GetEL5101<WithStreamedUnaryMethod_GetDeviceInfo<WithStreamedUnaryMethod_GetBrakeControlStyle<WithStreamedUnaryMethod_SetSanderCommand<WithStreamedUnaryMethod_GetSanderCommand<WithStreamedUnaryMethod_GetFTSensorData<WithStreamedUnaryMethod_GetConveyor<WithStreamedUnaryMethod_SetConveyorName<WithStreamedUnaryMethod_SetConveyorByName<WithStreamedUnaryMethod_SetConveyorEncoder<WithStreamedUnaryMethod_SetConveyorTrigger<WithStreamedUnaryMethod_SetConveyorOffset<WithStreamedUnaryMethod_SetConveyorStartingPose<WithStreamedUnaryMethod_SetConveyorTerminalPose<WithStreamedUnaryMethod_GetConveyorState<WithStreamedUnaryMethod_GetLoadFactors<WithStreamedUnaryMethod_SetAutoMode<WithStreamedUnaryMethod_CheckAutoMode<WithStreamedUnaryMethod_CheckReducedMode<WithStreamedUnaryMethod_GetSafetyFunctionState<WithStreamedUnaryMethod_RequestSafetyFunction<WithStreamedUnaryMethod_GetSafetyControlData<WithStreamedUnaryMethod_GetGripperData<WithStreamedUnaryMethod_SetGripperCommand<WithStreamedUnaryMethod_AddPhotoneoCalibPoint<WithStreamedUnaryMethod_GetPhotoneoDetection<WithStreamedUnaryMethod_GetPhotoneoRetrieval<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace IndyFramework
}  // namespace Nrmk


#endif  // GRPC_device_2eproto__INCLUDED
