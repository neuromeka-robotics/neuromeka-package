// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: control.proto
#ifndef GRPC_control_2eproto__INCLUDED
#define GRPC_control_2eproto__INCLUDED

#include "control.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace Nrmk {
namespace IndyFramework {

class Control final {
 public:
  static constexpr char const* service_full_name() {
    return "Nrmk.IndyFramework.Control";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::ControlInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ControlInfo>> AsyncGetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ControlInfo>>(AsyncGetControlInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ControlInfo>> PrepareAsyncGetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ControlInfo>>(PrepareAsyncGetControlInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status ActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::Nrmk::IndyFramework::SDKLicenseResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDKLicenseResp>> AsyncActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDKLicenseResp>>(AsyncActivateIndySDKRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDKLicenseResp>> PrepareAsyncActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDKLicenseResp>>(PrepareAsyncActivateIndySDKRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Motion
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status MoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveJRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveJTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveJTRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveLRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveLTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveLTRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveCRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveCRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveCTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveCTRaw(context, request, cq));
    }
    virtual ::grpc::Status WaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncWaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncWaitIORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitIORaw(context, request, cq));
    }
    virtual ::grpc::Status WaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncWaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncWaitTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status WaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncWaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncWaitProgressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitProgressRaw(context, request, cq));
    }
    virtual ::grpc::Status WaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncWaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncWaitTrajRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitTrajRaw(context, request, cq));
    }
    virtual ::grpc::Status WaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncWaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncWaitRadiusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitRadiusRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveJCondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveJCondRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Command
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status StopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncStopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncStopMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncStopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStopMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status PauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncPauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncPauseMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncPauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncPauseMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetDirectTeachingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetDirectTeachingRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetSimulationModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetSimulationModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetCustomControlModeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IntMode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntMode>> AsyncGetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntMode>>(AsyncGetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntMode>> PrepareAsyncGetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntMode>>(PrepareAsyncGetCustomControlModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetFrictionCompensationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetFrictionCompensationRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::State* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::State>> AsyncGetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::State>>(AsyncGetFrictionCompensationStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::State>> PrepareAsyncGetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::State>>(PrepareAsyncGetFrictionCompensationStateRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Violation Recovery
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status Recover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncRecover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    virtual ::grpc::Status SetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetManualRecoveryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetManualRecoveryRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveRecoverJointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveRecoverJointRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Program
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::Nrmk::IndyFramework::ProgramInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ProgramInfo>> AsyncSearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ProgramInfo>>(AsyncSearchProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ProgramInfo>> PrepareAsyncSearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ProgramInfo>>(PrepareAsyncSearchProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status PlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncPlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncPlayProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncPlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncPlayProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status PauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncPauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncPauseProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncPauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncPauseProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status ResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncResumeProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncResumeProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status StopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncStopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncStopProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncStopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStopProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status SendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSendAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSendAlarmRaw(context, request, cq));
    }
    virtual ::grpc::Status SendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSendAnnotationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSendAnnotationRaw(context, request, cq));
    }
    virtual ::grpc::Status PlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::Nrmk::IndyFramework::CollisionThresholds* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CollisionThresholds>> AsyncPlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CollisionThresholds>>(AsyncPlayTuningProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CollisionThresholds>> PrepareAsyncPlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CollisionThresholds>>(PrepareAsyncPlayTuningProgramRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Custom Variable
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetModbusVariableNameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetModbusVariableNameListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetVariableNameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetVariableNameListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AllVars* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AllVars>> AsyncGetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AllVars>>(AsyncGetVariableNameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AllVars>> PrepareAsyncGetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AllVars>>(PrepareAsyncGetVariableNameListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetIntVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetIntVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IntVars* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntVars>> AsyncGetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntVars>>(AsyncGetIntVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntVars>> PrepareAsyncGetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntVars>>(PrepareAsyncGetIntVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status SetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetModbusVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetModbusVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status GetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::ModbusVars* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ModbusVars>> AsyncGetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ModbusVars>>(AsyncGetModbusVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ModbusVars>> PrepareAsyncGetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ModbusVars>>(PrepareAsyncGetModbusVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status SetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetBoolVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetBoolVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::BoolVars* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BoolVars>> AsyncGetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BoolVars>>(AsyncGetBoolVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BoolVars>> PrepareAsyncGetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BoolVars>>(PrepareAsyncGetBoolVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status SetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetFloatVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetFloatVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::FloatVars* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FloatVars>> AsyncGetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FloatVars>>(AsyncGetFloatVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FloatVars>> PrepareAsyncGetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FloatVars>>(PrepareAsyncGetFloatVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status SetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetJPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetJPosVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::JPosVars* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::JPosVars>> AsyncGetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::JPosVars>>(AsyncGetJPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::JPosVars>> PrepareAsyncGetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::JPosVars>>(PrepareAsyncGetJPosVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetTPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetTPosVariableRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TPosVars* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TPosVars>> AsyncGetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TPosVars>>(AsyncGetTPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TPosVars>> PrepareAsyncGetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TPosVars>>(PrepareAsyncGetTPosVariableRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Utility
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::Nrmk::IndyFramework::InverseKinematicsRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::InverseKinematicsRes>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::InverseKinematicsRes>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::InverseKinematicsRes>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::InverseKinematicsRes>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>> AsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>>(AsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>> PrepareAsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>>(PrepareAsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::Nrmk::IndyFramework::GetPalletPointListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetPalletPointListRes>> AsyncGetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetPalletPointListRes>>(AsyncGetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetPalletPointListRes>> PrepareAsyncGetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetPalletPointListRes>>(PrepareAsyncGetPalletPointListRaw(context, request, cq));
    }
    virtual ::grpc::Status CalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateRelativePoseRes>> AsyncCalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateRelativePoseRes>>(AsyncCalculateRelativePoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateRelativePoseRes>> PrepareAsyncCalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateRelativePoseRes>>(PrepareAsyncCalculateRelativePoseRaw(context, request, cq));
    }
    virtual ::grpc::Status CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>> AsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>>(AsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>> PrepareAsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>>(PrepareAsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    virtual ::grpc::Status PingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncPingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncPingFromContyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncPingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncPingFromContyRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // TeleOperation
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleOpDevice* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpDevice>> AsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpDevice>>(AsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpDevice>> PrepareAsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpDevice>>(PrepareAsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleOpState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpState>> AsyncGetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpState>>(AsyncGetTeleOpStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpState>> PrepareAsyncGetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpState>>(PrepareAsyncGetTeleOpStateRaw(context, request, cq));
    }
    virtual ::grpc::Status ConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    virtual ::grpc::Status DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleP* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleP>> AsyncReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleP>>(AsyncReadTeleOpInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleP>> PrepareAsyncReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleP>>(PrepareAsyncReadTeleOpInputRaw(context, request, cq));
    }
    virtual ::grpc::Status StartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncStartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncStartTeleOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncStartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStartTeleOpRaw(context, request, cq));
    }
    virtual ::grpc::Status StopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncStopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncStopTeleOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncStopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStopTeleOpRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetPlayRateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TelePlayRate* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TelePlayRate>> AsyncGetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TelePlayRate>>(AsyncGetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TelePlayRate>> PrepareAsyncGetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TelePlayRate>>(PrepareAsyncGetPlayRateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleOpFileList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpFileList>> AsyncGetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpFileList>>(AsyncGetTeleFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpFileList>> PrepareAsyncGetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpFileList>>(PrepareAsyncGetTeleFileListRaw(context, request, cq));
    }
    virtual ::grpc::Status SaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncSaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncSaveTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncSaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSaveTeleMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status LoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncLoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncLoadTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncLoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncLoadTeleMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncDeleteTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncDeleteTeleMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncEnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncEnableTeleKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncEnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncEnableTeleKeyRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveTeleJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveTeleJRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::Nrmk::IndyFramework::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> AsyncMoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(AsyncMoveTeleLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveTeleLRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Sanding
    // ---------------------------------------------------------------- //
    //
    virtual ::grpc::Status MoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::Nrmk::IndyFramework::MoveFLRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MoveFLRes>> AsyncMoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MoveFLRes>>(AsyncMoveFLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MoveFLRes>> PrepareAsyncMoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MoveFLRes>>(PrepareAsyncMoveFLRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ControlInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ControlInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo* request, ::Nrmk::IndyFramework::SDKLicenseResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo* request, ::Nrmk::IndyFramework::SDKLicenseResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Motion
      // ---------------------------------------------------------------- //
      virtual void MoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Command
      // ---------------------------------------------------------------- //
      virtual void StopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntMode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntMode* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::State* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::State* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Violation Recovery
      // ---------------------------------------------------------------- //
      virtual void Recover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Program
      // ---------------------------------------------------------------- //
      virtual void SearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::ProgramInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::ProgramInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram* request, ::Nrmk::IndyFramework::CollisionThresholds* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram* request, ::Nrmk::IndyFramework::CollisionThresholds* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Custom Variable
      // ---------------------------------------------------------------- //
      virtual void SetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AllVars* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AllVars* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntVars* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntVars* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ModbusVars* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ModbusVars* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BoolVars* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BoolVars* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FloatVars* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FloatVars* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::JPosVars* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::JPosVars* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TPosVars* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TPosVars* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Utility
      // ---------------------------------------------------------------- //
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq* request, ::Nrmk::IndyFramework::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq* request, ::Nrmk::IndyFramework::InverseKinematicsRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq* request, ::Nrmk::IndyFramework::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq* request, ::Nrmk::IndyFramework::GetPalletPointListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // TeleOperation
      // ---------------------------------------------------------------- //
      virtual void GetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpDevice* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpDevice* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleP* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleP* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TelePlayRate* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TelePlayRate* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpFileList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpFileList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void LoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Sanding
      // ---------------------------------------------------------------- //
      //
      virtual void MoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq* request, ::Nrmk::IndyFramework::MoveFLRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq* request, ::Nrmk::IndyFramework::MoveFLRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ControlInfo>* AsyncGetControlInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ControlInfo>* PrepareAsyncGetControlInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDKLicenseResp>* AsyncActivateIndySDKRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDKLicenseResp>* PrepareAsyncActivateIndySDKRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveJTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveJTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveLTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveLTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveCRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveCRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveCTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveCTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncWaitIORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitIORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncWaitTimeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitTimeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncWaitProgressRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitProgressRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncWaitTrajRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitTrajRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncWaitRadiusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitRadiusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveJCondRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveJCondRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncStopMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncStopMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncPauseMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncPauseMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetDirectTeachingRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetDirectTeachingRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntMode>* AsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntMode>* PrepareAsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetFrictionCompensationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetFrictionCompensationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::State>* AsyncGetFrictionCompensationStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::State>* PrepareAsyncGetFrictionCompensationStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetManualRecoveryRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetManualRecoveryRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveRecoverJointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveRecoverJointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ProgramInfo>* AsyncSearchProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ProgramInfo>* PrepareAsyncSearchProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncPlayProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncPlayProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncPauseProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncPauseProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncResumeProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncResumeProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncStopProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncStopProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSendAlarmRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSendAlarmRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSendAnnotationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSendAnnotationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CollisionThresholds>* AsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CollisionThresholds>* PrepareAsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetModbusVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetModbusVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AllVars>* AsyncGetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::AllVars>* PrepareAsyncGetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntVars>* AsyncGetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IntVars>* PrepareAsyncGetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ModbusVars>* AsyncGetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ModbusVars>* PrepareAsyncGetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BoolVars>* AsyncGetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::BoolVars>* PrepareAsyncGetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FloatVars>* AsyncGetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::FloatVars>* PrepareAsyncGetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::JPosVars>* AsyncGetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::JPosVars>* PrepareAsyncGetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TPosVars>* AsyncGetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TPosVars>* PrepareAsyncGetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::InverseKinematicsRes>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::InverseKinematicsRes>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>* AsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>* PrepareAsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetPalletPointListRes>* AsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::GetPalletPointListRes>* PrepareAsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateRelativePoseRes>* AsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateRelativePoseRes>* PrepareAsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* AsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* PrepareAsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncPingFromContyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncPingFromContyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpDevice>* AsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpDevice>* PrepareAsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpState>* AsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpState>* PrepareAsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleP>* AsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleP>* PrepareAsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncStartTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncStartTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TelePlayRate>* AsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TelePlayRate>* PrepareAsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpFileList>* AsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::TeleOpFileList>* PrepareAsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncEnableTeleKeyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncEnableTeleKeyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* AsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MoveFLRes>* AsyncMoveFLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MoveFLRes>* PrepareAsyncMoveFLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::ControlInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ControlInfo>> AsyncGetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ControlInfo>>(AsyncGetControlInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ControlInfo>> PrepareAsyncGetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ControlInfo>>(PrepareAsyncGetControlInfoRaw(context, request, cq));
    }
    ::grpc::Status ActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::Nrmk::IndyFramework::SDKLicenseResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDKLicenseResp>> AsyncActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDKLicenseResp>>(AsyncActivateIndySDKRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDKLicenseResp>> PrepareAsyncActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDKLicenseResp>>(PrepareAsyncActivateIndySDKRaw(context, request, cq));
    }
    ::grpc::Status MoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveJRaw(context, request, cq));
    }
    ::grpc::Status MoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveJTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveJTRaw(context, request, cq));
    }
    ::grpc::Status MoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveLRaw(context, request, cq));
    }
    ::grpc::Status MoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveLTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveLTRaw(context, request, cq));
    }
    ::grpc::Status MoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveCRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveCRaw(context, request, cq));
    }
    ::grpc::Status MoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveCTRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveCTRaw(context, request, cq));
    }
    ::grpc::Status WaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncWaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncWaitIORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitIORaw(context, request, cq));
    }
    ::grpc::Status WaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncWaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncWaitTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitTimeRaw(context, request, cq));
    }
    ::grpc::Status WaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncWaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncWaitProgressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitProgressRaw(context, request, cq));
    }
    ::grpc::Status WaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncWaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncWaitTrajRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitTrajRaw(context, request, cq));
    }
    ::grpc::Status WaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncWaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncWaitRadiusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncWaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncWaitRadiusRaw(context, request, cq));
    }
    ::grpc::Status MoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveJCondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveJCondRaw(context, request, cq));
    }
    ::grpc::Status StopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncStopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncStopMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncStopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStopMotionRaw(context, request, cq));
    }
    ::grpc::Status PauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncPauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncPauseMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncPauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncPauseMotionRaw(context, request, cq));
    }
    ::grpc::Status SetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetDirectTeachingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetDirectTeachingRaw(context, request, cq));
    }
    ::grpc::Status SetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetSimulationModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetSimulationModeRaw(context, request, cq));
    }
    ::grpc::Status SetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetCustomControlModeRaw(context, request, cq));
    }
    ::grpc::Status GetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IntMode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntMode>> AsyncGetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntMode>>(AsyncGetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntMode>> PrepareAsyncGetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntMode>>(PrepareAsyncGetCustomControlModeRaw(context, request, cq));
    }
    ::grpc::Status SetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetFrictionCompensationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetFrictionCompensationRaw(context, request, cq));
    }
    ::grpc::Status GetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::State* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::State>> AsyncGetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::State>>(AsyncGetFrictionCompensationStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::State>> PrepareAsyncGetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::State>>(PrepareAsyncGetFrictionCompensationStateRaw(context, request, cq));
    }
    ::grpc::Status Recover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncRecover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    ::grpc::Status SetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetManualRecoveryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetManualRecoveryRaw(context, request, cq));
    }
    ::grpc::Status MoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveRecoverJointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveRecoverJointRaw(context, request, cq));
    }
    ::grpc::Status SearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::Nrmk::IndyFramework::ProgramInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ProgramInfo>> AsyncSearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ProgramInfo>>(AsyncSearchProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ProgramInfo>> PrepareAsyncSearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ProgramInfo>>(PrepareAsyncSearchProgramRaw(context, request, cq));
    }
    ::grpc::Status PlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncPlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncPlayProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncPlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncPlayProgramRaw(context, request, cq));
    }
    ::grpc::Status PauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncPauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncPauseProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncPauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncPauseProgramRaw(context, request, cq));
    }
    ::grpc::Status ResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncResumeProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncResumeProgramRaw(context, request, cq));
    }
    ::grpc::Status StopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncStopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncStopProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncStopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStopProgramRaw(context, request, cq));
    }
    ::grpc::Status SendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSendAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSendAlarmRaw(context, request, cq));
    }
    ::grpc::Status SendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSendAnnotationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSendAnnotationRaw(context, request, cq));
    }
    ::grpc::Status PlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::Nrmk::IndyFramework::CollisionThresholds* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CollisionThresholds>> AsyncPlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CollisionThresholds>>(AsyncPlayTuningProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CollisionThresholds>> PrepareAsyncPlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CollisionThresholds>>(PrepareAsyncPlayTuningProgramRaw(context, request, cq));
    }
    ::grpc::Status SetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetModbusVariableNameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetModbusVariableNameListRaw(context, request, cq));
    }
    ::grpc::Status SetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetVariableNameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetVariableNameListRaw(context, request, cq));
    }
    ::grpc::Status GetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::AllVars* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AllVars>> AsyncGetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AllVars>>(AsyncGetVariableNameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AllVars>> PrepareAsyncGetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AllVars>>(PrepareAsyncGetVariableNameListRaw(context, request, cq));
    }
    ::grpc::Status SetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetIntVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetIntVariableRaw(context, request, cq));
    }
    ::grpc::Status GetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IntVars* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntVars>> AsyncGetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntVars>>(AsyncGetIntVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntVars>> PrepareAsyncGetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntVars>>(PrepareAsyncGetIntVariableRaw(context, request, cq));
    }
    ::grpc::Status SetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetModbusVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetModbusVariableRaw(context, request, cq));
    }
    ::grpc::Status GetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::ModbusVars* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ModbusVars>> AsyncGetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ModbusVars>>(AsyncGetModbusVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ModbusVars>> PrepareAsyncGetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ModbusVars>>(PrepareAsyncGetModbusVariableRaw(context, request, cq));
    }
    ::grpc::Status SetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetBoolVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetBoolVariableRaw(context, request, cq));
    }
    ::grpc::Status GetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::BoolVars* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BoolVars>> AsyncGetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BoolVars>>(AsyncGetBoolVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BoolVars>> PrepareAsyncGetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BoolVars>>(PrepareAsyncGetBoolVariableRaw(context, request, cq));
    }
    ::grpc::Status SetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetFloatVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetFloatVariableRaw(context, request, cq));
    }
    ::grpc::Status GetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::FloatVars* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FloatVars>> AsyncGetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FloatVars>>(AsyncGetFloatVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FloatVars>> PrepareAsyncGetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FloatVars>>(PrepareAsyncGetFloatVariableRaw(context, request, cq));
    }
    ::grpc::Status SetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetJPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetJPosVariableRaw(context, request, cq));
    }
    ::grpc::Status GetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::JPosVars* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::JPosVars>> AsyncGetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::JPosVars>>(AsyncGetJPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::JPosVars>> PrepareAsyncGetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::JPosVars>>(PrepareAsyncGetJPosVariableRaw(context, request, cq));
    }
    ::grpc::Status SetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetTPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetTPosVariableRaw(context, request, cq));
    }
    ::grpc::Status GetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TPosVars* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TPosVars>> AsyncGetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TPosVars>>(AsyncGetTPosVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TPosVars>> PrepareAsyncGetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TPosVars>>(PrepareAsyncGetTPosVariableRaw(context, request, cq));
    }
    ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::Nrmk::IndyFramework::InverseKinematicsRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::InverseKinematicsRes>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::InverseKinematicsRes>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::InverseKinematicsRes>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::InverseKinematicsRes>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    ::grpc::Status CheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>> AsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>>(AsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>> PrepareAsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>>(PrepareAsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    ::grpc::Status GetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::Nrmk::IndyFramework::GetPalletPointListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetPalletPointListRes>> AsyncGetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetPalletPointListRes>>(AsyncGetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetPalletPointListRes>> PrepareAsyncGetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetPalletPointListRes>>(PrepareAsyncGetPalletPointListRaw(context, request, cq));
    }
    ::grpc::Status CalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateRelativePoseRes>> AsyncCalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateRelativePoseRes>>(AsyncCalculateRelativePoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateRelativePoseRes>> PrepareAsyncCalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateRelativePoseRes>>(PrepareAsyncCalculateRelativePoseRaw(context, request, cq));
    }
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>> AsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>>(AsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>> PrepareAsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>>(PrepareAsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    ::grpc::Status PingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncPingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncPingFromContyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncPingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncPingFromContyRaw(context, request, cq));
    }
    ::grpc::Status GetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleOpDevice* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpDevice>> AsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpDevice>>(AsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpDevice>> PrepareAsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpDevice>>(PrepareAsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    ::grpc::Status GetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleOpState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpState>> AsyncGetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpState>>(AsyncGetTeleOpStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpState>> PrepareAsyncGetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpState>>(PrepareAsyncGetTeleOpStateRaw(context, request, cq));
    }
    ::grpc::Status ConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    ::grpc::Status ReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleP* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleP>> AsyncReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleP>>(AsyncReadTeleOpInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleP>> PrepareAsyncReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleP>>(PrepareAsyncReadTeleOpInputRaw(context, request, cq));
    }
    ::grpc::Status StartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncStartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncStartTeleOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncStartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStartTeleOpRaw(context, request, cq));
    }
    ::grpc::Status StopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncStopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncStopTeleOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncStopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncStopTeleOpRaw(context, request, cq));
    }
    ::grpc::Status SetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSetPlayRateRaw(context, request, cq));
    }
    ::grpc::Status GetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TelePlayRate* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TelePlayRate>> AsyncGetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TelePlayRate>>(AsyncGetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TelePlayRate>> PrepareAsyncGetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TelePlayRate>>(PrepareAsyncGetPlayRateRaw(context, request, cq));
    }
    ::grpc::Status GetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::TeleOpFileList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpFileList>> AsyncGetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpFileList>>(AsyncGetTeleFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpFileList>> PrepareAsyncGetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpFileList>>(PrepareAsyncGetTeleFileListRaw(context, request, cq));
    }
    ::grpc::Status SaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncSaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncSaveTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncSaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncSaveTeleMotionRaw(context, request, cq));
    }
    ::grpc::Status LoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncLoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncLoadTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncLoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncLoadTeleMotionRaw(context, request, cq));
    }
    ::grpc::Status DeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncDeleteTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncDeleteTeleMotionRaw(context, request, cq));
    }
    ::grpc::Status EnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncEnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncEnableTeleKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncEnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncEnableTeleKeyRaw(context, request, cq));
    }
    ::grpc::Status MoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveTeleJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveTeleJRaw(context, request, cq));
    }
    ::grpc::Status MoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::Nrmk::IndyFramework::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> AsyncMoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(AsyncMoveTeleLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>> PrepareAsyncMoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>>(PrepareAsyncMoveTeleLRaw(context, request, cq));
    }
    ::grpc::Status MoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::Nrmk::IndyFramework::MoveFLRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MoveFLRes>> AsyncMoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MoveFLRes>>(AsyncMoveFLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MoveFLRes>> PrepareAsyncMoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MoveFLRes>>(PrepareAsyncMoveFLRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ControlInfo* response, std::function<void(::grpc::Status)>) override;
      void GetControlInfo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ControlInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo* request, ::Nrmk::IndyFramework::SDKLicenseResp* response, std::function<void(::grpc::Status)>) override;
      void ActivateIndySDK(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo* request, ::Nrmk::IndyFramework::SDKLicenseResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveJT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveLT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveC(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveCT(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void WaitIO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void WaitTime(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void WaitProgress(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void WaitTraj(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void WaitRadius(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveJCond(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void StopMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void PauseMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetDirectTeaching(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetSimulationMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntMode* response, std::function<void(::grpc::Status)>) override;
      void GetCustomControlMode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntMode* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetFrictionCompensation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::State* response, std::function<void(::grpc::Status)>) override;
      void GetFrictionCompensationState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::State* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Recover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void Recover(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetManualRecovery(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveRecoverJoint(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::ProgramInfo* response, std::function<void(::grpc::Status)>) override;
      void SearchProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::ProgramInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void PlayProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void PauseProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void ResumeProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void StopProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SendAlarm(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SendAnnotation(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram* request, ::Nrmk::IndyFramework::CollisionThresholds* response, std::function<void(::grpc::Status)>) override;
      void PlayTuningProgram(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram* request, ::Nrmk::IndyFramework::CollisionThresholds* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetModbusVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AllVars* response, std::function<void(::grpc::Status)>) override;
      void GetVariableNameList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AllVars* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntVars* response, std::function<void(::grpc::Status)>) override;
      void GetIntVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntVars* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ModbusVars* response, std::function<void(::grpc::Status)>) override;
      void GetModbusVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ModbusVars* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BoolVars* response, std::function<void(::grpc::Status)>) override;
      void GetBoolVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BoolVars* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FloatVars* response, std::function<void(::grpc::Status)>) override;
      void GetFloatVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FloatVars* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::JPosVars* response, std::function<void(::grpc::Status)>) override;
      void GetJPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::JPosVars* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TPosVars* response, std::function<void(::grpc::Status)>) override;
      void GetTPosVariable(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TPosVars* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq* request, ::Nrmk::IndyFramework::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq* request, ::Nrmk::IndyFramework::InverseKinematicsRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq* request, ::Nrmk::IndyFramework::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq* request, ::Nrmk::IndyFramework::GetPalletPointListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void PingFromConty(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpDevice* response, std::function<void(::grpc::Status)>) override;
      void GetTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpDevice* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpState* response, std::function<void(::grpc::Status)>) override;
      void GetTeleOpState(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleP* response, std::function<void(::grpc::Status)>) override;
      void ReadTeleOpInput(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleP* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void StartTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void StopTeleOp(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TelePlayRate* response, std::function<void(::grpc::Status)>) override;
      void GetPlayRate(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TelePlayRate* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpFileList* response, std::function<void(::grpc::Status)>) override;
      void GetTeleFileList(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpFileList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void SaveTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void LoadTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void DeleteTeleMotion(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void EnableTeleKey(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveTeleJ(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq* request, ::Nrmk::IndyFramework::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveTeleL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq* request, ::Nrmk::IndyFramework::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq* request, ::Nrmk::IndyFramework::MoveFLRes* response, std::function<void(::grpc::Status)>) override;
      void MoveFL(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq* request, ::Nrmk::IndyFramework::MoveFLRes* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ControlInfo>* AsyncGetControlInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ControlInfo>* PrepareAsyncGetControlInfoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDKLicenseResp>* AsyncActivateIndySDKRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDKLicenseResp>* PrepareAsyncActivateIndySDKRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveJTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveJTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveLTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveLTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveLTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveCRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveCRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveCTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveCTRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveCTReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncWaitIORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitIORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitIOReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncWaitTimeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitTimeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTimeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncWaitProgressRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitProgressRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitProgressReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncWaitTrajRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitTrajRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitTrajReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncWaitRadiusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncWaitRadiusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveJCondRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveJCondRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveJCondReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncStopMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncStopMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::StopCat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncPauseMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncPauseMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::PauseCat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetDirectTeachingRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetDirectTeachingRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntMode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntMode>* AsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntMode>* PrepareAsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetFrictionCompensationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetFrictionCompensationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::State>* AsyncGetFrictionCompensationStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::State>* PrepareAsyncGetFrictionCompensationStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetManualRecoveryRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetManualRecoveryRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveRecoverJointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveRecoverJointRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TargetJ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ProgramInfo>* AsyncSearchProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ProgramInfo>* PrepareAsyncSearchProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncPlayProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncPlayProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Program& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncPauseProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncPauseProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncResumeProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncResumeProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncStopProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncStopProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSendAlarmRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSendAlarmRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSendAnnotationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSendAnnotationRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Message& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CollisionThresholds>* AsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CollisionThresholds>* PrepareAsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TuningProgram& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetModbusVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetModbusVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVariableList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::AllVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AllVars>* AsyncGetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::AllVars>* PrepareAsyncGetVariableNameListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IntVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntVars>* AsyncGetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IntVars>* PrepareAsyncGetIntVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ModbusVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ModbusVars>* AsyncGetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ModbusVars>* PrepareAsyncGetModbusVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::BoolVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BoolVars>* AsyncGetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::BoolVars>* PrepareAsyncGetBoolVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::FloatVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FloatVars>* AsyncGetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::FloatVars>* PrepareAsyncGetFloatVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::JPosVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::JPosVars>* AsyncGetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::JPosVars>* PrepareAsyncGetJPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TPosVars& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TPosVars>* AsyncGetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TPosVars>* PrepareAsyncGetTPosVariableRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::InverseKinematicsRes>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::InverseKinematicsRes>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>* AsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>* PrepareAsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetPalletPointListRes>* AsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::GetPalletPointListRes>* PrepareAsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateRelativePoseRes>* AsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateRelativePoseRes>* PrepareAsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* AsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* PrepareAsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncPingFromContyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncPingFromContyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpDevice>* AsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpDevice>* PrepareAsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpState>* AsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpState>* PrepareAsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleP>* AsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleP>* PrepareAsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncStartTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncStartTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleOpState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TelePlayRate& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TelePlayRate>* AsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TelePlayRate>* PrepareAsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpFileList>* AsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::TeleOpFileList>* PrepareAsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncEnableTeleKeyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncEnableTeleKeyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* AsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Response>* PrepareAsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MoveFLRes>* AsyncMoveFLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MoveFLRes>* PrepareAsyncMoveFLRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::MoveFLReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetControlInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ActivateIndySDK_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveJ_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveJT_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveL_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveLT_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveC_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveCT_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitIO_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitTime_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitProgress_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitTraj_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitRadius_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveJCond_;
    const ::grpc::internal::RpcMethod rpcmethod_StopMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDirectTeaching_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSimulationMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCustomControlMode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCustomControlMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFrictionCompensation_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFrictionCompensationState_;
    const ::grpc::internal::RpcMethod rpcmethod_Recover_;
    const ::grpc::internal::RpcMethod rpcmethod_SetManualRecovery_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveRecoverJoint_;
    const ::grpc::internal::RpcMethod rpcmethod_SearchProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_PlayProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_ResumeProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_StopProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_SendAlarm_;
    const ::grpc::internal::RpcMethod rpcmethod_SendAnnotation_;
    const ::grpc::internal::RpcMethod rpcmethod_PlayTuningProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_SetModbusVariableNameList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVariableNameList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVariableNameList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetIntVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIntVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_SetModbusVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModbusVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_SetBoolVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBoolVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFloatVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFloatVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_SetJPosVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJPosVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTPosVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTPosVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_InverseKinematics_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckAproachRetractValid_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPalletPointList_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateRelativePose_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateCurrentPoseRel_;
    const ::grpc::internal::RpcMethod rpcmethod_PingFromConty_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTeleOpDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTeleOpState_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectTeleOpDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_DisConnectTeleOpDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadTeleOpInput_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTeleOp_;
    const ::grpc::internal::RpcMethod rpcmethod_StopTeleOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPlayRate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayRate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTeleFileList_;
    const ::grpc::internal::RpcMethod rpcmethod_SaveTeleMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadTeleMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteTeleMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableTeleKey_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveTeleJ_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveTeleL_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveFL_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetControlInfo(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ControlInfo* response);
    virtual ::grpc::Status ActivateIndySDK(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo* request, ::Nrmk::IndyFramework::SDKLicenseResp* response);
    // ---------------------------------------------------------------- //
    // Motion
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status MoveJ(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveJReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveJT(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveJTReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveL(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveLReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveLT(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveLTReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveC(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveCReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveCT(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveCTReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status WaitIO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::WaitIOReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status WaitTime(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::WaitTimeReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status WaitProgress(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::WaitProgressReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status WaitTraj(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::WaitTrajReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status WaitRadius(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveJCond(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveJCondReq* request, ::Nrmk::IndyFramework::Response* response);
    // ---------------------------------------------------------------- //
    // Command
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status StopMotion(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::StopCat* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status PauseMotion(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::PauseCat* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetDirectTeaching(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetSimulationMode(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetCustomControlMode(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::IntMode* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status GetCustomControlMode(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntMode* response);
    virtual ::grpc::Status SetFrictionCompensation(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status GetFrictionCompensationState(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::State* response);
    // ---------------------------------------------------------------- //
    // Violation Recovery
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status Recover(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetManualRecovery(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveRecoverJoint(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TargetJ* request, ::Nrmk::IndyFramework::Response* response);
    // ---------------------------------------------------------------- //
    // Program
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SearchProgram(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::ProgramInfo* response);
    virtual ::grpc::Status PlayProgram(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status PauseProgram(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status ResumeProgram(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status StopProgram(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SendAlarm(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SendAnnotation(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status PlayTuningProgram(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TuningProgram* request, ::Nrmk::IndyFramework::CollisionThresholds* response);
    // ---------------------------------------------------------------- //
    // Custom Variable
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetModbusVariableNameList(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ModbusVariableList* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SetVariableNameList(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::AllVars* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetVariableNameList(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AllVars* response);
    virtual ::grpc::Status SetIntVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::IntVars* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetIntVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntVars* response);
    virtual ::grpc::Status SetModbusVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ModbusVars* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetModbusVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ModbusVars* response);
    virtual ::grpc::Status SetBoolVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::BoolVars* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetBoolVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BoolVars* response);
    virtual ::grpc::Status SetFloatVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::FloatVars* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetFloatVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FloatVars* response);
    virtual ::grpc::Status SetJPosVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::JPosVars* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetJPosVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::JPosVars* response);
    virtual ::grpc::Status SetTPosVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TPosVars* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetTPosVariable(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TPosVars* response);
    // ---------------------------------------------------------------- //
    // Utility
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status InverseKinematics(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq* request, ::Nrmk::IndyFramework::InverseKinematicsRes* response);
    virtual ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response);
    virtual ::grpc::Status GetPalletPointList(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq* request, ::Nrmk::IndyFramework::GetPalletPointListRes* response);
    virtual ::grpc::Status CalculateRelativePose(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response);
    virtual ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response);
    virtual ::grpc::Status PingFromConty(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response);
    // ---------------------------------------------------------------- //
    // TeleOperation
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpDevice* response);
    virtual ::grpc::Status GetTeleOpState(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpState* response);
    virtual ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TeleOpDevice* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleP* response);
    virtual ::grpc::Status StartTeleOp(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TeleOpState* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status StopTeleOp(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status SetPlayRate(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TelePlayRate* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status GetPlayRate(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TelePlayRate* response);
    virtual ::grpc::Status GetTeleFileList(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpFileList* response);
    virtual ::grpc::Status SaveTeleMotion(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status LoadTeleMotion(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status EnableTeleKey(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveTeleJ(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq* request, ::Nrmk::IndyFramework::Response* response);
    virtual ::grpc::Status MoveTeleL(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq* request, ::Nrmk::IndyFramework::Response* response);
    // ---------------------------------------------------------------- //
    // Sanding
    // ---------------------------------------------------------------- //
    //
    virtual ::grpc::Status MoveFL(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::MoveFLReq* request, ::Nrmk::IndyFramework::MoveFLRes* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetControlInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetControlInfo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetControlInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetControlInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ControlInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetControlInfo(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ControlInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ActivateIndySDK : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ActivateIndySDK() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ActivateIndySDK() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateIndySDK(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SDKLicenseInfo* /*request*/, ::Nrmk::IndyFramework::SDKLicenseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActivateIndySDK(::grpc::ServerContext* context, ::Nrmk::IndyFramework::SDKLicenseInfo* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SDKLicenseResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveJ() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_MoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveJ(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveJReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveJT() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_MoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveJT(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveJTReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveL() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveL(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveLReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveLT() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_MoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveLT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveLT(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveLTReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveC() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_MoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveC(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveC(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveCReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveCT() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_MoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveCT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveCT(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveCTReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitIO() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_WaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitIO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitIOReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitIO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::WaitIOReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitTime() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_WaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTime(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTimeReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitTime(::grpc::ServerContext* context, ::Nrmk::IndyFramework::WaitTimeReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitProgress() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_WaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitProgress(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitProgressReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitProgress(::grpc::ServerContext* context, ::Nrmk::IndyFramework::WaitProgressReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitTraj() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_WaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTraj(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTrajReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitTraj(::grpc::ServerContext* context, ::Nrmk::IndyFramework::WaitTrajReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitRadius() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_WaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitRadius(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitRadiusReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitRadius(::grpc::ServerContext* context, ::Nrmk::IndyFramework::WaitRadiusReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveJCond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveJCond() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_MoveJCond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJCond(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJCondReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveJCond(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveJCondReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopMotion() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::StopCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopMotion(::grpc::ServerContext* context, ::Nrmk::IndyFramework::StopCat* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseMotion() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_PauseMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PauseCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseMotion(::grpc::ServerContext* context, ::Nrmk::IndyFramework::PauseCat* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDirectTeaching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDirectTeaching() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_SetDirectTeaching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeaching(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDirectTeaching(::grpc::ServerContext* context, ::Nrmk::IndyFramework::State* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSimulationMode(::grpc::ServerContext* context, ::Nrmk::IndyFramework::State* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntMode* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCustomControlMode(::grpc::ServerContext* context, ::Nrmk::IndyFramework::IntMode* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCustomControlMode(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::IntMode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFrictionCompensation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetFrictionCompensation() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_SetFrictionCompensation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFrictionCompensation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFrictionCompensation(::grpc::ServerContext* context, ::Nrmk::IndyFramework::State* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFrictionCompensationState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFrictionCompensationState() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetFrictionCompensationState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFrictionCompensationState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFrictionCompensationState(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::State>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Recover() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetManualRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetManualRecovery() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_SetManualRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecovery(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetManualRecovery(::grpc::ServerContext* context, ::Nrmk::IndyFramework::State* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveRecoverJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveRecoverJoint() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_MoveRecoverJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveRecoverJoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TargetJ* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveRecoverJoint(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TargetJ* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SearchProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SearchProgram() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_SearchProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::ProgramInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSearchProgram(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Program* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ProgramInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayProgram() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayProgram(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Program* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseProgram() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseProgram(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeProgram(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopProgram() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopProgram(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendAlarm() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_SendAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAlarm(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendAlarm(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Message* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendAnnotation() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_SendAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAnnotation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendAnnotation(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Message* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TuningProgram* /*request*/, ::Nrmk::IndyFramework::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayTuningProgram(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TuningProgram* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::CollisionThresholds>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetModbusVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetModbusVariableNameList() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_SetModbusVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVariableList* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetModbusVariableNameList(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ModbusVariableList* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVariableNameList() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_SetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AllVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariableNameList(::grpc::ServerContext* context, ::Nrmk::IndyFramework::AllVars* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVariableNameList() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_GetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AllVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVariableNameList(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::AllVars>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetIntVariable() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_SetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetIntVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::IntVars* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIntVariable() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIntVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::IntVars>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetModbusVariable() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_SetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetModbusVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ModbusVars* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModbusVariable() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_GetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ModbusVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModbusVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ModbusVars>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetBoolVariable() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_SetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::BoolVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetBoolVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::BoolVars* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBoolVariable() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_GetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BoolVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBoolVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::BoolVars>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetFloatVariable() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_SetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::FloatVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFloatVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::FloatVars* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFloatVariable() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FloatVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFloatVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::FloatVars>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetJPosVariable() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_SetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::JPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJPosVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::JPosVars* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJPosVariable() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_GetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::JPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJPosVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::JPosVars>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTPosVariable() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_SetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTPosVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TPosVars* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTPosVariable() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_GetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTPosVariable(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::TPosVars>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::InverseKinematicsReq* /*request*/, ::Nrmk::IndyFramework::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::Nrmk::IndyFramework::InverseKinematicsReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::InverseKinematicsRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* /*request*/, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAproachRetractValid(::grpc::ServerContext* context, ::Nrmk::IndyFramework::CheckAproachRetractValidReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::CheckAproachRetractValidRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GetPalletPointListReq* /*request*/, ::Nrmk::IndyFramework::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletPointList(::grpc::ServerContext* context, ::Nrmk::IndyFramework::GetPalletPointListReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::GetPalletPointListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* /*request*/, ::Nrmk::IndyFramework::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateRelativePose(::grpc::ServerContext* context, ::Nrmk::IndyFramework::CalculateRelativePoseReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::CalculateRelativePoseRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* /*request*/, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateCurrentPoseRel(::grpc::ServerContext* context, ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PingFromConty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PingFromConty() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_PingFromConty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingFromConty(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPingFromConty(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpDevice(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::TeleOpDevice>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpState(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::TeleOpState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpDevice* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectTeleOpDevice(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TeleOpDevice* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisConnectTeleOpDevice(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadTeleOpInput(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::TeleP>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTeleOp() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_StartTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleOp(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TeleOpState* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTeleOp(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TelePlayRate* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayRate(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TelePlayRate* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayRate(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::TelePlayRate>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleFileList(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::TeleOpFileList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveTeleMotion(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TeleFileReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadTeleMotion(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TeleFileReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTeleMotion(::grpc::ServerContext* context, ::Nrmk::IndyFramework::TeleFileReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableTeleKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableTeleKey() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_EnableTeleKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTeleKey(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableTeleKey(::grpc::ServerContext* context, ::Nrmk::IndyFramework::State* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleJ(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveTeleJReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleL(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveTeleLReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveFL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveFL() {
      ::grpc::Service::MarkMethodAsync(70);
    }
    ~WithAsyncMethod_MoveFL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveFLReq* /*request*/, ::Nrmk::IndyFramework::MoveFLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveFL(::grpc::ServerContext* context, ::Nrmk::IndyFramework::MoveFLReq* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::MoveFLRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetControlInfo<WithAsyncMethod_ActivateIndySDK<WithAsyncMethod_MoveJ<WithAsyncMethod_MoveJT<WithAsyncMethod_MoveL<WithAsyncMethod_MoveLT<WithAsyncMethod_MoveC<WithAsyncMethod_MoveCT<WithAsyncMethod_WaitIO<WithAsyncMethod_WaitTime<WithAsyncMethod_WaitProgress<WithAsyncMethod_WaitTraj<WithAsyncMethod_WaitRadius<WithAsyncMethod_MoveJCond<WithAsyncMethod_StopMotion<WithAsyncMethod_PauseMotion<WithAsyncMethod_SetDirectTeaching<WithAsyncMethod_SetSimulationMode<WithAsyncMethod_SetCustomControlMode<WithAsyncMethod_GetCustomControlMode<WithAsyncMethod_SetFrictionCompensation<WithAsyncMethod_GetFrictionCompensationState<WithAsyncMethod_Recover<WithAsyncMethod_SetManualRecovery<WithAsyncMethod_MoveRecoverJoint<WithAsyncMethod_SearchProgram<WithAsyncMethod_PlayProgram<WithAsyncMethod_PauseProgram<WithAsyncMethod_ResumeProgram<WithAsyncMethod_StopProgram<WithAsyncMethod_SendAlarm<WithAsyncMethod_SendAnnotation<WithAsyncMethod_PlayTuningProgram<WithAsyncMethod_SetModbusVariableNameList<WithAsyncMethod_SetVariableNameList<WithAsyncMethod_GetVariableNameList<WithAsyncMethod_SetIntVariable<WithAsyncMethod_GetIntVariable<WithAsyncMethod_SetModbusVariable<WithAsyncMethod_GetModbusVariable<WithAsyncMethod_SetBoolVariable<WithAsyncMethod_GetBoolVariable<WithAsyncMethod_SetFloatVariable<WithAsyncMethod_GetFloatVariable<WithAsyncMethod_SetJPosVariable<WithAsyncMethod_GetJPosVariable<WithAsyncMethod_SetTPosVariable<WithAsyncMethod_GetTPosVariable<WithAsyncMethod_InverseKinematics<WithAsyncMethod_CheckAproachRetractValid<WithAsyncMethod_GetPalletPointList<WithAsyncMethod_CalculateRelativePose<WithAsyncMethod_CalculateCurrentPoseRel<WithAsyncMethod_PingFromConty<WithAsyncMethod_GetTeleOpDevice<WithAsyncMethod_GetTeleOpState<WithAsyncMethod_ConnectTeleOpDevice<WithAsyncMethod_DisConnectTeleOpDevice<WithAsyncMethod_ReadTeleOpInput<WithAsyncMethod_StartTeleOp<WithAsyncMethod_StopTeleOp<WithAsyncMethod_SetPlayRate<WithAsyncMethod_GetPlayRate<WithAsyncMethod_GetTeleFileList<WithAsyncMethod_SaveTeleMotion<WithAsyncMethod_LoadTeleMotion<WithAsyncMethod_DeleteTeleMotion<WithAsyncMethod_EnableTeleKey<WithAsyncMethod_MoveTeleJ<WithAsyncMethod_MoveTeleL<WithAsyncMethod_MoveFL<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetControlInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetControlInfo() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ControlInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ControlInfo* response) { return this->GetControlInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetControlInfo(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ControlInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ControlInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetControlInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetControlInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ControlInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetControlInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ControlInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ActivateIndySDK : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ActivateIndySDK() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SDKLicenseInfo, ::Nrmk::IndyFramework::SDKLicenseResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::SDKLicenseInfo* request, ::Nrmk::IndyFramework::SDKLicenseResp* response) { return this->ActivateIndySDK(context, request, response); }));}
    void SetMessageAllocatorFor_ActivateIndySDK(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::SDKLicenseInfo, ::Nrmk::IndyFramework::SDKLicenseResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::SDKLicenseInfo, ::Nrmk::IndyFramework::SDKLicenseResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ActivateIndySDK() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateIndySDK(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SDKLicenseInfo* /*request*/, ::Nrmk::IndyFramework::SDKLicenseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ActivateIndySDK(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::SDKLicenseInfo* /*request*/, ::Nrmk::IndyFramework::SDKLicenseResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveJ() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveJReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveJReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveJ(context, request, response); }));}
    void SetMessageAllocatorFor_MoveJ(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveJReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveJReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveJ(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveJT() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveJTReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveJTReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveJT(context, request, response); }));}
    void SetMessageAllocatorFor_MoveJT(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveJTReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveJTReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveJT(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveL() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveLReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveLReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveL(context, request, response); }));}
    void SetMessageAllocatorFor_MoveL(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveLReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveLReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveL(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveLT() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveLTReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveLTReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveLT(context, request, response); }));}
    void SetMessageAllocatorFor_MoveLT(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveLTReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveLTReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveLT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveLT(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveC() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveCReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveCReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveC(context, request, response); }));}
    void SetMessageAllocatorFor_MoveC(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveCReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveCReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveC(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveC(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveCT() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveCTReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveCTReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveCT(context, request, response); }));}
    void SetMessageAllocatorFor_MoveCT(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveCTReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveCTReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveCT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveCT(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WaitIO() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitIOReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::WaitIOReq* request, ::Nrmk::IndyFramework::Response* response) { return this->WaitIO(context, request, response); }));}
    void SetMessageAllocatorFor_WaitIO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::WaitIOReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitIOReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitIO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitIOReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitIO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitIOReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WaitTime() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitTimeReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::WaitTimeReq* request, ::Nrmk::IndyFramework::Response* response) { return this->WaitTime(context, request, response); }));}
    void SetMessageAllocatorFor_WaitTime(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::WaitTimeReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitTimeReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTime(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTimeReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitTime(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTimeReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WaitProgress() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitProgressReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::WaitProgressReq* request, ::Nrmk::IndyFramework::Response* response) { return this->WaitProgress(context, request, response); }));}
    void SetMessageAllocatorFor_WaitProgress(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::WaitProgressReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitProgressReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitProgress(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitProgressReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitProgress(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitProgressReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WaitTraj() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitTrajReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::WaitTrajReq* request, ::Nrmk::IndyFramework::Response* response) { return this->WaitTraj(context, request, response); }));}
    void SetMessageAllocatorFor_WaitTraj(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::WaitTrajReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitTrajReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTraj(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTrajReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitTraj(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTrajReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WaitRadius() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitRadiusReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::WaitRadiusReq* request, ::Nrmk::IndyFramework::Response* response) { return this->WaitRadius(context, request, response); }));}
    void SetMessageAllocatorFor_WaitRadius(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::WaitRadiusReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::WaitRadiusReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitRadius(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitRadiusReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitRadius(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitRadiusReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveJCond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveJCond() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveJCondReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveJCondReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveJCond(context, request, response); }));}
    void SetMessageAllocatorFor_MoveJCond(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveJCondReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveJCondReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveJCond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJCond(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJCondReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveJCond(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJCondReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopMotion() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::StopCat, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::StopCat* request, ::Nrmk::IndyFramework::Response* response) { return this->StopMotion(context, request, response); }));}
    void SetMessageAllocatorFor_StopMotion(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::StopCat, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::StopCat, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::StopCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::StopCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseMotion() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::PauseCat, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::PauseCat* request, ::Nrmk::IndyFramework::Response* response) { return this->PauseMotion(context, request, response); }));}
    void SetMessageAllocatorFor_PauseMotion(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::PauseCat, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::PauseCat, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PauseCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::PauseCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDirectTeaching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDirectTeaching() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response) { return this->SetDirectTeaching(context, request, response); }));}
    void SetMessageAllocatorFor_SetDirectTeaching(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDirectTeaching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeaching(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDirectTeaching(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response) { return this->SetSimulationMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetSimulationMode(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSimulationMode(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::IntMode, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::IntMode* request, ::Nrmk::IndyFramework::Response* response) { return this->SetCustomControlMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetCustomControlMode(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::IntMode, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::IntMode, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntMode* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::IntMode* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntMode>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntMode* response) { return this->GetCustomControlMode(context, request, response); }));}
    void SetMessageAllocatorFor_GetCustomControlMode(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntMode>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntMode>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntMode* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetFrictionCompensation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetFrictionCompensation() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response) { return this->SetFrictionCompensation(context, request, response); }));}
    void SetMessageAllocatorFor_SetFrictionCompensation(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetFrictionCompensation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFrictionCompensation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFrictionCompensation(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFrictionCompensationState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFrictionCompensationState() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::State>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::State* response) { return this->GetFrictionCompensationState(context, request, response); }));}
    void SetMessageAllocatorFor_GetFrictionCompensationState(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::State>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::State>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFrictionCompensationState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFrictionCompensationState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFrictionCompensationState(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::State* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Recover() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response) { return this->Recover(context, request, response); }));}
    void SetMessageAllocatorFor_Recover(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Recover(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetManualRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetManualRecovery() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response) { return this->SetManualRecovery(context, request, response); }));}
    void SetMessageAllocatorFor_SetManualRecovery(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetManualRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecovery(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetManualRecovery(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveRecoverJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveRecoverJoint() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TargetJ, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TargetJ* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveRecoverJoint(context, request, response); }));}
    void SetMessageAllocatorFor_MoveRecoverJoint(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TargetJ, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TargetJ, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveRecoverJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveRecoverJoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TargetJ* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveRecoverJoint(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TargetJ* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SearchProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SearchProgram() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::ProgramInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::ProgramInfo* response) { return this->SearchProgram(context, request, response); }));}
    void SetMessageAllocatorFor_SearchProgram(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::ProgramInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::ProgramInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SearchProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::ProgramInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SearchProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::ProgramInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayProgram() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Program* request, ::Nrmk::IndyFramework::Response* response) { return this->PlayProgram(context, request, response); }));}
    void SetMessageAllocatorFor_PlayProgram(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseProgram() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response) { return this->PauseProgram(context, request, response); }));}
    void SetMessageAllocatorFor_PauseProgram(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response) { return this->ResumeProgram(context, request, response); }));}
    void SetMessageAllocatorFor_ResumeProgram(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopProgram() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response) { return this->StopProgram(context, request, response); }));}
    void SetMessageAllocatorFor_StopProgram(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendAlarm() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response) { return this->SendAlarm(context, request, response); }));}
    void SetMessageAllocatorFor_SendAlarm(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAlarm(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendAnnotation() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Message* request, ::Nrmk::IndyFramework::Empty* response) { return this->SendAnnotation(context, request, response); }));}
    void SetMessageAllocatorFor_SendAnnotation(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAnnotation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendAnnotation(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TuningProgram, ::Nrmk::IndyFramework::CollisionThresholds>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TuningProgram* request, ::Nrmk::IndyFramework::CollisionThresholds* response) { return this->PlayTuningProgram(context, request, response); }));}
    void SetMessageAllocatorFor_PlayTuningProgram(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TuningProgram, ::Nrmk::IndyFramework::CollisionThresholds>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TuningProgram, ::Nrmk::IndyFramework::CollisionThresholds>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TuningProgram* /*request*/, ::Nrmk::IndyFramework::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayTuningProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TuningProgram* /*request*/, ::Nrmk::IndyFramework::CollisionThresholds* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetModbusVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetModbusVariableNameList() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ModbusVariableList, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ModbusVariableList* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetModbusVariableNameList(context, request, response); }));}
    void SetMessageAllocatorFor_SetModbusVariableNameList(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ModbusVariableList, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ModbusVariableList, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetModbusVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVariableList* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetModbusVariableNameList(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVariableList* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetVariableNameList() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AllVars, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::AllVars* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetVariableNameList(context, request, response); }));}
    void SetMessageAllocatorFor_SetVariableNameList(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::AllVars, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::AllVars, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AllVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVariableNameList(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::AllVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVariableNameList() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AllVars>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::AllVars* response) { return this->GetVariableNameList(context, request, response); }));}
    void SetMessageAllocatorFor_GetVariableNameList(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AllVars>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AllVars>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AllVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVariableNameList(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AllVars* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetIntVariable() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::IntVars, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::IntVars* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetIntVariable(context, request, response); }));}
    void SetMessageAllocatorFor_SetIntVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::IntVars, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::IntVars, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetIntVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::IntVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetIntVariable() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntVars>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IntVars* response) { return this->GetIntVariable(context, request, response); }));}
    void SetMessageAllocatorFor_GetIntVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntVars>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntVars>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIntVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntVars* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetModbusVariable() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ModbusVars, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ModbusVars* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetModbusVariable(context, request, response); }));}
    void SetMessageAllocatorFor_SetModbusVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ModbusVars, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ModbusVars, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetModbusVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetModbusVariable() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ModbusVars>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::ModbusVars* response) { return this->GetModbusVariable(context, request, response); }));}
    void SetMessageAllocatorFor_GetModbusVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ModbusVars>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ModbusVars>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ModbusVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModbusVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ModbusVars* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetBoolVariable() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::BoolVars, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::BoolVars* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetBoolVariable(context, request, response); }));}
    void SetMessageAllocatorFor_SetBoolVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::BoolVars, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::BoolVars, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::BoolVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetBoolVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::BoolVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBoolVariable() {
      ::grpc::Service::MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BoolVars>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::BoolVars* response) { return this->GetBoolVariable(context, request, response); }));}
    void SetMessageAllocatorFor_GetBoolVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BoolVars>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BoolVars>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BoolVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBoolVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BoolVars* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetFloatVariable() {
      ::grpc::Service::MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::FloatVars, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::FloatVars* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetFloatVariable(context, request, response); }));}
    void SetMessageAllocatorFor_SetFloatVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::FloatVars, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::FloatVars, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::FloatVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFloatVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::FloatVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFloatVariable() {
      ::grpc::Service::MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FloatVars>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::FloatVars* response) { return this->GetFloatVariable(context, request, response); }));}
    void SetMessageAllocatorFor_GetFloatVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FloatVars>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FloatVars>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FloatVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFloatVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FloatVars* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetJPosVariable() {
      ::grpc::Service::MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::JPosVars, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::JPosVars* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetJPosVariable(context, request, response); }));}
    void SetMessageAllocatorFor_SetJPosVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::JPosVars, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::JPosVars, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::JPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::JPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJPosVariable() {
      ::grpc::Service::MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::JPosVars>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::JPosVars* response) { return this->GetJPosVariable(context, request, response); }));}
    void SetMessageAllocatorFor_GetJPosVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::JPosVars>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::JPosVars>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::JPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::JPosVars* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetTPosVariable() {
      ::grpc::Service::MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TPosVars, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TPosVars* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetTPosVariable(context, request, response); }));}
    void SetMessageAllocatorFor_SetTPosVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TPosVars, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TPosVars, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTPosVariable() {
      ::grpc::Service::MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TPosVars>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TPosVars* response) { return this->GetTPosVariable(context, request, response); }));}
    void SetMessageAllocatorFor_GetTPosVariable(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TPosVars>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TPosVars>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TPosVars* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::InverseKinematicsReq, ::Nrmk::IndyFramework::InverseKinematicsRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::InverseKinematicsReq* request, ::Nrmk::IndyFramework::InverseKinematicsRes* response) { return this->InverseKinematics(context, request, response); }));}
    void SetMessageAllocatorFor_InverseKinematics(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::InverseKinematicsReq, ::Nrmk::IndyFramework::InverseKinematicsRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::InverseKinematicsReq, ::Nrmk::IndyFramework::InverseKinematicsRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::InverseKinematicsReq* /*request*/, ::Nrmk::IndyFramework::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InverseKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::InverseKinematicsReq* /*request*/, ::Nrmk::IndyFramework::InverseKinematicsRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::CheckAproachRetractValidReq, ::Nrmk::IndyFramework::CheckAproachRetractValidRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* request, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* response) { return this->CheckAproachRetractValid(context, request, response); }));}
    void SetMessageAllocatorFor_CheckAproachRetractValid(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::CheckAproachRetractValidReq, ::Nrmk::IndyFramework::CheckAproachRetractValidRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::CheckAproachRetractValidReq, ::Nrmk::IndyFramework::CheckAproachRetractValidRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* /*request*/, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAproachRetractValid(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* /*request*/, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::GetPalletPointListReq, ::Nrmk::IndyFramework::GetPalletPointListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::GetPalletPointListReq* request, ::Nrmk::IndyFramework::GetPalletPointListRes* response) { return this->GetPalletPointList(context, request, response); }));}
    void SetMessageAllocatorFor_GetPalletPointList(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::GetPalletPointListReq, ::Nrmk::IndyFramework::GetPalletPointListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::GetPalletPointListReq, ::Nrmk::IndyFramework::GetPalletPointListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GetPalletPointListReq* /*request*/, ::Nrmk::IndyFramework::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPalletPointList(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::GetPalletPointListReq* /*request*/, ::Nrmk::IndyFramework::GetPalletPointListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::CalculateRelativePoseReq, ::Nrmk::IndyFramework::CalculateRelativePoseRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* request, ::Nrmk::IndyFramework::CalculateRelativePoseRes* response) { return this->CalculateRelativePose(context, request, response); }));}
    void SetMessageAllocatorFor_CalculateRelativePose(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::CalculateRelativePoseReq, ::Nrmk::IndyFramework::CalculateRelativePoseRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::CalculateRelativePoseReq, ::Nrmk::IndyFramework::CalculateRelativePoseRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* /*request*/, ::Nrmk::IndyFramework::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateRelativePose(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* /*request*/, ::Nrmk::IndyFramework::CalculateRelativePoseRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* request, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* response) { return this->CalculateCurrentPoseRel(context, request, response); }));}
    void SetMessageAllocatorFor_CalculateCurrentPoseRel(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* /*request*/, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateCurrentPoseRel(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* /*request*/, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PingFromConty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PingFromConty() {
      ::grpc::Service::MarkMethodCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response) { return this->PingFromConty(context, request, response); }));}
    void SetMessageAllocatorFor_PingFromConty(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PingFromConty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingFromConty(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PingFromConty(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpDevice>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpDevice* response) { return this->GetTeleOpDevice(context, request, response); }));}
    void SetMessageAllocatorFor_GetTeleOpDevice(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpDevice>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(54);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpDevice>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpDevice* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpState* response) { return this->GetTeleOpState(context, request, response); }));}
    void SetMessageAllocatorFor_GetTeleOpState(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpState(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleOpDevice, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TeleOpDevice* request, ::Nrmk::IndyFramework::Response* response) { return this->ConnectTeleOpDevice(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectTeleOpDevice(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TeleOpDevice, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleOpDevice, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpDevice* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpDevice* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response) { return this->DisConnectTeleOpDevice(context, request, response); }));}
    void SetMessageAllocatorFor_DisConnectTeleOpDevice(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleP>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleP* response) { return this->ReadTeleOpInput(context, request, response); }));}
    void SetMessageAllocatorFor_ReadTeleOpInput(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleP>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleP>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadTeleOpInput(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleP* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartTeleOp() {
      ::grpc::Service::MarkMethodCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleOpState, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TeleOpState* request, ::Nrmk::IndyFramework::Response* response) { return this->StartTeleOp(context, request, response); }));}
    void SetMessageAllocatorFor_StartTeleOp(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TeleOpState, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleOpState, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleOp(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Response* response) { return this->StopTeleOp(context, request, response); }));}
    void SetMessageAllocatorFor_StopTeleOp(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopTeleOp(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TelePlayRate, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TelePlayRate* request, ::Nrmk::IndyFramework::Response* response) { return this->SetPlayRate(context, request, response); }));}
    void SetMessageAllocatorFor_SetPlayRate(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TelePlayRate, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TelePlayRate, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TelePlayRate* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TelePlayRate* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TelePlayRate>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TelePlayRate* response) { return this->GetPlayRate(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayRate(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TelePlayRate>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TelePlayRate>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TelePlayRate* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpFileList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::TeleOpFileList* response) { return this->GetTeleFileList(context, request, response); }));}
    void SetMessageAllocatorFor_GetTeleFileList(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpFileList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpFileList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpFileList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response) { return this->SaveTeleMotion(context, request, response); }));}
    void SetMessageAllocatorFor_SaveTeleMotion(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(64);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response) { return this->LoadTeleMotion(context, request, response); }));}
    void SetMessageAllocatorFor_LoadTeleMotion(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(65);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::TeleFileReq* request, ::Nrmk::IndyFramework::Response* response) { return this->DeleteTeleMotion(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteTeleMotion(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(66);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableTeleKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableTeleKey() {
      ::grpc::Service::MarkMethodCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::State* request, ::Nrmk::IndyFramework::Response* response) { return this->EnableTeleKey(context, request, response); }));}
    void SetMessageAllocatorFor_EnableTeleKey(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(67);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableTeleKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTeleKey(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableTeleKey(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveTeleJReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveTeleJReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveTeleJ(context, request, response); }));}
    void SetMessageAllocatorFor_MoveTeleJ(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveTeleJReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(68);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveTeleJReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleJ(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveTeleLReq, ::Nrmk::IndyFramework::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveTeleLReq* request, ::Nrmk::IndyFramework::Response* response) { return this->MoveTeleL(context, request, response); }));}
    void SetMessageAllocatorFor_MoveTeleL(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveTeleLReq, ::Nrmk::IndyFramework::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(69);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveTeleLReq, ::Nrmk::IndyFramework::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleL(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveFL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveFL() {
      ::grpc::Service::MarkMethodCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveFLReq, ::Nrmk::IndyFramework::MoveFLRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::MoveFLReq* request, ::Nrmk::IndyFramework::MoveFLRes* response) { return this->MoveFL(context, request, response); }));}
    void SetMessageAllocatorFor_MoveFL(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::MoveFLReq, ::Nrmk::IndyFramework::MoveFLRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(70);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::MoveFLReq, ::Nrmk::IndyFramework::MoveFLRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveFL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveFLReq* /*request*/, ::Nrmk::IndyFramework::MoveFLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveFL(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveFLReq* /*request*/, ::Nrmk::IndyFramework::MoveFLRes* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetControlInfo<WithCallbackMethod_ActivateIndySDK<WithCallbackMethod_MoveJ<WithCallbackMethod_MoveJT<WithCallbackMethod_MoveL<WithCallbackMethod_MoveLT<WithCallbackMethod_MoveC<WithCallbackMethod_MoveCT<WithCallbackMethod_WaitIO<WithCallbackMethod_WaitTime<WithCallbackMethod_WaitProgress<WithCallbackMethod_WaitTraj<WithCallbackMethod_WaitRadius<WithCallbackMethod_MoveJCond<WithCallbackMethod_StopMotion<WithCallbackMethod_PauseMotion<WithCallbackMethod_SetDirectTeaching<WithCallbackMethod_SetSimulationMode<WithCallbackMethod_SetCustomControlMode<WithCallbackMethod_GetCustomControlMode<WithCallbackMethod_SetFrictionCompensation<WithCallbackMethod_GetFrictionCompensationState<WithCallbackMethod_Recover<WithCallbackMethod_SetManualRecovery<WithCallbackMethod_MoveRecoverJoint<WithCallbackMethod_SearchProgram<WithCallbackMethod_PlayProgram<WithCallbackMethod_PauseProgram<WithCallbackMethod_ResumeProgram<WithCallbackMethod_StopProgram<WithCallbackMethod_SendAlarm<WithCallbackMethod_SendAnnotation<WithCallbackMethod_PlayTuningProgram<WithCallbackMethod_SetModbusVariableNameList<WithCallbackMethod_SetVariableNameList<WithCallbackMethod_GetVariableNameList<WithCallbackMethod_SetIntVariable<WithCallbackMethod_GetIntVariable<WithCallbackMethod_SetModbusVariable<WithCallbackMethod_GetModbusVariable<WithCallbackMethod_SetBoolVariable<WithCallbackMethod_GetBoolVariable<WithCallbackMethod_SetFloatVariable<WithCallbackMethod_GetFloatVariable<WithCallbackMethod_SetJPosVariable<WithCallbackMethod_GetJPosVariable<WithCallbackMethod_SetTPosVariable<WithCallbackMethod_GetTPosVariable<WithCallbackMethod_InverseKinematics<WithCallbackMethod_CheckAproachRetractValid<WithCallbackMethod_GetPalletPointList<WithCallbackMethod_CalculateRelativePose<WithCallbackMethod_CalculateCurrentPoseRel<WithCallbackMethod_PingFromConty<WithCallbackMethod_GetTeleOpDevice<WithCallbackMethod_GetTeleOpState<WithCallbackMethod_ConnectTeleOpDevice<WithCallbackMethod_DisConnectTeleOpDevice<WithCallbackMethod_ReadTeleOpInput<WithCallbackMethod_StartTeleOp<WithCallbackMethod_StopTeleOp<WithCallbackMethod_SetPlayRate<WithCallbackMethod_GetPlayRate<WithCallbackMethod_GetTeleFileList<WithCallbackMethod_SaveTeleMotion<WithCallbackMethod_LoadTeleMotion<WithCallbackMethod_DeleteTeleMotion<WithCallbackMethod_EnableTeleKey<WithCallbackMethod_MoveTeleJ<WithCallbackMethod_MoveTeleL<WithCallbackMethod_MoveFL<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetControlInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetControlInfo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetControlInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetControlInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ControlInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ActivateIndySDK : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ActivateIndySDK() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ActivateIndySDK() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateIndySDK(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SDKLicenseInfo* /*request*/, ::Nrmk::IndyFramework::SDKLicenseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveJ() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_MoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveJT() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_MoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveL() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveLT() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_MoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveLT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveC() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_MoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveC(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveCT() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_MoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveCT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitIO() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_WaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitIO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitIOReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitTime() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_WaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTime(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTimeReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitProgress() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_WaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitProgress(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitProgressReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitTraj() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_WaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTraj(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTrajReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitRadius() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_WaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitRadius(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitRadiusReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveJCond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveJCond() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_MoveJCond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJCond(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJCondReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopMotion() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::StopCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseMotion() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_PauseMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PauseCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDirectTeaching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDirectTeaching() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_SetDirectTeaching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeaching(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntMode* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFrictionCompensation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetFrictionCompensation() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_SetFrictionCompensation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFrictionCompensation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFrictionCompensationState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFrictionCompensationState() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetFrictionCompensationState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFrictionCompensationState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Recover() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetManualRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetManualRecovery() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_SetManualRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecovery(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveRecoverJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveRecoverJoint() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_MoveRecoverJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveRecoverJoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TargetJ* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SearchProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SearchProgram() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_SearchProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::ProgramInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayProgram() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseProgram() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopProgram() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendAlarm() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_SendAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAlarm(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendAnnotation() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_SendAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAnnotation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TuningProgram* /*request*/, ::Nrmk::IndyFramework::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetModbusVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetModbusVariableNameList() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_SetModbusVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVariableList* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVariableNameList() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_SetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AllVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVariableNameList() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_GetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AllVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetIntVariable() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_SetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIntVariable() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetModbusVariable() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_SetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModbusVariable() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_GetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ModbusVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetBoolVariable() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_SetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::BoolVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBoolVariable() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_GetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BoolVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetFloatVariable() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_SetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::FloatVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFloatVariable() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FloatVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetJPosVariable() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_SetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::JPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJPosVariable() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_GetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::JPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTPosVariable() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_SetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTPosVariable() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_GetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::InverseKinematicsReq* /*request*/, ::Nrmk::IndyFramework::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* /*request*/, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GetPalletPointListReq* /*request*/, ::Nrmk::IndyFramework::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* /*request*/, ::Nrmk::IndyFramework::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* /*request*/, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PingFromConty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PingFromConty() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_PingFromConty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingFromConty(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpDevice* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTeleOp() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_StartTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TelePlayRate* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableTeleKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableTeleKey() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_EnableTeleKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTeleKey(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveFL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveFL() {
      ::grpc::Service::MarkMethodGeneric(70);
    }
    ~WithGenericMethod_MoveFL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveFLReq* /*request*/, ::Nrmk::IndyFramework::MoveFLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetControlInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetControlInfo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetControlInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetControlInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ControlInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetControlInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ActivateIndySDK : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ActivateIndySDK() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ActivateIndySDK() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateIndySDK(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SDKLicenseInfo* /*request*/, ::Nrmk::IndyFramework::SDKLicenseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestActivateIndySDK(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveJ() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_MoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveJT() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_MoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveJT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveL() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveLT() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_MoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveLT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveLT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveC() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_MoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveC(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveC(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveCT() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_MoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveCT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveCT(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitIO() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_WaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitIO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitIOReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitIO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitTime() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_WaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTime(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTimeReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitProgress() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_WaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitProgress(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitProgressReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitProgress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitTraj() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_WaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTraj(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTrajReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitTraj(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitRadius() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_WaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitRadius(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitRadiusReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitRadius(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveJCond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveJCond() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_MoveJCond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJCond(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJCondReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveJCond(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopMotion() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::StopCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseMotion() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_PauseMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PauseCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDirectTeaching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDirectTeaching() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_SetDirectTeaching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeaching(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDirectTeaching(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSimulationMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntMode* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCustomControlMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCustomControlMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetFrictionCompensation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetFrictionCompensation() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_SetFrictionCompensation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFrictionCompensation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFrictionCompensation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFrictionCompensationState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFrictionCompensationState() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetFrictionCompensationState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFrictionCompensationState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFrictionCompensationState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Recover() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetManualRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetManualRecovery() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_SetManualRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecovery(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetManualRecovery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveRecoverJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveRecoverJoint() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_MoveRecoverJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveRecoverJoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TargetJ* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveRecoverJoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SearchProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SearchProgram() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_SearchProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::ProgramInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSearchProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayProgram() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseProgram() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopProgram() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendAlarm() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_SendAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAlarm(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendAlarm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendAnnotation() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_SendAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAnnotation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendAnnotation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TuningProgram* /*request*/, ::Nrmk::IndyFramework::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayTuningProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetModbusVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetModbusVariableNameList() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_SetModbusVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVariableList* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetModbusVariableNameList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVariableNameList() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_SetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AllVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariableNameList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVariableNameList() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_GetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AllVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVariableNameList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetIntVariable() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_SetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetIntVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIntVariable() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIntVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetModbusVariable() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_SetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetModbusVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModbusVariable() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_GetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ModbusVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModbusVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetBoolVariable() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_SetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::BoolVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetBoolVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBoolVariable() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_GetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BoolVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBoolVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetFloatVariable() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_SetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::FloatVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFloatVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFloatVariable() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FloatVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFloatVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetJPosVariable() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_SetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::JPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJPosVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJPosVariable() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_GetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::JPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJPosVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTPosVariable() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_SetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTPosVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTPosVariable() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_GetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTPosVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::InverseKinematicsReq* /*request*/, ::Nrmk::IndyFramework::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* /*request*/, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAproachRetractValid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GetPalletPointListReq* /*request*/, ::Nrmk::IndyFramework::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletPointList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* /*request*/, ::Nrmk::IndyFramework::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateRelativePose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* /*request*/, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateCurrentPoseRel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PingFromConty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PingFromConty() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_PingFromConty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingFromConty(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPingFromConty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpDevice* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadTeleOpInput(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTeleOp() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_StartTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTeleOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TelePlayRate* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleFileList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveTeleMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadTeleMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTeleMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableTeleKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableTeleKey() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_EnableTeleKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTeleKey(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableTeleKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveFL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveFL() {
      ::grpc::Service::MarkMethodRaw(70);
    }
    ~WithRawMethod_MoveFL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveFLReq* /*request*/, ::Nrmk::IndyFramework::MoveFLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveFL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetControlInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetControlInfo() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetControlInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetControlInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetControlInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ControlInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetControlInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ActivateIndySDK : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ActivateIndySDK() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ActivateIndySDK(context, request, response); }));
    }
    ~WithRawCallbackMethod_ActivateIndySDK() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ActivateIndySDK(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SDKLicenseInfo* /*request*/, ::Nrmk::IndyFramework::SDKLicenseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ActivateIndySDK(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveJ() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveJ(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveJ(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveJT() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveJT(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveJT(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveL() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveL(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveL(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveLT() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveLT(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveLT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveLT(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveC() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveC(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveC(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveC(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveCT() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveCT(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveCT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveCT(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WaitIO() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitIO(context, request, response); }));
    }
    ~WithRawCallbackMethod_WaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitIO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitIOReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitIO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WaitTime() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitTime(context, request, response); }));
    }
    ~WithRawCallbackMethod_WaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTime(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTimeReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitTime(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WaitProgress() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitProgress(context, request, response); }));
    }
    ~WithRawCallbackMethod_WaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitProgress(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitProgressReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitProgress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WaitTraj() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitTraj(context, request, response); }));
    }
    ~WithRawCallbackMethod_WaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitTraj(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTrajReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitTraj(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WaitRadius() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitRadius(context, request, response); }));
    }
    ~WithRawCallbackMethod_WaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitRadius(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitRadiusReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WaitRadius(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveJCond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveJCond() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveJCond(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveJCond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveJCond(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJCondReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveJCond(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopMotion() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::StopCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseMotion() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PauseCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDirectTeaching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDirectTeaching() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDirectTeaching(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDirectTeaching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeaching(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDirectTeaching(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSimulationMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSimulationMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCustomControlMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntMode* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCustomControlMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetFrictionCompensation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetFrictionCompensation() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetFrictionCompensation(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetFrictionCompensation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFrictionCompensation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFrictionCompensation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFrictionCompensationState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFrictionCompensationState() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFrictionCompensationState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFrictionCompensationState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFrictionCompensationState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFrictionCompensationState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Recover() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Recover(context, request, response); }));
    }
    ~WithRawCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Recover(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetManualRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetManualRecovery() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetManualRecovery(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetManualRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecovery(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetManualRecovery(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveRecoverJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveRecoverJoint() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveRecoverJoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveRecoverJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveRecoverJoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TargetJ* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveRecoverJoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SearchProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SearchProgram() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SearchProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_SearchProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::ProgramInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SearchProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayProgram() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseProgram() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResumeProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopProgram() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendAlarm() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendAlarm(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAlarm(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendAnnotation() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendAnnotation(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendAnnotation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendAnnotation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayTuningProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TuningProgram* /*request*/, ::Nrmk::IndyFramework::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayTuningProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetModbusVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetModbusVariableNameList() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetModbusVariableNameList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetModbusVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVariableList* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetModbusVariableNameList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetVariableNameList() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVariableNameList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AllVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVariableNameList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVariableNameList() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVariableNameList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AllVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVariableNameList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetIntVariable() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetIntVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetIntVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetIntVariable() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetIntVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIntVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetModbusVariable() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetModbusVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetModbusVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetModbusVariable() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModbusVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ModbusVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModbusVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetBoolVariable() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetBoolVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::BoolVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetBoolVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBoolVariable() {
      ::grpc::Service::MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBoolVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BoolVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBoolVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetFloatVariable() {
      ::grpc::Service::MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetFloatVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::FloatVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFloatVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFloatVariable() {
      ::grpc::Service::MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFloatVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FloatVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFloatVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetJPosVariable() {
      ::grpc::Service::MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetJPosVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::JPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJPosVariable() {
      ::grpc::Service::MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJPosVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::JPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetTPosVariable() {
      ::grpc::Service::MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTPosVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTPosVariable() {
      ::grpc::Service::MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTPosVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTPosVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InverseKinematics(context, request, response); }));
    }
    ~WithRawCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::InverseKinematicsReq* /*request*/, ::Nrmk::IndyFramework::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InverseKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckAproachRetractValid(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* /*request*/, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAproachRetractValid(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPalletPointList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GetPalletPointListReq* /*request*/, ::Nrmk::IndyFramework::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPalletPointList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CalculateRelativePose(context, request, response); }));
    }
    ~WithRawCallbackMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* /*request*/, ::Nrmk::IndyFramework::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateRelativePose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CalculateCurrentPoseRel(context, request, response); }));
    }
    ~WithRawCallbackMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* /*request*/, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateCurrentPoseRel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PingFromConty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PingFromConty() {
      ::grpc::Service::MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PingFromConty(context, request, response); }));
    }
    ~WithRawCallbackMethod_PingFromConty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PingFromConty(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PingFromConty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTeleOpDevice(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTeleOpState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectTeleOpDevice(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpDevice* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRawCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisConnectTeleOpDevice(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodRawCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadTeleOpInput(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadTeleOpInput(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartTeleOp() {
      ::grpc::Service::MarkMethodRawCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartTeleOp(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodRawCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopTeleOp(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopTeleOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodRawCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPlayRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TelePlayRate* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodRawCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodRawCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTeleFileList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodRawCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SaveTeleMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodRawCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadTeleMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodRawCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteTeleMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableTeleKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableTeleKey() {
      ::grpc::Service::MarkMethodRawCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableTeleKey(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableTeleKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableTeleKey(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableTeleKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodRawCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveTeleJ(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleJ(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodRawCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveTeleL(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleL(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveFL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveFL() {
      ::grpc::Service::MarkMethodRawCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveFL(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveFL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveFL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveFLReq* /*request*/, ::Nrmk::IndyFramework::MoveFLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveFL(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetControlInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetControlInfo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ControlInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ControlInfo>* streamer) {
                       return this->StreamedGetControlInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetControlInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetControlInfo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ControlInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetControlInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::ControlInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ActivateIndySDK : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ActivateIndySDK() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::SDKLicenseInfo, ::Nrmk::IndyFramework::SDKLicenseResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::SDKLicenseInfo, ::Nrmk::IndyFramework::SDKLicenseResp>* streamer) {
                       return this->StreamedActivateIndySDK(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ActivateIndySDK() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ActivateIndySDK(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::SDKLicenseInfo* /*request*/, ::Nrmk::IndyFramework::SDKLicenseResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedActivateIndySDK(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::SDKLicenseInfo,::Nrmk::IndyFramework::SDKLicenseResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveJ() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveJReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveJReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveJ(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveJReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveJT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveJT() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveJTReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveJTReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveJT(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveJT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveJT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveJT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveJTReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveL() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveLReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveLReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveL(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveLReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveLT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveLT() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveLTReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveLTReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveLT(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveLT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveLT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveLTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveLT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveLTReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveC() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveCReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveCReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveC(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveC(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveC(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveCReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveCT : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveCT() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveCTReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveCTReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveCT(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveCT() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveCT(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveCTReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveCT(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveCTReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitIO() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::WaitIOReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::WaitIOReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedWaitIO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitIO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitIOReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitIO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::WaitIOReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitTime() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::WaitTimeReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::WaitTimeReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedWaitTime(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitTime(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTimeReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::WaitTimeReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitProgress() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::WaitProgressReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::WaitProgressReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedWaitProgress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitProgress(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitProgressReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitProgress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::WaitProgressReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitTraj : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitTraj() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::WaitTrajReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::WaitTrajReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedWaitTraj(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitTraj() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitTraj(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitTrajReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitTraj(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::WaitTrajReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitRadius : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitRadius() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::WaitRadiusReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::WaitRadiusReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedWaitRadius(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitRadius() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitRadius(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::WaitRadiusReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitRadius(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::WaitRadiusReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveJCond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveJCond() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveJCondReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveJCondReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveJCond(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveJCond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveJCond(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveJCondReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveJCond(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveJCondReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopMotion() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::StopCat, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::StopCat, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedStopMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::StopCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::StopCat,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseMotion() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::PauseCat, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::PauseCat, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedPauseMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::PauseCat* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::PauseCat,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDirectTeaching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDirectTeaching() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetDirectTeaching(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDirectTeaching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDirectTeaching(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDirectTeaching(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::State,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetSimulationMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSimulationMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::State,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::IntMode, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::IntMode, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetCustomControlMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntMode* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCustomControlMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::IntMode,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntMode>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntMode>* streamer) {
                       return this->StreamedGetCustomControlMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCustomControlMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::IntMode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetFrictionCompensation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetFrictionCompensation() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetFrictionCompensation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetFrictionCompensation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetFrictionCompensation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetFrictionCompensation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::State,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFrictionCompensationState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFrictionCompensationState() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::State>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::State>* streamer) {
                       return this->StreamedGetFrictionCompensationState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFrictionCompensationState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFrictionCompensationState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFrictionCompensationState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::State>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Recover() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedRecover(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetManualRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetManualRecovery() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetManualRecovery(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetManualRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetManualRecovery(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetManualRecovery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::State,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveRecoverJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveRecoverJoint() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TargetJ, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TargetJ, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveRecoverJoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveRecoverJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveRecoverJoint(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TargetJ* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveRecoverJoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TargetJ,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SearchProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SearchProgram() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::ProgramInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::ProgramInfo>* streamer) {
                       return this->StreamedSearchProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SearchProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SearchProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::ProgramInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSearchProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Program,::Nrmk::IndyFramework::ProgramInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayProgram() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Program, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedPlayProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Program* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Program,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseProgram() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedPauseProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedResumeProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResumeProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopProgram() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedStopProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendAlarm() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSendAlarm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendAlarm(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendAlarm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Message,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendAnnotation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendAnnotation() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Message, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSendAnnotation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendAnnotation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendAnnotation(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Message* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendAnnotation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Message,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TuningProgram, ::Nrmk::IndyFramework::CollisionThresholds>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TuningProgram, ::Nrmk::IndyFramework::CollisionThresholds>* streamer) {
                       return this->StreamedPlayTuningProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TuningProgram* /*request*/, ::Nrmk::IndyFramework::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayTuningProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TuningProgram,::Nrmk::IndyFramework::CollisionThresholds>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetModbusVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetModbusVariableNameList() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ModbusVariableList, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ModbusVariableList, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetModbusVariableNameList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetModbusVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetModbusVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVariableList* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetModbusVariableNameList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ModbusVariableList,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVariableNameList() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::AllVars, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::AllVars, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetVariableNameList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::AllVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVariableNameList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::AllVars,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVariableNameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVariableNameList() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AllVars>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::AllVars>* streamer) {
                       return this->StreamedGetVariableNameList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVariableNameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVariableNameList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::AllVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVariableNameList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::AllVars>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetIntVariable() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::IntVars, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::IntVars, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetIntVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IntVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetIntVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::IntVars,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIntVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIntVariable() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntVars>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IntVars>* streamer) {
                       return this->StreamedGetIntVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetIntVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIntVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IntVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIntVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::IntVars>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetModbusVariable() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ModbusVars, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ModbusVars, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetModbusVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ModbusVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetModbusVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ModbusVars,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModbusVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModbusVariable() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ModbusVars>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::ModbusVars>* streamer) {
                       return this->StreamedGetModbusVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetModbusVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModbusVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::ModbusVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModbusVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::ModbusVars>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetBoolVariable() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::BoolVars, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::BoolVars, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetBoolVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::BoolVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetBoolVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::BoolVars,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBoolVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBoolVariable() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BoolVars>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::BoolVars>* streamer) {
                       return this->StreamedGetBoolVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBoolVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBoolVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::BoolVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBoolVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::BoolVars>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetFloatVariable() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::FloatVars, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::FloatVars, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetFloatVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::FloatVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetFloatVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::FloatVars,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFloatVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFloatVariable() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FloatVars>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::FloatVars>* streamer) {
                       return this->StreamedGetFloatVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFloatVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFloatVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::FloatVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFloatVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::FloatVars>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetJPosVariable() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::JPosVars, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::JPosVars, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetJPosVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::JPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetJPosVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::JPosVars,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJPosVariable() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::JPosVars>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::JPosVars>* streamer) {
                       return this->StreamedGetJPosVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::JPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJPosVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::JPosVars>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTPosVariable() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TPosVars, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TPosVars, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetTPosVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TPosVars* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTPosVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TPosVars,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTPosVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTPosVariable() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TPosVars>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TPosVars>* streamer) {
                       return this->StreamedGetTPosVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTPosVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTPosVariable(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TPosVars* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTPosVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::TPosVars>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::InverseKinematicsReq, ::Nrmk::IndyFramework::InverseKinematicsRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::InverseKinematicsReq, ::Nrmk::IndyFramework::InverseKinematicsRes>* streamer) {
                       return this->StreamedInverseKinematics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::InverseKinematicsReq* /*request*/, ::Nrmk::IndyFramework::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInverseKinematics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::InverseKinematicsReq,::Nrmk::IndyFramework::InverseKinematicsRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::CheckAproachRetractValidReq, ::Nrmk::IndyFramework::CheckAproachRetractValidRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::CheckAproachRetractValidReq, ::Nrmk::IndyFramework::CheckAproachRetractValidRes>* streamer) {
                       return this->StreamedCheckAproachRetractValid(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CheckAproachRetractValidReq* /*request*/, ::Nrmk::IndyFramework::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckAproachRetractValid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::CheckAproachRetractValidReq,::Nrmk::IndyFramework::CheckAproachRetractValidRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::GetPalletPointListReq, ::Nrmk::IndyFramework::GetPalletPointListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::GetPalletPointListReq, ::Nrmk::IndyFramework::GetPalletPointListRes>* streamer) {
                       return this->StreamedGetPalletPointList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::GetPalletPointListReq* /*request*/, ::Nrmk::IndyFramework::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPalletPointList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::GetPalletPointListReq,::Nrmk::IndyFramework::GetPalletPointListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::CalculateRelativePoseReq, ::Nrmk::IndyFramework::CalculateRelativePoseRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::CalculateRelativePoseReq, ::Nrmk::IndyFramework::CalculateRelativePoseRes>* streamer) {
                       return this->StreamedCalculateRelativePose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateRelativePoseReq* /*request*/, ::Nrmk::IndyFramework::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateRelativePose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::CalculateRelativePoseReq,::Nrmk::IndyFramework::CalculateRelativePoseRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* streamer) {
                       return this->StreamedCalculateCurrentPoseRel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq* /*request*/, ::Nrmk::IndyFramework::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateCurrentPoseRel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::CalculateCurrentPoseRelReq,::Nrmk::IndyFramework::CalculateCurrentPoseRelRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PingFromConty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PingFromConty() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedPingFromConty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PingFromConty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PingFromConty(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPingFromConty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpDevice>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpDevice>* streamer) {
                       return this->StreamedGetTeleOpDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTeleOpDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::TeleOpDevice>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpState>* streamer) {
                       return this->StreamedGetTeleOpState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTeleOpState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::TeleOpState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TeleOpDevice, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TeleOpDevice, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedConnectTeleOpDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpDevice* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TeleOpDevice,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedDisConnectTeleOpDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleP>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleP>* streamer) {
                       return this->StreamedReadTeleOpInput(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadTeleOpInput(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::TeleP>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartTeleOp() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TeleOpState, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TeleOpState, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedStartTeleOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleOpState* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartTeleOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TeleOpState,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedStopTeleOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopTeleOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TelePlayRate, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TelePlayRate, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSetPlayRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TelePlayRate* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPlayRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TelePlayRate,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TelePlayRate>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TelePlayRate>* streamer) {
                       return this->StreamedGetPlayRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::TelePlayRate>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpFileList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::TeleOpFileList>* streamer) {
                       return this->StreamedGetTeleFileList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTeleFileList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::TeleOpFileList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedSaveTeleMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSaveTeleMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TeleFileReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedLoadTeleMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadTeleMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TeleFileReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::TeleFileReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedDeleteTeleMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::TeleFileReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteTeleMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::TeleFileReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableTeleKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableTeleKey() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::State, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedEnableTeleKey(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableTeleKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableTeleKey(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::State* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableTeleKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::State,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodStreamed(68,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveTeleJReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveTeleJReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveTeleJ(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleJReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveTeleJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveTeleJReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodStreamed(69,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveTeleLReq, ::Nrmk::IndyFramework::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveTeleLReq, ::Nrmk::IndyFramework::Response>* streamer) {
                       return this->StreamedMoveTeleL(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveTeleLReq* /*request*/, ::Nrmk::IndyFramework::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveTeleL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveTeleLReq,::Nrmk::IndyFramework::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveFL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveFL() {
      ::grpc::Service::MarkMethodStreamed(70,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::MoveFLReq, ::Nrmk::IndyFramework::MoveFLRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::MoveFLReq, ::Nrmk::IndyFramework::MoveFLRes>* streamer) {
                       return this->StreamedMoveFL(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveFL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveFL(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::MoveFLReq* /*request*/, ::Nrmk::IndyFramework::MoveFLRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveFL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::MoveFLReq,::Nrmk::IndyFramework::MoveFLRes>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetControlInfo<WithStreamedUnaryMethod_ActivateIndySDK<WithStreamedUnaryMethod_MoveJ<WithStreamedUnaryMethod_MoveJT<WithStreamedUnaryMethod_MoveL<WithStreamedUnaryMethod_MoveLT<WithStreamedUnaryMethod_MoveC<WithStreamedUnaryMethod_MoveCT<WithStreamedUnaryMethod_WaitIO<WithStreamedUnaryMethod_WaitTime<WithStreamedUnaryMethod_WaitProgress<WithStreamedUnaryMethod_WaitTraj<WithStreamedUnaryMethod_WaitRadius<WithStreamedUnaryMethod_MoveJCond<WithStreamedUnaryMethod_StopMotion<WithStreamedUnaryMethod_PauseMotion<WithStreamedUnaryMethod_SetDirectTeaching<WithStreamedUnaryMethod_SetSimulationMode<WithStreamedUnaryMethod_SetCustomControlMode<WithStreamedUnaryMethod_GetCustomControlMode<WithStreamedUnaryMethod_SetFrictionCompensation<WithStreamedUnaryMethod_GetFrictionCompensationState<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_SetManualRecovery<WithStreamedUnaryMethod_MoveRecoverJoint<WithStreamedUnaryMethod_SearchProgram<WithStreamedUnaryMethod_PlayProgram<WithStreamedUnaryMethod_PauseProgram<WithStreamedUnaryMethod_ResumeProgram<WithStreamedUnaryMethod_StopProgram<WithStreamedUnaryMethod_SendAlarm<WithStreamedUnaryMethod_SendAnnotation<WithStreamedUnaryMethod_PlayTuningProgram<WithStreamedUnaryMethod_SetModbusVariableNameList<WithStreamedUnaryMethod_SetVariableNameList<WithStreamedUnaryMethod_GetVariableNameList<WithStreamedUnaryMethod_SetIntVariable<WithStreamedUnaryMethod_GetIntVariable<WithStreamedUnaryMethod_SetModbusVariable<WithStreamedUnaryMethod_GetModbusVariable<WithStreamedUnaryMethod_SetBoolVariable<WithStreamedUnaryMethod_GetBoolVariable<WithStreamedUnaryMethod_SetFloatVariable<WithStreamedUnaryMethod_GetFloatVariable<WithStreamedUnaryMethod_SetJPosVariable<WithStreamedUnaryMethod_GetJPosVariable<WithStreamedUnaryMethod_SetTPosVariable<WithStreamedUnaryMethod_GetTPosVariable<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_CheckAproachRetractValid<WithStreamedUnaryMethod_GetPalletPointList<WithStreamedUnaryMethod_CalculateRelativePose<WithStreamedUnaryMethod_CalculateCurrentPoseRel<WithStreamedUnaryMethod_PingFromConty<WithStreamedUnaryMethod_GetTeleOpDevice<WithStreamedUnaryMethod_GetTeleOpState<WithStreamedUnaryMethod_ConnectTeleOpDevice<WithStreamedUnaryMethod_DisConnectTeleOpDevice<WithStreamedUnaryMethod_ReadTeleOpInput<WithStreamedUnaryMethod_StartTeleOp<WithStreamedUnaryMethod_StopTeleOp<WithStreamedUnaryMethod_SetPlayRate<WithStreamedUnaryMethod_GetPlayRate<WithStreamedUnaryMethod_GetTeleFileList<WithStreamedUnaryMethod_SaveTeleMotion<WithStreamedUnaryMethod_LoadTeleMotion<WithStreamedUnaryMethod_DeleteTeleMotion<WithStreamedUnaryMethod_EnableTeleKey<WithStreamedUnaryMethod_MoveTeleJ<WithStreamedUnaryMethod_MoveTeleL<WithStreamedUnaryMethod_MoveFL<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetControlInfo<WithStreamedUnaryMethod_ActivateIndySDK<WithStreamedUnaryMethod_MoveJ<WithStreamedUnaryMethod_MoveJT<WithStreamedUnaryMethod_MoveL<WithStreamedUnaryMethod_MoveLT<WithStreamedUnaryMethod_MoveC<WithStreamedUnaryMethod_MoveCT<WithStreamedUnaryMethod_WaitIO<WithStreamedUnaryMethod_WaitTime<WithStreamedUnaryMethod_WaitProgress<WithStreamedUnaryMethod_WaitTraj<WithStreamedUnaryMethod_WaitRadius<WithStreamedUnaryMethod_MoveJCond<WithStreamedUnaryMethod_StopMotion<WithStreamedUnaryMethod_PauseMotion<WithStreamedUnaryMethod_SetDirectTeaching<WithStreamedUnaryMethod_SetSimulationMode<WithStreamedUnaryMethod_SetCustomControlMode<WithStreamedUnaryMethod_GetCustomControlMode<WithStreamedUnaryMethod_SetFrictionCompensation<WithStreamedUnaryMethod_GetFrictionCompensationState<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_SetManualRecovery<WithStreamedUnaryMethod_MoveRecoverJoint<WithStreamedUnaryMethod_SearchProgram<WithStreamedUnaryMethod_PlayProgram<WithStreamedUnaryMethod_PauseProgram<WithStreamedUnaryMethod_ResumeProgram<WithStreamedUnaryMethod_StopProgram<WithStreamedUnaryMethod_SendAlarm<WithStreamedUnaryMethod_SendAnnotation<WithStreamedUnaryMethod_PlayTuningProgram<WithStreamedUnaryMethod_SetModbusVariableNameList<WithStreamedUnaryMethod_SetVariableNameList<WithStreamedUnaryMethod_GetVariableNameList<WithStreamedUnaryMethod_SetIntVariable<WithStreamedUnaryMethod_GetIntVariable<WithStreamedUnaryMethod_SetModbusVariable<WithStreamedUnaryMethod_GetModbusVariable<WithStreamedUnaryMethod_SetBoolVariable<WithStreamedUnaryMethod_GetBoolVariable<WithStreamedUnaryMethod_SetFloatVariable<WithStreamedUnaryMethod_GetFloatVariable<WithStreamedUnaryMethod_SetJPosVariable<WithStreamedUnaryMethod_GetJPosVariable<WithStreamedUnaryMethod_SetTPosVariable<WithStreamedUnaryMethod_GetTPosVariable<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_CheckAproachRetractValid<WithStreamedUnaryMethod_GetPalletPointList<WithStreamedUnaryMethod_CalculateRelativePose<WithStreamedUnaryMethod_CalculateCurrentPoseRel<WithStreamedUnaryMethod_PingFromConty<WithStreamedUnaryMethod_GetTeleOpDevice<WithStreamedUnaryMethod_GetTeleOpState<WithStreamedUnaryMethod_ConnectTeleOpDevice<WithStreamedUnaryMethod_DisConnectTeleOpDevice<WithStreamedUnaryMethod_ReadTeleOpInput<WithStreamedUnaryMethod_StartTeleOp<WithStreamedUnaryMethod_StopTeleOp<WithStreamedUnaryMethod_SetPlayRate<WithStreamedUnaryMethod_GetPlayRate<WithStreamedUnaryMethod_GetTeleFileList<WithStreamedUnaryMethod_SaveTeleMotion<WithStreamedUnaryMethod_LoadTeleMotion<WithStreamedUnaryMethod_DeleteTeleMotion<WithStreamedUnaryMethod_EnableTeleKey<WithStreamedUnaryMethod_MoveTeleJ<WithStreamedUnaryMethod_MoveTeleL<WithStreamedUnaryMethod_MoveFL<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace IndyFramework
}  // namespace Nrmk


#endif  // GRPC_control_2eproto__INCLUDED
