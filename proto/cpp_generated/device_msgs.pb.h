// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_msgs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_device_5fmsgs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_device_5fmsgs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common_msgs.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_device_5fmsgs_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_device_5fmsgs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_device_5fmsgs_2eproto;
namespace Nrmk {
namespace IndyFramework {
class AddPhotoneoCalibPointReq;
struct AddPhotoneoCalibPointReqDefaultTypeInternal;
extern AddPhotoneoCalibPointReqDefaultTypeInternal _AddPhotoneoCalibPointReq_default_instance_;
class AnalogList;
struct AnalogListDefaultTypeInternal;
extern AnalogListDefaultTypeInternal _AnalogList_default_instance_;
class AnalogSignal;
struct AnalogSignalDefaultTypeInternal;
extern AnalogSignalDefaultTypeInternal _AnalogSignal_default_instance_;
class BrakeControlStyle;
struct BrakeControlStyleDefaultTypeInternal;
extern BrakeControlStyleDefaultTypeInternal _BrakeControlStyle_default_instance_;
class CheckAutoModeRes;
struct CheckAutoModeResDefaultTypeInternal;
extern CheckAutoModeResDefaultTypeInternal _CheckAutoModeRes_default_instance_;
class CheckReducedModeRes;
struct CheckReducedModeResDefaultTypeInternal;
extern CheckReducedModeResDefaultTypeInternal _CheckReducedModeRes_default_instance_;
class Conveyor;
struct ConveyorDefaultTypeInternal;
extern ConveyorDefaultTypeInternal _Conveyor_default_instance_;
class ConveyorState;
struct ConveyorStateDefaultTypeInternal;
extern ConveyorStateDefaultTypeInternal _ConveyorState_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class DigitalList;
struct DigitalListDefaultTypeInternal;
extern DigitalListDefaultTypeInternal _DigitalList_default_instance_;
class DigitalSignal;
struct DigitalSignalDefaultTypeInternal;
extern DigitalSignalDefaultTypeInternal _DigitalSignal_default_instance_;
class Encoder;
struct EncoderDefaultTypeInternal;
extern EncoderDefaultTypeInternal _Encoder_default_instance_;
class EndLedDim;
struct EndLedDimDefaultTypeInternal;
extern EndLedDimDefaultTypeInternal _EndLedDim_default_instance_;
class EndtoolSignal;
struct EndtoolSignalDefaultTypeInternal;
extern EndtoolSignalDefaultTypeInternal _EndtoolSignal_default_instance_;
class EndtoolSignalList;
struct EndtoolSignalListDefaultTypeInternal;
extern EndtoolSignalListDefaultTypeInternal _EndtoolSignalList_default_instance_;
class FTSensorData;
struct FTSensorDataDefaultTypeInternal;
extern FTSensorDataDefaultTypeInternal _FTSensorData_default_instance_;
class GetEL5001Data;
struct GetEL5001DataDefaultTypeInternal;
extern GetEL5001DataDefaultTypeInternal _GetEL5001Data_default_instance_;
class GetEL5101Data;
struct GetEL5101DataDefaultTypeInternal;
extern GetEL5101DataDefaultTypeInternal _GetEL5101Data_default_instance_;
class GetLoadFactorsRes;
struct GetLoadFactorsResDefaultTypeInternal;
extern GetLoadFactorsResDefaultTypeInternal _GetLoadFactorsRes_default_instance_;
class GripperCommand;
struct GripperCommandDefaultTypeInternal;
extern GripperCommandDefaultTypeInternal _GripperCommand_default_instance_;
class GripperData;
struct GripperDataDefaultTypeInternal;
extern GripperDataDefaultTypeInternal _GripperData_default_instance_;
class Motor;
struct MotorDefaultTypeInternal;
extern MotorDefaultTypeInternal _Motor_default_instance_;
class MotorList;
struct MotorListDefaultTypeInternal;
extern MotorListDefaultTypeInternal _MotorList_default_instance_;
class SafetyControlData;
struct SafetyControlDataDefaultTypeInternal;
extern SafetyControlDataDefaultTypeInternal _SafetyControlData_default_instance_;
class SafetyFunctionState;
struct SafetyFunctionStateDefaultTypeInternal;
extern SafetyFunctionStateDefaultTypeInternal _SafetyFunctionState_default_instance_;
class SanderCommand;
struct SanderCommandDefaultTypeInternal;
extern SanderCommandDefaultTypeInternal _SanderCommand_default_instance_;
class Servo;
struct ServoDefaultTypeInternal;
extern ServoDefaultTypeInternal _Servo_default_instance_;
class SetAutoModeReq;
struct SetAutoModeReqDefaultTypeInternal;
extern SetAutoModeReqDefaultTypeInternal _SetAutoModeReq_default_instance_;
class SetAutoModeRes;
struct SetAutoModeResDefaultTypeInternal;
extern SetAutoModeResDefaultTypeInternal _SetAutoModeRes_default_instance_;
class Trigger;
struct TriggerDefaultTypeInternal;
extern TriggerDefaultTypeInternal _Trigger_default_instance_;
class VisionRequest;
struct VisionRequestDefaultTypeInternal;
extern VisionRequestDefaultTypeInternal _VisionRequest_default_instance_;
class VisionResult;
struct VisionResultDefaultTypeInternal;
extern VisionResultDefaultTypeInternal _VisionResult_default_instance_;
class VisionServer;
struct VisionServerDefaultTypeInternal;
extern VisionServerDefaultTypeInternal _VisionServer_default_instance_;
}  // namespace IndyFramework
}  // namespace Nrmk
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace Nrmk {
namespace IndyFramework {
enum GripperCommand_GripperCommandType : int {
  GripperCommand_GripperCommandType_AUTO_DETECT = 0,
  GripperCommand_GripperCommandType_ACTIVATE = 1,
  GripperCommand_GripperCommandType_RE_ACTIVATE = 2,
  GripperCommand_GripperCommandType_SET_PVT = 3,
  GripperCommand_GripperCommandType_GripperCommand_GripperCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GripperCommand_GripperCommandType_GripperCommand_GripperCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GripperCommand_GripperCommandType_IsValid(int value);
constexpr GripperCommand_GripperCommandType GripperCommand_GripperCommandType_GripperCommandType_MIN = static_cast<GripperCommand_GripperCommandType>(0);
constexpr GripperCommand_GripperCommandType GripperCommand_GripperCommandType_GripperCommandType_MAX = static_cast<GripperCommand_GripperCommandType>(3);
constexpr int GripperCommand_GripperCommandType_GripperCommandType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
GripperCommand_GripperCommandType_descriptor();
template <typename T>
const std::string& GripperCommand_GripperCommandType_Name(T value) {
  static_assert(std::is_same<T, GripperCommand_GripperCommandType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GripperCommandType_Name().");
  return GripperCommand_GripperCommandType_Name(static_cast<GripperCommand_GripperCommandType>(value));
}
template <>
inline const std::string& GripperCommand_GripperCommandType_Name(GripperCommand_GripperCommandType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GripperCommand_GripperCommandType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool GripperCommand_GripperCommandType_Parse(absl::string_view name, GripperCommand_GripperCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GripperCommand_GripperCommandType>(
      GripperCommand_GripperCommandType_descriptor(), name, value);
}
enum BrakeControlStyle_ControlStyle : int {
  BrakeControlStyle_ControlStyle_UNAVAILABLE = 0,
  BrakeControlStyle_ControlStyle_CONCURRENT = 1,
  BrakeControlStyle_ControlStyle_INDIVIDUAL = 2,
  BrakeControlStyle_ControlStyle_BrakeControlStyle_ControlStyle_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BrakeControlStyle_ControlStyle_BrakeControlStyle_ControlStyle_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BrakeControlStyle_ControlStyle_IsValid(int value);
constexpr BrakeControlStyle_ControlStyle BrakeControlStyle_ControlStyle_ControlStyle_MIN = static_cast<BrakeControlStyle_ControlStyle>(0);
constexpr BrakeControlStyle_ControlStyle BrakeControlStyle_ControlStyle_ControlStyle_MAX = static_cast<BrakeControlStyle_ControlStyle>(2);
constexpr int BrakeControlStyle_ControlStyle_ControlStyle_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
BrakeControlStyle_ControlStyle_descriptor();
template <typename T>
const std::string& BrakeControlStyle_ControlStyle_Name(T value) {
  static_assert(std::is_same<T, BrakeControlStyle_ControlStyle>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControlStyle_Name().");
  return BrakeControlStyle_ControlStyle_Name(static_cast<BrakeControlStyle_ControlStyle>(value));
}
template <>
inline const std::string& BrakeControlStyle_ControlStyle_Name(BrakeControlStyle_ControlStyle value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BrakeControlStyle_ControlStyle_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool BrakeControlStyle_ControlStyle_Parse(absl::string_view name, BrakeControlStyle_ControlStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BrakeControlStyle_ControlStyle>(
      BrakeControlStyle_ControlStyle_descriptor(), name, value);
}
enum SanderCommand_SanderType : int {
  SanderCommand_SanderType_SANDER_ONROBOT = 0,
  SanderCommand_SanderType_SanderCommand_SanderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SanderCommand_SanderType_SanderCommand_SanderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SanderCommand_SanderType_IsValid(int value);
constexpr SanderCommand_SanderType SanderCommand_SanderType_SanderType_MIN = static_cast<SanderCommand_SanderType>(0);
constexpr SanderCommand_SanderType SanderCommand_SanderType_SanderType_MAX = static_cast<SanderCommand_SanderType>(0);
constexpr int SanderCommand_SanderType_SanderType_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
SanderCommand_SanderType_descriptor();
template <typename T>
const std::string& SanderCommand_SanderType_Name(T value) {
  static_assert(std::is_same<T, SanderCommand_SanderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SanderType_Name().");
  return SanderCommand_SanderType_Name(static_cast<SanderCommand_SanderType>(value));
}
template <>
inline const std::string& SanderCommand_SanderType_Name(SanderCommand_SanderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SanderCommand_SanderType_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool SanderCommand_SanderType_Parse(absl::string_view name, SanderCommand_SanderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SanderCommand_SanderType>(
      SanderCommand_SanderType_descriptor(), name, value);
}
enum Encoder_EncoderType : int {
  Encoder_EncoderType_CONSTANT = 0,
  Encoder_EncoderType_QUADRATURE = 1,
  Encoder_EncoderType_RISING = 2,
  Encoder_EncoderType_FALLING = 3,
  Encoder_EncoderType_MODBUS = 4,
  Encoder_EncoderType_Encoder_EncoderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Encoder_EncoderType_Encoder_EncoderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Encoder_EncoderType_IsValid(int value);
constexpr Encoder_EncoderType Encoder_EncoderType_EncoderType_MIN = static_cast<Encoder_EncoderType>(0);
constexpr Encoder_EncoderType Encoder_EncoderType_EncoderType_MAX = static_cast<Encoder_EncoderType>(4);
constexpr int Encoder_EncoderType_EncoderType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Encoder_EncoderType_descriptor();
template <typename T>
const std::string& Encoder_EncoderType_Name(T value) {
  static_assert(std::is_same<T, Encoder_EncoderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EncoderType_Name().");
  return Encoder_EncoderType_Name(static_cast<Encoder_EncoderType>(value));
}
template <>
inline const std::string& Encoder_EncoderType_Name(Encoder_EncoderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Encoder_EncoderType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Encoder_EncoderType_Parse(absl::string_view name, Encoder_EncoderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Encoder_EncoderType>(
      Encoder_EncoderType_descriptor(), name, value);
}
enum Trigger_TriggerType : int {
  Trigger_TriggerType_DIGITAL = 0,
  Trigger_TriggerType_MODBUS = 1,
  Trigger_TriggerType_Trigger_TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Trigger_TriggerType_Trigger_TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Trigger_TriggerType_IsValid(int value);
constexpr Trigger_TriggerType Trigger_TriggerType_TriggerType_MIN = static_cast<Trigger_TriggerType>(0);
constexpr Trigger_TriggerType Trigger_TriggerType_TriggerType_MAX = static_cast<Trigger_TriggerType>(1);
constexpr int Trigger_TriggerType_TriggerType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Trigger_TriggerType_descriptor();
template <typename T>
const std::string& Trigger_TriggerType_Name(T value) {
  static_assert(std::is_same<T, Trigger_TriggerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TriggerType_Name().");
  return Trigger_TriggerType_Name(static_cast<Trigger_TriggerType>(value));
}
template <>
inline const std::string& Trigger_TriggerType_Name(Trigger_TriggerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Trigger_TriggerType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Trigger_TriggerType_Parse(absl::string_view name, Trigger_TriggerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Trigger_TriggerType>(
      Trigger_TriggerType_descriptor(), name, value);
}
enum VisionServer_VisionServerType : int {
  VisionServer_VisionServerType_INDYEYE = 0,
  VisionServer_VisionServerType_PHOTONEO = 1,
  VisionServer_VisionServerType_HELIOS = 2,
  VisionServer_VisionServerType_VisionServer_VisionServerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VisionServer_VisionServerType_VisionServer_VisionServerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VisionServer_VisionServerType_IsValid(int value);
constexpr VisionServer_VisionServerType VisionServer_VisionServerType_VisionServerType_MIN = static_cast<VisionServer_VisionServerType>(0);
constexpr VisionServer_VisionServerType VisionServer_VisionServerType_VisionServerType_MAX = static_cast<VisionServer_VisionServerType>(2);
constexpr int VisionServer_VisionServerType_VisionServerType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VisionServer_VisionServerType_descriptor();
template <typename T>
const std::string& VisionServer_VisionServerType_Name(T value) {
  static_assert(std::is_same<T, VisionServer_VisionServerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VisionServerType_Name().");
  return VisionServer_VisionServerType_Name(static_cast<VisionServer_VisionServerType>(value));
}
template <>
inline const std::string& VisionServer_VisionServerType_Name(VisionServer_VisionServerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VisionServer_VisionServerType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VisionServer_VisionServerType_Parse(absl::string_view name, VisionServer_VisionServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisionServer_VisionServerType>(
      VisionServer_VisionServerType_descriptor(), name, value);
}
enum GripperType : int {
  NONE = 0,
  ROBOTIQ_GRIPPER = 1,
  DH_GRIPPER = 2,
  GripperType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GripperType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GripperType_IsValid(int value);
constexpr GripperType GripperType_MIN = static_cast<GripperType>(0);
constexpr GripperType GripperType_MAX = static_cast<GripperType>(2);
constexpr int GripperType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
GripperType_descriptor();
template <typename T>
const std::string& GripperType_Name(T value) {
  static_assert(std::is_same<T, GripperType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GripperType_Name().");
  return GripperType_Name(static_cast<GripperType>(value));
}
template <>
inline const std::string& GripperType_Name(GripperType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GripperType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool GripperType_Parse(absl::string_view name, GripperType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GripperType>(
      GripperType_descriptor(), name, value);
}
enum DigitalState : int {
  OFF_STATE = 0,
  ON_STATE = 1,
  UNUSED_STATE = 2,
  DigitalState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DigitalState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DigitalState_IsValid(int value);
constexpr DigitalState DigitalState_MIN = static_cast<DigitalState>(0);
constexpr DigitalState DigitalState_MAX = static_cast<DigitalState>(2);
constexpr int DigitalState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DigitalState_descriptor();
template <typename T>
const std::string& DigitalState_Name(T value) {
  static_assert(std::is_same<T, DigitalState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DigitalState_Name().");
  return DigitalState_Name(static_cast<DigitalState>(value));
}
template <>
inline const std::string& DigitalState_Name(DigitalState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DigitalState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DigitalState_Parse(absl::string_view name, DigitalState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DigitalState>(
      DigitalState_descriptor(), name, value);
}
enum EndtoolState : int {
  UNUSED = 0,
  HIGH_PNP = 2,
  HIGH_NPN = 1,
  LOW_NPN = -1,
  LOW_PNP = -2,
  EndtoolState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EndtoolState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EndtoolState_IsValid(int value);
constexpr EndtoolState EndtoolState_MIN = static_cast<EndtoolState>(-2);
constexpr EndtoolState EndtoolState_MAX = static_cast<EndtoolState>(2);
constexpr int EndtoolState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
EndtoolState_descriptor();
template <typename T>
const std::string& EndtoolState_Name(T value) {
  static_assert(std::is_same<T, EndtoolState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EndtoolState_Name().");
  return EndtoolState_Name(static_cast<EndtoolState>(value));
}
template <>
inline const std::string& EndtoolState_Name(EndtoolState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EndtoolState_descriptor,
                                                 -2, 2>(
      static_cast<int>(value));
}
inline bool EndtoolState_Parse(absl::string_view name, EndtoolState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EndtoolState>(
      EndtoolState_descriptor(), name, value);
}
enum VisionFrameType : int {
  OBJECT = 0,
  END_EFFECTOR = 1,
  VisionFrameType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VisionFrameType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VisionFrameType_IsValid(int value);
constexpr VisionFrameType VisionFrameType_MIN = static_cast<VisionFrameType>(0);
constexpr VisionFrameType VisionFrameType_MAX = static_cast<VisionFrameType>(1);
constexpr int VisionFrameType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
VisionFrameType_descriptor();
template <typename T>
const std::string& VisionFrameType_Name(T value) {
  static_assert(std::is_same<T, VisionFrameType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VisionFrameType_Name().");
  return VisionFrameType_Name(static_cast<VisionFrameType>(value));
}
template <>
inline const std::string& VisionFrameType_Name(VisionFrameType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VisionFrameType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool VisionFrameType_Parse(absl::string_view name, VisionFrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisionFrameType>(
      VisionFrameType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Motor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Motor) */ {
 public:
  inline Motor() : Motor(nullptr) {}
  ~Motor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Motor(::google::protobuf::internal::ConstantInitialized);

  Motor(const Motor& from);
  Motor(Motor&& from) noexcept
    : Motor() {
    *this = ::std::move(from);
  }

  inline Motor& operator=(const Motor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Motor& operator=(Motor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Motor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Motor* internal_default_instance() {
    return reinterpret_cast<const Motor*>(
               &_Motor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Motor& a, Motor& b) {
    a.Swap(&b);
  }
  inline void Swap(Motor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Motor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Motor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Motor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Motor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Motor& from) {
    Motor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Motor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.Motor";
  }
  protected:
  explicit Motor(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // uint32 index = 1;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Motor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t index_;
    bool enable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class Servo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Servo) */ {
 public:
  inline Servo() : Servo(nullptr) {}
  ~Servo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Servo(::google::protobuf::internal::ConstantInitialized);

  Servo(const Servo& from);
  Servo(Servo&& from) noexcept
    : Servo() {
    *this = ::std::move(from);
  }

  inline Servo& operator=(const Servo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Servo& operator=(Servo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Servo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Servo* internal_default_instance() {
    return reinterpret_cast<const Servo*>(
               &_Servo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Servo& a, Servo& b) {
    a.Swap(&b);
  }
  inline void Swap(Servo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Servo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Servo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Servo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Servo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Servo& from) {
    Servo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Servo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.Servo";
  }
  protected:
  explicit Servo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // uint32 index = 1;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Servo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t index_;
    bool enable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class GripperData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GripperData) */ {
 public:
  inline GripperData() : GripperData(nullptr) {}
  ~GripperData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GripperData(::google::protobuf::internal::ConstantInitialized);

  GripperData(const GripperData& from);
  GripperData(GripperData&& from) noexcept
    : GripperData() {
    *this = ::std::move(from);
  }

  inline GripperData& operator=(const GripperData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GripperData& operator=(GripperData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GripperData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GripperData* internal_default_instance() {
    return reinterpret_cast<const GripperData*>(
               &_GripperData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GripperData& a, GripperData& b) {
    a.Swap(&b);
  }
  inline void Swap(GripperData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GripperData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GripperData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GripperData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GripperData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GripperData& from) {
    GripperData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GripperData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.GripperData";
  }
  protected:
  explicit GripperData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGripperTypeFieldNumber = 1,
    kGripperPositionFieldNumber = 2,
    kGripperStateFieldNumber = 3,
  };
  // .Nrmk.IndyFramework.GripperType gripper_type = 1;
  void clear_gripper_type() ;
  ::Nrmk::IndyFramework::GripperType gripper_type() const;
  void set_gripper_type(::Nrmk::IndyFramework::GripperType value);

  private:
  ::Nrmk::IndyFramework::GripperType _internal_gripper_type() const;
  void _internal_set_gripper_type(::Nrmk::IndyFramework::GripperType value);

  public:
  // int32 gripper_position = 2;
  void clear_gripper_position() ;
  ::int32_t gripper_position() const;
  void set_gripper_position(::int32_t value);

  private:
  ::int32_t _internal_gripper_position() const;
  void _internal_set_gripper_position(::int32_t value);

  public:
  // int32 gripper_state = 3;
  void clear_gripper_state() ;
  ::int32_t gripper_state() const;
  void set_gripper_state(::int32_t value);

  private:
  ::int32_t _internal_gripper_state() const;
  void _internal_set_gripper_state(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GripperData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int gripper_type_;
    ::int32_t gripper_position_;
    ::int32_t gripper_state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class GripperCommand final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GripperCommand) */ {
 public:
  inline GripperCommand() : GripperCommand(nullptr) {}
  ~GripperCommand() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GripperCommand(::google::protobuf::internal::ConstantInitialized);

  GripperCommand(const GripperCommand& from);
  GripperCommand(GripperCommand&& from) noexcept
    : GripperCommand() {
    *this = ::std::move(from);
  }

  inline GripperCommand& operator=(const GripperCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GripperCommand& operator=(GripperCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GripperCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const GripperCommand* internal_default_instance() {
    return reinterpret_cast<const GripperCommand*>(
               &_GripperCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GripperCommand& a, GripperCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(GripperCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GripperCommand* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GripperCommand* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GripperCommand>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GripperCommand& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GripperCommand& from) {
    GripperCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GripperCommand* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.GripperCommand";
  }
  protected:
  explicit GripperCommand(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using GripperCommandType = GripperCommand_GripperCommandType;
  static constexpr GripperCommandType AUTO_DETECT = GripperCommand_GripperCommandType_AUTO_DETECT;
  static constexpr GripperCommandType ACTIVATE = GripperCommand_GripperCommandType_ACTIVATE;
  static constexpr GripperCommandType RE_ACTIVATE = GripperCommand_GripperCommandType_RE_ACTIVATE;
  static constexpr GripperCommandType SET_PVT = GripperCommand_GripperCommandType_SET_PVT;
  static inline bool GripperCommandType_IsValid(int value) {
    return GripperCommand_GripperCommandType_IsValid(value);
  }
  static constexpr GripperCommandType GripperCommandType_MIN = GripperCommand_GripperCommandType_GripperCommandType_MIN;
  static constexpr GripperCommandType GripperCommandType_MAX = GripperCommand_GripperCommandType_GripperCommandType_MAX;
  static constexpr int GripperCommandType_ARRAYSIZE = GripperCommand_GripperCommandType_GripperCommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GripperCommandType_descriptor() {
    return GripperCommand_GripperCommandType_descriptor();
  }
  template <typename T>
  static inline const std::string& GripperCommandType_Name(T value) {
    return GripperCommand_GripperCommandType_Name(value);
  }
  static inline bool GripperCommandType_Parse(absl::string_view name, GripperCommandType* value) {
    return GripperCommand_GripperCommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGripperPvtDataFieldNumber = 3,
    kGripperCommandFieldNumber = 1,
    kGripperTypeFieldNumber = 2,
  };
  // repeated int32 gripper_pvt_data = 3;
  int gripper_pvt_data_size() const;
  private:
  int _internal_gripper_pvt_data_size() const;

  public:
  void clear_gripper_pvt_data() ;
  ::int32_t gripper_pvt_data(int index) const;
  void set_gripper_pvt_data(int index, ::int32_t value);
  void add_gripper_pvt_data(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& gripper_pvt_data() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_gripper_pvt_data();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_gripper_pvt_data() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_gripper_pvt_data();

  public:
  // .Nrmk.IndyFramework.GripperCommand.GripperCommandType gripper_command = 1;
  void clear_gripper_command() ;
  ::Nrmk::IndyFramework::GripperCommand_GripperCommandType gripper_command() const;
  void set_gripper_command(::Nrmk::IndyFramework::GripperCommand_GripperCommandType value);

  private:
  ::Nrmk::IndyFramework::GripperCommand_GripperCommandType _internal_gripper_command() const;
  void _internal_set_gripper_command(::Nrmk::IndyFramework::GripperCommand_GripperCommandType value);

  public:
  // .Nrmk.IndyFramework.GripperType gripper_type = 2;
  void clear_gripper_type() ;
  ::Nrmk::IndyFramework::GripperType gripper_type() const;
  void set_gripper_type(::Nrmk::IndyFramework::GripperType value);

  private:
  ::Nrmk::IndyFramework::GripperType _internal_gripper_type() const;
  void _internal_set_gripper_type(::Nrmk::IndyFramework::GripperType value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GripperCommand)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::int32_t> gripper_pvt_data_;
    mutable ::google::protobuf::internal::CachedSize _gripper_pvt_data_cached_byte_size_;
    int gripper_command_;
    int gripper_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class DigitalSignal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.DigitalSignal) */ {
 public:
  inline DigitalSignal() : DigitalSignal(nullptr) {}
  ~DigitalSignal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DigitalSignal(::google::protobuf::internal::ConstantInitialized);

  DigitalSignal(const DigitalSignal& from);
  DigitalSignal(DigitalSignal&& from) noexcept
    : DigitalSignal() {
    *this = ::std::move(from);
  }

  inline DigitalSignal& operator=(const DigitalSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitalSignal& operator=(DigitalSignal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigitalSignal& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigitalSignal* internal_default_instance() {
    return reinterpret_cast<const DigitalSignal*>(
               &_DigitalSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DigitalSignal& a, DigitalSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(DigitalSignal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigitalSignal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DigitalSignal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DigitalSignal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DigitalSignal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DigitalSignal& from) {
    DigitalSignal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitalSignal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.DigitalSignal";
  }
  protected:
  explicit DigitalSignal(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // uint32 address = 1;
  void clear_address() ;
  ::uint32_t address() const;
  void set_address(::uint32_t value);

  private:
  ::uint32_t _internal_address() const;
  void _internal_set_address(::uint32_t value);

  public:
  // .Nrmk.IndyFramework.DigitalState state = 2;
  void clear_state() ;
  ::Nrmk::IndyFramework::DigitalState state() const;
  void set_state(::Nrmk::IndyFramework::DigitalState value);

  private:
  ::Nrmk::IndyFramework::DigitalState _internal_state() const;
  void _internal_set_state(::Nrmk::IndyFramework::DigitalState value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.DigitalSignal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t address_;
    int state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class EndLedDim final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.EndLedDim) */ {
 public:
  inline EndLedDim() : EndLedDim(nullptr) {}
  ~EndLedDim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EndLedDim(::google::protobuf::internal::ConstantInitialized);

  EndLedDim(const EndLedDim& from);
  EndLedDim(EndLedDim&& from) noexcept
    : EndLedDim() {
    *this = ::std::move(from);
  }

  inline EndLedDim& operator=(const EndLedDim& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndLedDim& operator=(EndLedDim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndLedDim& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndLedDim* internal_default_instance() {
    return reinterpret_cast<const EndLedDim*>(
               &_EndLedDim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EndLedDim& a, EndLedDim& b) {
    a.Swap(&b);
  }
  inline void Swap(EndLedDim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndLedDim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndLedDim* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndLedDim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndLedDim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EndLedDim& from) {
    EndLedDim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndLedDim* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.EndLedDim";
  }
  protected:
  explicit EndLedDim(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedDimFieldNumber = 1,
  };
  // uint32 led_dim = 1;
  void clear_led_dim() ;
  ::uint32_t led_dim() const;
  void set_led_dim(::uint32_t value);

  private:
  ::uint32_t _internal_led_dim() const;
  void _internal_set_led_dim(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.EndLedDim)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t led_dim_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class EndtoolSignal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.EndtoolSignal) */ {
 public:
  inline EndtoolSignal() : EndtoolSignal(nullptr) {}
  ~EndtoolSignal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EndtoolSignal(::google::protobuf::internal::ConstantInitialized);

  EndtoolSignal(const EndtoolSignal& from);
  EndtoolSignal(EndtoolSignal&& from) noexcept
    : EndtoolSignal() {
    *this = ::std::move(from);
  }

  inline EndtoolSignal& operator=(const EndtoolSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndtoolSignal& operator=(EndtoolSignal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndtoolSignal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndtoolSignal* internal_default_instance() {
    return reinterpret_cast<const EndtoolSignal*>(
               &_EndtoolSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EndtoolSignal& a, EndtoolSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(EndtoolSignal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndtoolSignal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndtoolSignal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndtoolSignal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndtoolSignal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EndtoolSignal& from) {
    EndtoolSignal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndtoolSignal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.EndtoolSignal";
  }
  protected:
  explicit EndtoolSignal(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 2,
    kPortFieldNumber = 1,
  };
  // repeated .Nrmk.IndyFramework.EndtoolState states = 2;
  int states_size() const;
  private:
  int _internal_states_size() const;

  public:
  void clear_states() ;
  public:
  ::Nrmk::IndyFramework::EndtoolState states(int index) const;
  void set_states(int index, ::Nrmk::IndyFramework::EndtoolState value);
  void add_states(::Nrmk::IndyFramework::EndtoolState value);
  const ::google::protobuf::RepeatedField<int>& states() const;
  ::google::protobuf::RepeatedField<int>* mutable_states();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_states() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_states();

  public:
  // string port = 1;
  void clear_port() ;
  const std::string& port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port(Arg_&& arg, Args_... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* ptr);

  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(
      const std::string& value);
  std::string* _internal_mutable_port();

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.EndtoolSignal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<int> states_;
    mutable ::google::protobuf::internal::CachedSize _states_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class AnalogSignal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.AnalogSignal) */ {
 public:
  inline AnalogSignal() : AnalogSignal(nullptr) {}
  ~AnalogSignal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalogSignal(::google::protobuf::internal::ConstantInitialized);

  AnalogSignal(const AnalogSignal& from);
  AnalogSignal(AnalogSignal&& from) noexcept
    : AnalogSignal() {
    *this = ::std::move(from);
  }

  inline AnalogSignal& operator=(const AnalogSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogSignal& operator=(AnalogSignal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalogSignal& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalogSignal* internal_default_instance() {
    return reinterpret_cast<const AnalogSignal*>(
               &_AnalogSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AnalogSignal& a, AnalogSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalogSignal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalogSignal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalogSignal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalogSignal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalogSignal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalogSignal& from) {
    AnalogSignal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogSignal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.AnalogSignal";
  }
  protected:
  explicit AnalogSignal(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kVoltageFieldNumber = 2,
  };
  // uint32 address = 1;
  void clear_address() ;
  ::uint32_t address() const;
  void set_address(::uint32_t value);

  private:
  ::uint32_t _internal_address() const;
  void _internal_set_address(::uint32_t value);

  public:
  // int32 voltage = 2;
  void clear_voltage() ;
  ::int32_t voltage() const;
  void set_voltage(::int32_t value);

  private:
  ::int32_t _internal_voltage() const;
  void _internal_set_voltage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.AnalogSignal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t address_;
    ::int32_t voltage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class MotorList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.MotorList) */ {
 public:
  inline MotorList() : MotorList(nullptr) {}
  ~MotorList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotorList(::google::protobuf::internal::ConstantInitialized);

  MotorList(const MotorList& from);
  MotorList(MotorList&& from) noexcept
    : MotorList() {
    *this = ::std::move(from);
  }

  inline MotorList& operator=(const MotorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorList& operator=(MotorList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorList* internal_default_instance() {
    return reinterpret_cast<const MotorList*>(
               &_MotorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MotorList& a, MotorList& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MotorList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MotorList& from) {
    MotorList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.MotorList";
  }
  protected:
  explicit MotorList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorsFieldNumber = 1,
  };
  // repeated .Nrmk.IndyFramework.Motor motors = 1;
  int motors_size() const;
  private:
  int _internal_motors_size() const;

  public:
  void clear_motors() ;
  ::Nrmk::IndyFramework::Motor* mutable_motors(int index);
  ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >*
      mutable_motors();
  private:
  const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::Motor>& _internal_motors() const;
  ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::Motor>* _internal_mutable_motors();
  public:
  const ::Nrmk::IndyFramework::Motor& motors(int index) const;
  ::Nrmk::IndyFramework::Motor* add_motors();
  const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >&
      motors() const;
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.MotorList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::Motor > motors_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class DigitalList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.DigitalList) */ {
 public:
  inline DigitalList() : DigitalList(nullptr) {}
  ~DigitalList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DigitalList(::google::protobuf::internal::ConstantInitialized);

  DigitalList(const DigitalList& from);
  DigitalList(DigitalList&& from) noexcept
    : DigitalList() {
    *this = ::std::move(from);
  }

  inline DigitalList& operator=(const DigitalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitalList& operator=(DigitalList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigitalList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigitalList* internal_default_instance() {
    return reinterpret_cast<const DigitalList*>(
               &_DigitalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DigitalList& a, DigitalList& b) {
    a.Swap(&b);
  }
  inline void Swap(DigitalList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigitalList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DigitalList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DigitalList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DigitalList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DigitalList& from) {
    DigitalList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitalList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.DigitalList";
  }
  protected:
  explicit DigitalList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 1,
  };
  // repeated .Nrmk.IndyFramework.DigitalSignal signals = 1;
  int signals_size() const;
  private:
  int _internal_signals_size() const;

  public:
  void clear_signals() ;
  ::Nrmk::IndyFramework::DigitalSignal* mutable_signals(int index);
  ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >*
      mutable_signals();
  private:
  const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::DigitalSignal>& _internal_signals() const;
  ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::DigitalSignal>* _internal_mutable_signals();
  public:
  const ::Nrmk::IndyFramework::DigitalSignal& signals(int index) const;
  ::Nrmk::IndyFramework::DigitalSignal* add_signals();
  const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >&
      signals() const;
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.DigitalList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal > signals_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class EndtoolSignalList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.EndtoolSignalList) */ {
 public:
  inline EndtoolSignalList() : EndtoolSignalList(nullptr) {}
  ~EndtoolSignalList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EndtoolSignalList(::google::protobuf::internal::ConstantInitialized);

  EndtoolSignalList(const EndtoolSignalList& from);
  EndtoolSignalList(EndtoolSignalList&& from) noexcept
    : EndtoolSignalList() {
    *this = ::std::move(from);
  }

  inline EndtoolSignalList& operator=(const EndtoolSignalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndtoolSignalList& operator=(EndtoolSignalList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndtoolSignalList& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndtoolSignalList* internal_default_instance() {
    return reinterpret_cast<const EndtoolSignalList*>(
               &_EndtoolSignalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EndtoolSignalList& a, EndtoolSignalList& b) {
    a.Swap(&b);
  }
  inline void Swap(EndtoolSignalList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndtoolSignalList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndtoolSignalList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndtoolSignalList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndtoolSignalList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EndtoolSignalList& from) {
    EndtoolSignalList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndtoolSignalList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.EndtoolSignalList";
  }
  protected:
  explicit EndtoolSignalList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 1,
  };
  // repeated .Nrmk.IndyFramework.EndtoolSignal signals = 1;
  int signals_size() const;
  private:
  int _internal_signals_size() const;

  public:
  void clear_signals() ;
  ::Nrmk::IndyFramework::EndtoolSignal* mutable_signals(int index);
  ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >*
      mutable_signals();
  private:
  const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::EndtoolSignal>& _internal_signals() const;
  ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::EndtoolSignal>* _internal_mutable_signals();
  public:
  const ::Nrmk::IndyFramework::EndtoolSignal& signals(int index) const;
  ::Nrmk::IndyFramework::EndtoolSignal* add_signals();
  const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >&
      signals() const;
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.EndtoolSignalList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal > signals_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class AnalogList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.AnalogList) */ {
 public:
  inline AnalogList() : AnalogList(nullptr) {}
  ~AnalogList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalogList(::google::protobuf::internal::ConstantInitialized);

  AnalogList(const AnalogList& from);
  AnalogList(AnalogList&& from) noexcept
    : AnalogList() {
    *this = ::std::move(from);
  }

  inline AnalogList& operator=(const AnalogList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogList& operator=(AnalogList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalogList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalogList* internal_default_instance() {
    return reinterpret_cast<const AnalogList*>(
               &_AnalogList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AnalogList& a, AnalogList& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalogList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalogList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalogList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalogList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalogList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalogList& from) {
    AnalogList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.AnalogList";
  }
  protected:
  explicit AnalogList(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 1,
  };
  // repeated .Nrmk.IndyFramework.AnalogSignal signals = 1;
  int signals_size() const;
  private:
  int _internal_signals_size() const;

  public:
  void clear_signals() ;
  ::Nrmk::IndyFramework::AnalogSignal* mutable_signals(int index);
  ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >*
      mutable_signals();
  private:
  const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::AnalogSignal>& _internal_signals() const;
  ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::AnalogSignal>* _internal_mutable_signals();
  public:
  const ::Nrmk::IndyFramework::AnalogSignal& signals(int index) const;
  ::Nrmk::IndyFramework::AnalogSignal* add_signals();
  const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >&
      signals() const;
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.AnalogList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal > signals_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class DeviceInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceInfo(::google::protobuf::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeviceInfo& from) {
    DeviceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoreBoardFwVersFieldNumber = 11,
    kRobotSerialFieldNumber = 2,
    kIoBoardFwVerFieldNumber = 10,
    kEndtoolBoardFwVerFieldNumber = 12,
    kControllerVerFieldNumber = 20,
    kControllerDetailFieldNumber = 21,
    kControllerDateFieldNumber = 22,
    kResponseFieldNumber = 100,
    kNumJointsFieldNumber = 1,
    kPayloadFieldNumber = 3,
    kTeleopLoadedFieldNumber = 30,
    kCalibratedFieldNumber = 31,
  };
  // repeated string core_board_fw_vers = 11;
  int core_board_fw_vers_size() const;
  private:
  int _internal_core_board_fw_vers_size() const;

  public:
  void clear_core_board_fw_vers() ;
  const std::string& core_board_fw_vers(int index) const;
  std::string* mutable_core_board_fw_vers(int index);
  void set_core_board_fw_vers(int index, const std::string& value);
  void set_core_board_fw_vers(int index, std::string&& value);
  void set_core_board_fw_vers(int index, const char* value);
  void set_core_board_fw_vers(int index, const char* value, std::size_t size);
  void set_core_board_fw_vers(int index, absl::string_view value);
  std::string* add_core_board_fw_vers();
  void add_core_board_fw_vers(const std::string& value);
  void add_core_board_fw_vers(std::string&& value);
  void add_core_board_fw_vers(const char* value);
  void add_core_board_fw_vers(const char* value, std::size_t size);
  void add_core_board_fw_vers(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& core_board_fw_vers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_core_board_fw_vers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_core_board_fw_vers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_core_board_fw_vers();

  public:
  // string robot_serial = 2;
  void clear_robot_serial() ;
  const std::string& robot_serial() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_robot_serial(Arg_&& arg, Args_... args);
  std::string* mutable_robot_serial();
  PROTOBUF_NODISCARD std::string* release_robot_serial();
  void set_allocated_robot_serial(std::string* ptr);

  private:
  const std::string& _internal_robot_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robot_serial(
      const std::string& value);
  std::string* _internal_mutable_robot_serial();

  public:
  // string io_board_fw_ver = 10;
  void clear_io_board_fw_ver() ;
  const std::string& io_board_fw_ver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_io_board_fw_ver(Arg_&& arg, Args_... args);
  std::string* mutable_io_board_fw_ver();
  PROTOBUF_NODISCARD std::string* release_io_board_fw_ver();
  void set_allocated_io_board_fw_ver(std::string* ptr);

  private:
  const std::string& _internal_io_board_fw_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_io_board_fw_ver(
      const std::string& value);
  std::string* _internal_mutable_io_board_fw_ver();

  public:
  // string endtool_board_fw_ver = 12;
  void clear_endtool_board_fw_ver() ;
  const std::string& endtool_board_fw_ver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endtool_board_fw_ver(Arg_&& arg, Args_... args);
  std::string* mutable_endtool_board_fw_ver();
  PROTOBUF_NODISCARD std::string* release_endtool_board_fw_ver();
  void set_allocated_endtool_board_fw_ver(std::string* ptr);

  private:
  const std::string& _internal_endtool_board_fw_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endtool_board_fw_ver(
      const std::string& value);
  std::string* _internal_mutable_endtool_board_fw_ver();

  public:
  // string controller_ver = 20;
  void clear_controller_ver() ;
  const std::string& controller_ver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_controller_ver(Arg_&& arg, Args_... args);
  std::string* mutable_controller_ver();
  PROTOBUF_NODISCARD std::string* release_controller_ver();
  void set_allocated_controller_ver(std::string* ptr);

  private:
  const std::string& _internal_controller_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_ver(
      const std::string& value);
  std::string* _internal_mutable_controller_ver();

  public:
  // string controller_detail = 21;
  void clear_controller_detail() ;
  const std::string& controller_detail() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_controller_detail(Arg_&& arg, Args_... args);
  std::string* mutable_controller_detail();
  PROTOBUF_NODISCARD std::string* release_controller_detail();
  void set_allocated_controller_detail(std::string* ptr);

  private:
  const std::string& _internal_controller_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_detail(
      const std::string& value);
  std::string* _internal_mutable_controller_detail();

  public:
  // string controller_date = 22;
  void clear_controller_date() ;
  const std::string& controller_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_controller_date(Arg_&& arg, Args_... args);
  std::string* mutable_controller_date();
  PROTOBUF_NODISCARD std::string* release_controller_date();
  void set_allocated_controller_date(std::string* ptr);

  private:
  const std::string& _internal_controller_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_date(
      const std::string& value);
  std::string* _internal_mutable_controller_date();

  public:
  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response() ;
  const ::Nrmk::IndyFramework::Response& response() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* value);
  void unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value);
  ::Nrmk::IndyFramework::Response* unsafe_arena_release_response();

  private:
  const ::Nrmk::IndyFramework::Response& _internal_response() const;
  ::Nrmk::IndyFramework::Response* _internal_mutable_response();

  public:
  // uint32 num_joints = 1;
  void clear_num_joints() ;
  ::uint32_t num_joints() const;
  void set_num_joints(::uint32_t value);

  private:
  ::uint32_t _internal_num_joints() const;
  void _internal_set_num_joints(::uint32_t value);

  public:
  // float payload = 3;
  void clear_payload() ;
  float payload() const;
  void set_payload(float value);

  private:
  float _internal_payload() const;
  void _internal_set_payload(float value);

  public:
  // bool teleop_loaded = 30;
  void clear_teleop_loaded() ;
  bool teleop_loaded() const;
  void set_teleop_loaded(bool value);

  private:
  bool _internal_teleop_loaded() const;
  void _internal_set_teleop_loaded(bool value);

  public:
  // bool calibrated = 31;
  void clear_calibrated() ;
  bool calibrated() const;
  void set_calibrated(bool value);

  private:
  bool _internal_calibrated() const;
  void _internal_set_calibrated(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.DeviceInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12, 1, 157, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> core_board_fw_vers_;
    ::google::protobuf::internal::ArenaStringPtr robot_serial_;
    ::google::protobuf::internal::ArenaStringPtr io_board_fw_ver_;
    ::google::protobuf::internal::ArenaStringPtr endtool_board_fw_ver_;
    ::google::protobuf::internal::ArenaStringPtr controller_ver_;
    ::google::protobuf::internal::ArenaStringPtr controller_detail_;
    ::google::protobuf::internal::ArenaStringPtr controller_date_;
    ::Nrmk::IndyFramework::Response* response_;
    ::uint32_t num_joints_;
    float payload_;
    bool teleop_loaded_;
    bool calibrated_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class BrakeControlStyle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.BrakeControlStyle) */ {
 public:
  inline BrakeControlStyle() : BrakeControlStyle(nullptr) {}
  ~BrakeControlStyle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BrakeControlStyle(::google::protobuf::internal::ConstantInitialized);

  BrakeControlStyle(const BrakeControlStyle& from);
  BrakeControlStyle(BrakeControlStyle&& from) noexcept
    : BrakeControlStyle() {
    *this = ::std::move(from);
  }

  inline BrakeControlStyle& operator=(const BrakeControlStyle& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrakeControlStyle& operator=(BrakeControlStyle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrakeControlStyle& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrakeControlStyle* internal_default_instance() {
    return reinterpret_cast<const BrakeControlStyle*>(
               &_BrakeControlStyle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BrakeControlStyle& a, BrakeControlStyle& b) {
    a.Swap(&b);
  }
  inline void Swap(BrakeControlStyle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrakeControlStyle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrakeControlStyle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrakeControlStyle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BrakeControlStyle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BrakeControlStyle& from) {
    BrakeControlStyle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrakeControlStyle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.BrakeControlStyle";
  }
  protected:
  explicit BrakeControlStyle(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ControlStyle = BrakeControlStyle_ControlStyle;
  static constexpr ControlStyle UNAVAILABLE = BrakeControlStyle_ControlStyle_UNAVAILABLE;
  static constexpr ControlStyle CONCURRENT = BrakeControlStyle_ControlStyle_CONCURRENT;
  static constexpr ControlStyle INDIVIDUAL = BrakeControlStyle_ControlStyle_INDIVIDUAL;
  static inline bool ControlStyle_IsValid(int value) {
    return BrakeControlStyle_ControlStyle_IsValid(value);
  }
  static constexpr ControlStyle ControlStyle_MIN = BrakeControlStyle_ControlStyle_ControlStyle_MIN;
  static constexpr ControlStyle ControlStyle_MAX = BrakeControlStyle_ControlStyle_ControlStyle_MAX;
  static constexpr int ControlStyle_ARRAYSIZE = BrakeControlStyle_ControlStyle_ControlStyle_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ControlStyle_descriptor() {
    return BrakeControlStyle_ControlStyle_descriptor();
  }
  template <typename T>
  static inline const std::string& ControlStyle_Name(T value) {
    return BrakeControlStyle_ControlStyle_Name(value);
  }
  static inline bool ControlStyle_Parse(absl::string_view name, ControlStyle* value) {
    return BrakeControlStyle_ControlStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 100,
    kStyleFieldNumber = 1,
  };
  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response() ;
  const ::Nrmk::IndyFramework::Response& response() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* value);
  void unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value);
  ::Nrmk::IndyFramework::Response* unsafe_arena_release_response();

  private:
  const ::Nrmk::IndyFramework::Response& _internal_response() const;
  ::Nrmk::IndyFramework::Response* _internal_mutable_response();

  public:
  // .Nrmk.IndyFramework.BrakeControlStyle.ControlStyle style = 1;
  void clear_style() ;
  ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle style() const;
  void set_style(::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle value);

  private:
  ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle _internal_style() const;
  void _internal_set_style(::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.BrakeControlStyle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Nrmk::IndyFramework::Response* response_;
    int style_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class GetEL5001Data final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GetEL5001Data) */ {
 public:
  inline GetEL5001Data() : GetEL5001Data(nullptr) {}
  ~GetEL5001Data() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetEL5001Data(::google::protobuf::internal::ConstantInitialized);

  GetEL5001Data(const GetEL5001Data& from);
  GetEL5001Data(GetEL5001Data&& from) noexcept
    : GetEL5001Data() {
    *this = ::std::move(from);
  }

  inline GetEL5001Data& operator=(const GetEL5001Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEL5001Data& operator=(GetEL5001Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEL5001Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEL5001Data* internal_default_instance() {
    return reinterpret_cast<const GetEL5001Data*>(
               &_GetEL5001Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetEL5001Data& a, GetEL5001Data& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEL5001Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEL5001Data* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEL5001Data* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEL5001Data>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetEL5001Data& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetEL5001Data& from) {
    GetEL5001Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEL5001Data* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.GetEL5001Data";
  }
  protected:
  explicit GetEL5001Data(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 100,
    kStatusFieldNumber = 1,
    kValueFieldNumber = 2,
    kDeltaFieldNumber = 3,
    kAverageFieldNumber = 4,
  };
  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response() ;
  const ::Nrmk::IndyFramework::Response& response() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* value);
  void unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value);
  ::Nrmk::IndyFramework::Response* unsafe_arena_release_response();

  private:
  const ::Nrmk::IndyFramework::Response& _internal_response() const;
  ::Nrmk::IndyFramework::Response* _internal_mutable_response();

  public:
  // int32 status = 1;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // int32 value = 2;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // int32 delta = 3;
  void clear_delta() ;
  ::int32_t delta() const;
  void set_delta(::int32_t value);

  private:
  ::int32_t _internal_delta() const;
  void _internal_set_delta(::int32_t value);

  public:
  // float average = 4;
  void clear_average() ;
  float average() const;
  void set_average(float value);

  private:
  float _internal_average() const;
  void _internal_set_average(float value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GetEL5001Data)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 5, 1, 0, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Nrmk::IndyFramework::Response* response_;
    ::int32_t status_;
    ::int32_t value_;
    ::int32_t delta_;
    float average_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class GetEL5101Data final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GetEL5101Data) */ {
 public:
  inline GetEL5101Data() : GetEL5101Data(nullptr) {}
  ~GetEL5101Data() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetEL5101Data(::google::protobuf::internal::ConstantInitialized);

  GetEL5101Data(const GetEL5101Data& from);
  GetEL5101Data(GetEL5101Data&& from) noexcept
    : GetEL5101Data() {
    *this = ::std::move(from);
  }

  inline GetEL5101Data& operator=(const GetEL5101Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEL5101Data& operator=(GetEL5101Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEL5101Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEL5101Data* internal_default_instance() {
    return reinterpret_cast<const GetEL5101Data*>(
               &_GetEL5101Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetEL5101Data& a, GetEL5101Data& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEL5101Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEL5101Data* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEL5101Data* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEL5101Data>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetEL5101Data& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetEL5101Data& from) {
    GetEL5101Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEL5101Data* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.GetEL5101Data";
  }
  protected:
  explicit GetEL5101Data(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 100,
    kStatusFieldNumber = 1,
    kValueFieldNumber = 2,
    kLatchFieldNumber = 3,
    kDeltaFieldNumber = 4,
    kAverageFieldNumber = 5,
  };
  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response() ;
  const ::Nrmk::IndyFramework::Response& response() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* value);
  void unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value);
  ::Nrmk::IndyFramework::Response* unsafe_arena_release_response();

  private:
  const ::Nrmk::IndyFramework::Response& _internal_response() const;
  ::Nrmk::IndyFramework::Response* _internal_mutable_response();

  public:
  // int32 status = 1;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // int32 value = 2;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // int32 latch = 3;
  void clear_latch() ;
  ::int32_t latch() const;
  void set_latch(::int32_t value);

  private:
  ::int32_t _internal_latch() const;
  void _internal_set_latch(::int32_t value);

  public:
  // int32 delta = 4;
  void clear_delta() ;
  ::int32_t delta() const;
  void set_delta(::int32_t value);

  private:
  ::int32_t _internal_delta() const;
  void _internal_set_delta(::int32_t value);

  public:
  // float average = 5;
  void clear_average() ;
  float average() const;
  void set_average(float value);

  private:
  float _internal_average() const;
  void _internal_set_average(float value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GetEL5101Data)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 0, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Nrmk::IndyFramework::Response* response_;
    ::int32_t status_;
    ::int32_t value_;
    ::int32_t latch_;
    ::int32_t delta_;
    float average_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class FTSensorData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.FTSensorData) */ {
 public:
  inline FTSensorData() : FTSensorData(nullptr) {}
  ~FTSensorData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FTSensorData(::google::protobuf::internal::ConstantInitialized);

  FTSensorData(const FTSensorData& from);
  FTSensorData(FTSensorData&& from) noexcept
    : FTSensorData() {
    *this = ::std::move(from);
  }

  inline FTSensorData& operator=(const FTSensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FTSensorData& operator=(FTSensorData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FTSensorData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FTSensorData* internal_default_instance() {
    return reinterpret_cast<const FTSensorData*>(
               &_FTSensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FTSensorData& a, FTSensorData& b) {
    a.Swap(&b);
  }
  inline void Swap(FTSensorData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FTSensorData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FTSensorData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FTSensorData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FTSensorData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FTSensorData& from) {
    FTSensorData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FTSensorData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.FTSensorData";
  }
  protected:
  explicit FTSensorData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 100,
    kFtFxFieldNumber = 1,
    kFtFyFieldNumber = 2,
    kFtFzFieldNumber = 3,
    kFtTxFieldNumber = 4,
    kFtTyFieldNumber = 5,
    kFtTzFieldNumber = 6,
  };
  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response() ;
  const ::Nrmk::IndyFramework::Response& response() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* value);
  void unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value);
  ::Nrmk::IndyFramework::Response* unsafe_arena_release_response();

  private:
  const ::Nrmk::IndyFramework::Response& _internal_response() const;
  ::Nrmk::IndyFramework::Response* _internal_mutable_response();

  public:
  // float ft_Fx = 1;
  void clear_ft_fx() ;
  float ft_fx() const;
  void set_ft_fx(float value);

  private:
  float _internal_ft_fx() const;
  void _internal_set_ft_fx(float value);

  public:
  // float ft_Fy = 2;
  void clear_ft_fy() ;
  float ft_fy() const;
  void set_ft_fy(float value);

  private:
  float _internal_ft_fy() const;
  void _internal_set_ft_fy(float value);

  public:
  // float ft_Fz = 3;
  void clear_ft_fz() ;
  float ft_fz() const;
  void set_ft_fz(float value);

  private:
  float _internal_ft_fz() const;
  void _internal_set_ft_fz(float value);

  public:
  // float ft_Tx = 4;
  void clear_ft_tx() ;
  float ft_tx() const;
  void set_ft_tx(float value);

  private:
  float _internal_ft_tx() const;
  void _internal_set_ft_tx(float value);

  public:
  // float ft_Ty = 5;
  void clear_ft_ty() ;
  float ft_ty() const;
  void set_ft_ty(float value);

  private:
  float _internal_ft_ty() const;
  void _internal_set_ft_ty(float value);

  public:
  // float ft_Tz = 6;
  void clear_ft_tz() ;
  float ft_tz() const;
  void set_ft_tz(float value);

  private:
  float _internal_ft_tz() const;
  void _internal_set_ft_tz(float value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.FTSensorData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 1, 0, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Nrmk::IndyFramework::Response* response_;
    float ft_fx_;
    float ft_fy_;
    float ft_fz_;
    float ft_tx_;
    float ft_ty_;
    float ft_tz_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class GetLoadFactorsRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GetLoadFactorsRes) */ {
 public:
  inline GetLoadFactorsRes() : GetLoadFactorsRes(nullptr) {}
  ~GetLoadFactorsRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetLoadFactorsRes(::google::protobuf::internal::ConstantInitialized);

  GetLoadFactorsRes(const GetLoadFactorsRes& from);
  GetLoadFactorsRes(GetLoadFactorsRes&& from) noexcept
    : GetLoadFactorsRes() {
    *this = ::std::move(from);
  }

  inline GetLoadFactorsRes& operator=(const GetLoadFactorsRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLoadFactorsRes& operator=(GetLoadFactorsRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLoadFactorsRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLoadFactorsRes* internal_default_instance() {
    return reinterpret_cast<const GetLoadFactorsRes*>(
               &_GetLoadFactorsRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetLoadFactorsRes& a, GetLoadFactorsRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLoadFactorsRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLoadFactorsRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLoadFactorsRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLoadFactorsRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetLoadFactorsRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetLoadFactorsRes& from) {
    GetLoadFactorsRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLoadFactorsRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.GetLoadFactorsRes";
  }
  protected:
  explicit GetLoadFactorsRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentsFieldNumber = 1,
    kTorquesFieldNumber = 2,
    kResponseFieldNumber = 100,
  };
  // repeated int32 percents = 1;
  int percents_size() const;
  private:
  int _internal_percents_size() const;

  public:
  void clear_percents() ;
  ::int32_t percents(int index) const;
  void set_percents(int index, ::int32_t value);
  void add_percents(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& percents() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_percents();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_percents() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_percents();

  public:
  // repeated float torques = 2;
  int torques_size() const;
  private:
  int _internal_torques_size() const;

  public:
  void clear_torques() ;
  float torques(int index) const;
  void set_torques(int index, float value);
  void add_torques(float value);
  const ::google::protobuf::RepeatedField<float>& torques() const;
  ::google::protobuf::RepeatedField<float>* mutable_torques();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_torques() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_torques();

  public:
  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response() ;
  const ::Nrmk::IndyFramework::Response& response() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* value);
  void unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value);
  ::Nrmk::IndyFramework::Response* unsafe_arena_release_response();

  private:
  const ::Nrmk::IndyFramework::Response& _internal_response() const;
  ::Nrmk::IndyFramework::Response* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GetLoadFactorsRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 0, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> percents_;
    mutable ::google::protobuf::internal::CachedSize _percents_cached_byte_size_;
    ::google::protobuf::RepeatedField<float> torques_;
    ::Nrmk::IndyFramework::Response* response_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class SetAutoModeReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SetAutoModeReq) */ {
 public:
  inline SetAutoModeReq() : SetAutoModeReq(nullptr) {}
  ~SetAutoModeReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetAutoModeReq(::google::protobuf::internal::ConstantInitialized);

  SetAutoModeReq(const SetAutoModeReq& from);
  SetAutoModeReq(SetAutoModeReq&& from) noexcept
    : SetAutoModeReq() {
    *this = ::std::move(from);
  }

  inline SetAutoModeReq& operator=(const SetAutoModeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAutoModeReq& operator=(SetAutoModeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAutoModeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAutoModeReq* internal_default_instance() {
    return reinterpret_cast<const SetAutoModeReq*>(
               &_SetAutoModeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetAutoModeReq& a, SetAutoModeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAutoModeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAutoModeReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAutoModeReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAutoModeReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetAutoModeReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetAutoModeReq& from) {
    SetAutoModeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAutoModeReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.SetAutoModeReq";
  }
  protected:
  explicit SetAutoModeReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnFieldNumber = 1,
  };
  // bool on = 1;
  void clear_on() ;
  bool on() const;
  void set_on(bool value);

  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SetAutoModeReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool on_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class SetAutoModeRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SetAutoModeRes) */ {
 public:
  inline SetAutoModeRes() : SetAutoModeRes(nullptr) {}
  ~SetAutoModeRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetAutoModeRes(::google::protobuf::internal::ConstantInitialized);

  SetAutoModeRes(const SetAutoModeRes& from);
  SetAutoModeRes(SetAutoModeRes&& from) noexcept
    : SetAutoModeRes() {
    *this = ::std::move(from);
  }

  inline SetAutoModeRes& operator=(const SetAutoModeRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAutoModeRes& operator=(SetAutoModeRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAutoModeRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAutoModeRes* internal_default_instance() {
    return reinterpret_cast<const SetAutoModeRes*>(
               &_SetAutoModeRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SetAutoModeRes& a, SetAutoModeRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAutoModeRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAutoModeRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAutoModeRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAutoModeRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetAutoModeRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetAutoModeRes& from) {
    SetAutoModeRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAutoModeRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.SetAutoModeRes";
  }
  protected:
  explicit SetAutoModeRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 100,
  };
  // string msg = 100;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SetAutoModeRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 45, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr msg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class CheckAutoModeRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.CheckAutoModeRes) */ {
 public:
  inline CheckAutoModeRes() : CheckAutoModeRes(nullptr) {}
  ~CheckAutoModeRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckAutoModeRes(::google::protobuf::internal::ConstantInitialized);

  CheckAutoModeRes(const CheckAutoModeRes& from);
  CheckAutoModeRes(CheckAutoModeRes&& from) noexcept
    : CheckAutoModeRes() {
    *this = ::std::move(from);
  }

  inline CheckAutoModeRes& operator=(const CheckAutoModeRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAutoModeRes& operator=(CheckAutoModeRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckAutoModeRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckAutoModeRes* internal_default_instance() {
    return reinterpret_cast<const CheckAutoModeRes*>(
               &_CheckAutoModeRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CheckAutoModeRes& a, CheckAutoModeRes& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckAutoModeRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckAutoModeRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckAutoModeRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckAutoModeRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckAutoModeRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckAutoModeRes& from) {
    CheckAutoModeRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckAutoModeRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.CheckAutoModeRes";
  }
  protected:
  explicit CheckAutoModeRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 100,
    kOnFieldNumber = 1,
  };
  // string msg = 100;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // bool on = 1;
  void clear_on() ;
  bool on() const;
  void set_on(bool value);

  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.CheckAutoModeRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 47, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr msg_;
    bool on_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class CheckReducedModeRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.CheckReducedModeRes) */ {
 public:
  inline CheckReducedModeRes() : CheckReducedModeRes(nullptr) {}
  ~CheckReducedModeRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckReducedModeRes(::google::protobuf::internal::ConstantInitialized);

  CheckReducedModeRes(const CheckReducedModeRes& from);
  CheckReducedModeRes(CheckReducedModeRes&& from) noexcept
    : CheckReducedModeRes() {
    *this = ::std::move(from);
  }

  inline CheckReducedModeRes& operator=(const CheckReducedModeRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckReducedModeRes& operator=(CheckReducedModeRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckReducedModeRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckReducedModeRes* internal_default_instance() {
    return reinterpret_cast<const CheckReducedModeRes*>(
               &_CheckReducedModeRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CheckReducedModeRes& a, CheckReducedModeRes& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckReducedModeRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckReducedModeRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckReducedModeRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckReducedModeRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckReducedModeRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckReducedModeRes& from) {
    CheckReducedModeRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckReducedModeRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.CheckReducedModeRes";
  }
  protected:
  explicit CheckReducedModeRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 100,
    kOnFieldNumber = 1,
  };
  // string msg = 100;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // bool on = 1;
  void clear_on() ;
  bool on() const;
  void set_on(bool value);

  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.CheckReducedModeRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 50, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr msg_;
    bool on_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class SafetyFunctionState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SafetyFunctionState) */ {
 public:
  inline SafetyFunctionState() : SafetyFunctionState(nullptr) {}
  ~SafetyFunctionState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SafetyFunctionState(::google::protobuf::internal::ConstantInitialized);

  SafetyFunctionState(const SafetyFunctionState& from);
  SafetyFunctionState(SafetyFunctionState&& from) noexcept
    : SafetyFunctionState() {
    *this = ::std::move(from);
  }

  inline SafetyFunctionState& operator=(const SafetyFunctionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafetyFunctionState& operator=(SafetyFunctionState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SafetyFunctionState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafetyFunctionState* internal_default_instance() {
    return reinterpret_cast<const SafetyFunctionState*>(
               &_SafetyFunctionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SafetyFunctionState& a, SafetyFunctionState& b) {
    a.Swap(&b);
  }
  inline void Swap(SafetyFunctionState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafetyFunctionState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafetyFunctionState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafetyFunctionState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SafetyFunctionState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SafetyFunctionState& from) {
    SafetyFunctionState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafetyFunctionState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.SafetyFunctionState";
  }
  protected:
  explicit SafetyFunctionState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 100,
    kIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response() ;
  const ::Nrmk::IndyFramework::Response& response() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* value);
  void unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value);
  ::Nrmk::IndyFramework::Response* unsafe_arena_release_response();

  private:
  const ::Nrmk::IndyFramework::Response& _internal_response() const;
  ::Nrmk::IndyFramework::Response* _internal_mutable_response();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // uint32 state = 2;
  void clear_state() ;
  ::uint32_t state() const;
  void set_state(::uint32_t value);

  private:
  ::uint32_t _internal_state() const;
  void _internal_set_state(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SafetyFunctionState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 0, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Nrmk::IndyFramework::Response* response_;
    ::uint32_t id_;
    ::uint32_t state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class SafetyControlData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SafetyControlData) */ {
 public:
  inline SafetyControlData() : SafetyControlData(nullptr) {}
  ~SafetyControlData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SafetyControlData(::google::protobuf::internal::ConstantInitialized);

  SafetyControlData(const SafetyControlData& from);
  SafetyControlData(SafetyControlData&& from) noexcept
    : SafetyControlData() {
    *this = ::std::move(from);
  }

  inline SafetyControlData& operator=(const SafetyControlData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafetyControlData& operator=(SafetyControlData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SafetyControlData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafetyControlData* internal_default_instance() {
    return reinterpret_cast<const SafetyControlData*>(
               &_SafetyControlData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SafetyControlData& a, SafetyControlData& b) {
    a.Swap(&b);
  }
  inline void Swap(SafetyControlData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafetyControlData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafetyControlData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafetyControlData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SafetyControlData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SafetyControlData& from) {
    SafetyControlData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafetyControlData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.SafetyControlData";
  }
  protected:
  explicit SafetyControlData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSafetyStateFieldNumber = 5,
    kAutoModeFieldNumber = 1,
    kReducedModeFieldNumber = 2,
    kEnablerPressedFieldNumber = 3,
  };
  // .Nrmk.IndyFramework.SafetyFunctionState safety_state = 5;
  bool has_safety_state() const;
  void clear_safety_state() ;
  const ::Nrmk::IndyFramework::SafetyFunctionState& safety_state() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::SafetyFunctionState* release_safety_state();
  ::Nrmk::IndyFramework::SafetyFunctionState* mutable_safety_state();
  void set_allocated_safety_state(::Nrmk::IndyFramework::SafetyFunctionState* value);
  void unsafe_arena_set_allocated_safety_state(::Nrmk::IndyFramework::SafetyFunctionState* value);
  ::Nrmk::IndyFramework::SafetyFunctionState* unsafe_arena_release_safety_state();

  private:
  const ::Nrmk::IndyFramework::SafetyFunctionState& _internal_safety_state() const;
  ::Nrmk::IndyFramework::SafetyFunctionState* _internal_mutable_safety_state();

  public:
  // bool auto_mode = 1;
  void clear_auto_mode() ;
  bool auto_mode() const;
  void set_auto_mode(bool value);

  private:
  bool _internal_auto_mode() const;
  void _internal_set_auto_mode(bool value);

  public:
  // bool reduced_mode = 2;
  void clear_reduced_mode() ;
  bool reduced_mode() const;
  void set_reduced_mode(bool value);

  private:
  bool _internal_reduced_mode() const;
  void _internal_set_reduced_mode(bool value);

  public:
  // bool enabler_pressed = 3;
  void clear_enabler_pressed() ;
  bool enabler_pressed() const;
  void set_enabler_pressed(bool value);

  private:
  bool _internal_enabler_pressed() const;
  void _internal_set_enabler_pressed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SafetyControlData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Nrmk::IndyFramework::SafetyFunctionState* safety_state_;
    bool auto_mode_;
    bool reduced_mode_;
    bool enabler_pressed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class SanderCommand final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SanderCommand) */ {
 public:
  inline SanderCommand() : SanderCommand(nullptr) {}
  ~SanderCommand() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SanderCommand(::google::protobuf::internal::ConstantInitialized);

  SanderCommand(const SanderCommand& from);
  SanderCommand(SanderCommand&& from) noexcept
    : SanderCommand() {
    *this = ::std::move(from);
  }

  inline SanderCommand& operator=(const SanderCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SanderCommand& operator=(SanderCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SanderCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SanderCommand* internal_default_instance() {
    return reinterpret_cast<const SanderCommand*>(
               &_SanderCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SanderCommand& a, SanderCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SanderCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SanderCommand* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SanderCommand* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SanderCommand>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SanderCommand& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SanderCommand& from) {
    SanderCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SanderCommand* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.SanderCommand";
  }
  protected:
  explicit SanderCommand(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SanderType = SanderCommand_SanderType;
  static constexpr SanderType SANDER_ONROBOT = SanderCommand_SanderType_SANDER_ONROBOT;
  static inline bool SanderType_IsValid(int value) {
    return SanderCommand_SanderType_IsValid(value);
  }
  static constexpr SanderType SanderType_MIN = SanderCommand_SanderType_SanderType_MIN;
  static constexpr SanderType SanderType_MAX = SanderCommand_SanderType_SanderType_MAX;
  static constexpr int SanderType_ARRAYSIZE = SanderCommand_SanderType_SanderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SanderType_descriptor() {
    return SanderCommand_SanderType_descriptor();
  }
  template <typename T>
  static inline const std::string& SanderType_Name(T value) {
    return SanderCommand_SanderType_Name(value);
  }
  static inline bool SanderType_Parse(absl::string_view name, SanderType* value) {
    return SanderCommand_SanderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 2,
    kTypeFieldNumber = 1,
    kSpeedFieldNumber = 3,
    kStateFieldNumber = 10,
  };
  // string ip = 2;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // .Nrmk.IndyFramework.SanderCommand.SanderType type = 1;
  void clear_type() ;
  ::Nrmk::IndyFramework::SanderCommand_SanderType type() const;
  void set_type(::Nrmk::IndyFramework::SanderCommand_SanderType value);

  private:
  ::Nrmk::IndyFramework::SanderCommand_SanderType _internal_type() const;
  void _internal_set_type(::Nrmk::IndyFramework::SanderCommand_SanderType value);

  public:
  // float speed = 3;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  // bool state = 10;
  void clear_state() ;
  bool state() const;
  void set_state(bool value);

  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SanderCommand)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 43, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr ip_;
    int type_;
    float speed_;
    bool state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class Encoder final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Encoder) */ {
 public:
  inline Encoder() : Encoder(nullptr) {}
  ~Encoder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Encoder(::google::protobuf::internal::ConstantInitialized);

  Encoder(const Encoder& from);
  Encoder(Encoder&& from) noexcept
    : Encoder() {
    *this = ::std::move(from);
  }

  inline Encoder& operator=(const Encoder& from) {
    CopyFrom(from);
    return *this;
  }
  inline Encoder& operator=(Encoder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Encoder& default_instance() {
    return *internal_default_instance();
  }
  static inline const Encoder* internal_default_instance() {
    return reinterpret_cast<const Encoder*>(
               &_Encoder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Encoder& a, Encoder& b) {
    a.Swap(&b);
  }
  inline void Swap(Encoder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Encoder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Encoder* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Encoder>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Encoder& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Encoder& from) {
    Encoder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Encoder* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.Encoder";
  }
  protected:
  explicit Encoder(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using EncoderType = Encoder_EncoderType;
  static constexpr EncoderType CONSTANT = Encoder_EncoderType_CONSTANT;
  static constexpr EncoderType QUADRATURE = Encoder_EncoderType_QUADRATURE;
  static constexpr EncoderType RISING = Encoder_EncoderType_RISING;
  static constexpr EncoderType FALLING = Encoder_EncoderType_FALLING;
  static constexpr EncoderType MODBUS = Encoder_EncoderType_MODBUS;
  static inline bool EncoderType_IsValid(int value) {
    return Encoder_EncoderType_IsValid(value);
  }
  static constexpr EncoderType EncoderType_MIN = Encoder_EncoderType_EncoderType_MIN;
  static constexpr EncoderType EncoderType_MAX = Encoder_EncoderType_EncoderType_MAX;
  static constexpr int EncoderType_ARRAYSIZE = Encoder_EncoderType_EncoderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EncoderType_descriptor() {
    return Encoder_EncoderType_descriptor();
  }
  template <typename T>
  static inline const std::string& EncoderType_Name(T value) {
    return Encoder_EncoderType_Name(value);
  }
  static inline bool EncoderType_Parse(absl::string_view name, EncoderType* value) {
    return Encoder_EncoderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChannel1FieldNumber = 2,
    kChannel2FieldNumber = 3,
    kTypeFieldNumber = 1,
    kMmPerTickFieldNumber = 5,
    kSampleNumFieldNumber = 4,
    kVelConstMmpsFieldNumber = 6,
    kReversedFieldNumber = 7,
  };
  // int64 channel1 = 2;
  void clear_channel1() ;
  ::int64_t channel1() const;
  void set_channel1(::int64_t value);

  private:
  ::int64_t _internal_channel1() const;
  void _internal_set_channel1(::int64_t value);

  public:
  // int64 channel2 = 3;
  void clear_channel2() ;
  ::int64_t channel2() const;
  void set_channel2(::int64_t value);

  private:
  ::int64_t _internal_channel2() const;
  void _internal_set_channel2(::int64_t value);

  public:
  // .Nrmk.IndyFramework.Encoder.EncoderType type = 1;
  void clear_type() ;
  ::Nrmk::IndyFramework::Encoder_EncoderType type() const;
  void set_type(::Nrmk::IndyFramework::Encoder_EncoderType value);

  private:
  ::Nrmk::IndyFramework::Encoder_EncoderType _internal_type() const;
  void _internal_set_type(::Nrmk::IndyFramework::Encoder_EncoderType value);

  public:
  // float mm_per_tick = 5;
  void clear_mm_per_tick() ;
  float mm_per_tick() const;
  void set_mm_per_tick(float value);

  private:
  float _internal_mm_per_tick() const;
  void _internal_set_mm_per_tick(float value);

  public:
  // int64 sample_num = 4;
  void clear_sample_num() ;
  ::int64_t sample_num() const;
  void set_sample_num(::int64_t value);

  private:
  ::int64_t _internal_sample_num() const;
  void _internal_set_sample_num(::int64_t value);

  public:
  // float vel_const_mmps = 6;
  void clear_vel_const_mmps() ;
  float vel_const_mmps() const;
  void set_vel_const_mmps(float value);

  private:
  float _internal_vel_const_mmps() const;
  void _internal_set_vel_const_mmps(float value);

  public:
  // bool reversed = 7;
  void clear_reversed() ;
  bool reversed() const;
  void set_reversed(bool value);

  private:
  bool _internal_reversed() const;
  void _internal_set_reversed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Encoder)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t channel1_;
    ::int64_t channel2_;
    int type_;
    float mm_per_tick_;
    ::int64_t sample_num_;
    float vel_const_mmps_;
    bool reversed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class Trigger final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Trigger) */ {
 public:
  inline Trigger() : Trigger(nullptr) {}
  ~Trigger() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Trigger(::google::protobuf::internal::ConstantInitialized);

  Trigger(const Trigger& from);
  Trigger(Trigger&& from) noexcept
    : Trigger() {
    *this = ::std::move(from);
  }

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trigger& operator=(Trigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trigger* internal_default_instance() {
    return reinterpret_cast<const Trigger*>(
               &_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Trigger& a, Trigger& b) {
    a.Swap(&b);
  }
  inline void Swap(Trigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trigger* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trigger* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trigger>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Trigger& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Trigger& from) {
    Trigger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trigger* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.Trigger";
  }
  protected:
  explicit Trigger(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TriggerType = Trigger_TriggerType;
  static constexpr TriggerType DIGITAL = Trigger_TriggerType_DIGITAL;
  static constexpr TriggerType MODBUS = Trigger_TriggerType_MODBUS;
  static inline bool TriggerType_IsValid(int value) {
    return Trigger_TriggerType_IsValid(value);
  }
  static constexpr TriggerType TriggerType_MIN = Trigger_TriggerType_TriggerType_MIN;
  static constexpr TriggerType TriggerType_MAX = Trigger_TriggerType_TriggerType_MAX;
  static constexpr int TriggerType_ARRAYSIZE = Trigger_TriggerType_TriggerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TriggerType_descriptor() {
    return Trigger_TriggerType_descriptor();
  }
  template <typename T>
  static inline const std::string& TriggerType_Name(T value) {
    return Trigger_TriggerType_Name(value);
  }
  static inline bool TriggerType_Parse(absl::string_view name, TriggerType* value) {
    return Trigger_TriggerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 2,
    kTypeFieldNumber = 1,
    kDetectRiseFieldNumber = 3,
  };
  // int64 channel = 2;
  void clear_channel() ;
  ::int64_t channel() const;
  void set_channel(::int64_t value);

  private:
  ::int64_t _internal_channel() const;
  void _internal_set_channel(::int64_t value);

  public:
  // .Nrmk.IndyFramework.Trigger.TriggerType type = 1;
  void clear_type() ;
  ::Nrmk::IndyFramework::Trigger_TriggerType type() const;
  void set_type(::Nrmk::IndyFramework::Trigger_TriggerType value);

  private:
  ::Nrmk::IndyFramework::Trigger_TriggerType _internal_type() const;
  void _internal_set_type(::Nrmk::IndyFramework::Trigger_TriggerType value);

  public:
  // bool detect_rise = 3;
  void clear_detect_rise() ;
  bool detect_rise() const;
  void set_detect_rise(bool value);

  private:
  bool _internal_detect_rise() const;
  void _internal_set_detect_rise(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Trigger)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t channel_;
    int type_;
    bool detect_rise_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class Conveyor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Conveyor) */ {
 public:
  inline Conveyor() : Conveyor(nullptr) {}
  ~Conveyor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Conveyor(::google::protobuf::internal::ConstantInitialized);

  Conveyor(const Conveyor& from);
  Conveyor(Conveyor&& from) noexcept
    : Conveyor() {
    *this = ::std::move(from);
  }

  inline Conveyor& operator=(const Conveyor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Conveyor& operator=(Conveyor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Conveyor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Conveyor* internal_default_instance() {
    return reinterpret_cast<const Conveyor*>(
               &_Conveyor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Conveyor& a, Conveyor& b) {
    a.Swap(&b);
  }
  inline void Swap(Conveyor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Conveyor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Conveyor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Conveyor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Conveyor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Conveyor& from) {
    Conveyor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Conveyor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.Conveyor";
  }
  protected:
  explicit Conveyor(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEncoderFieldNumber = 2,
    kTriggerFieldNumber = 3,
    kDirectionFieldNumber = 6,
    kStartingPoseFieldNumber = 10,
    kTerminalPoseFieldNumber = 11,
    kOffsetDistFieldNumber = 4,
    kWorkingDistFieldNumber = 5,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .Nrmk.IndyFramework.Encoder encoder = 2;
  bool has_encoder() const;
  void clear_encoder() ;
  const ::Nrmk::IndyFramework::Encoder& encoder() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Encoder* release_encoder();
  ::Nrmk::IndyFramework::Encoder* mutable_encoder();
  void set_allocated_encoder(::Nrmk::IndyFramework::Encoder* value);
  void unsafe_arena_set_allocated_encoder(::Nrmk::IndyFramework::Encoder* value);
  ::Nrmk::IndyFramework::Encoder* unsafe_arena_release_encoder();

  private:
  const ::Nrmk::IndyFramework::Encoder& _internal_encoder() const;
  ::Nrmk::IndyFramework::Encoder* _internal_mutable_encoder();

  public:
  // .Nrmk.IndyFramework.Trigger trigger = 3;
  bool has_trigger() const;
  void clear_trigger() ;
  const ::Nrmk::IndyFramework::Trigger& trigger() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Trigger* release_trigger();
  ::Nrmk::IndyFramework::Trigger* mutable_trigger();
  void set_allocated_trigger(::Nrmk::IndyFramework::Trigger* value);
  void unsafe_arena_set_allocated_trigger(::Nrmk::IndyFramework::Trigger* value);
  ::Nrmk::IndyFramework::Trigger* unsafe_arena_release_trigger();

  private:
  const ::Nrmk::IndyFramework::Trigger& _internal_trigger() const;
  ::Nrmk::IndyFramework::Trigger* _internal_mutable_trigger();

  public:
  // .Nrmk.IndyFramework.Vector direction = 6;
  bool has_direction() const;
  void clear_direction() ;
  const ::Nrmk::IndyFramework::Vector& direction() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::Vector* release_direction();
  ::Nrmk::IndyFramework::Vector* mutable_direction();
  void set_allocated_direction(::Nrmk::IndyFramework::Vector* value);
  void unsafe_arena_set_allocated_direction(::Nrmk::IndyFramework::Vector* value);
  ::Nrmk::IndyFramework::Vector* unsafe_arena_release_direction();

  private:
  const ::Nrmk::IndyFramework::Vector& _internal_direction() const;
  ::Nrmk::IndyFramework::Vector* _internal_mutable_direction();

  public:
  // .Nrmk.IndyFramework.PosePair starting_pose = 10;
  bool has_starting_pose() const;
  void clear_starting_pose() ;
  const ::Nrmk::IndyFramework::PosePair& starting_pose() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::PosePair* release_starting_pose();
  ::Nrmk::IndyFramework::PosePair* mutable_starting_pose();
  void set_allocated_starting_pose(::Nrmk::IndyFramework::PosePair* value);
  void unsafe_arena_set_allocated_starting_pose(::Nrmk::IndyFramework::PosePair* value);
  ::Nrmk::IndyFramework::PosePair* unsafe_arena_release_starting_pose();

  private:
  const ::Nrmk::IndyFramework::PosePair& _internal_starting_pose() const;
  ::Nrmk::IndyFramework::PosePair* _internal_mutable_starting_pose();

  public:
  // .Nrmk.IndyFramework.PosePair terminal_pose = 11;
  bool has_terminal_pose() const;
  void clear_terminal_pose() ;
  const ::Nrmk::IndyFramework::PosePair& terminal_pose() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::PosePair* release_terminal_pose();
  ::Nrmk::IndyFramework::PosePair* mutable_terminal_pose();
  void set_allocated_terminal_pose(::Nrmk::IndyFramework::PosePair* value);
  void unsafe_arena_set_allocated_terminal_pose(::Nrmk::IndyFramework::PosePair* value);
  ::Nrmk::IndyFramework::PosePair* unsafe_arena_release_terminal_pose();

  private:
  const ::Nrmk::IndyFramework::PosePair& _internal_terminal_pose() const;
  ::Nrmk::IndyFramework::PosePair* _internal_mutable_terminal_pose();

  public:
  // float offset_dist = 4;
  void clear_offset_dist() ;
  float offset_dist() const;
  void set_offset_dist(float value);

  private:
  float _internal_offset_dist() const;
  void _internal_set_offset_dist(float value);

  public:
  // float working_dist = 5;
  void clear_working_dist() ;
  float working_dist() const;
  void set_working_dist(float value);

  private:
  float _internal_working_dist() const;
  void _internal_set_working_dist(float value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Conveyor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 8, 5, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::Nrmk::IndyFramework::Encoder* encoder_;
    ::Nrmk::IndyFramework::Trigger* trigger_;
    ::Nrmk::IndyFramework::Vector* direction_;
    ::Nrmk::IndyFramework::PosePair* starting_pose_;
    ::Nrmk::IndyFramework::PosePair* terminal_pose_;
    float offset_dist_;
    float working_dist_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class ConveyorState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.ConveyorState) */ {
 public:
  inline ConveyorState() : ConveyorState(nullptr) {}
  ~ConveyorState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConveyorState(::google::protobuf::internal::ConstantInitialized);

  ConveyorState(const ConveyorState& from);
  ConveyorState(ConveyorState&& from) noexcept
    : ConveyorState() {
    *this = ::std::move(from);
  }

  inline ConveyorState& operator=(const ConveyorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConveyorState& operator=(ConveyorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConveyorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConveyorState* internal_default_instance() {
    return reinterpret_cast<const ConveyorState*>(
               &_ConveyorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ConveyorState& a, ConveyorState& b) {
    a.Swap(&b);
  }
  inline void Swap(ConveyorState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConveyorState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConveyorState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConveyorState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConveyorState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConveyorState& from) {
    ConveyorState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConveyorState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.ConveyorState";
  }
  protected:
  explicit ConveyorState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVelocityFieldNumber = 1,
    kTriggeredFieldNumber = 2,
  };
  // float velocity = 1;
  void clear_velocity() ;
  float velocity() const;
  void set_velocity(float value);

  private:
  float _internal_velocity() const;
  void _internal_set_velocity(float value);

  public:
  // float triggered = 2;
  void clear_triggered() ;
  float triggered() const;
  void set_triggered(float value);

  private:
  float _internal_triggered() const;
  void _internal_set_triggered(float value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.ConveyorState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float velocity_;
    float triggered_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class AddPhotoneoCalibPointReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.AddPhotoneoCalibPointReq) */ {
 public:
  inline AddPhotoneoCalibPointReq() : AddPhotoneoCalibPointReq(nullptr) {}
  ~AddPhotoneoCalibPointReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddPhotoneoCalibPointReq(::google::protobuf::internal::ConstantInitialized);

  AddPhotoneoCalibPointReq(const AddPhotoneoCalibPointReq& from);
  AddPhotoneoCalibPointReq(AddPhotoneoCalibPointReq&& from) noexcept
    : AddPhotoneoCalibPointReq() {
    *this = ::std::move(from);
  }

  inline AddPhotoneoCalibPointReq& operator=(const AddPhotoneoCalibPointReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPhotoneoCalibPointReq& operator=(AddPhotoneoCalibPointReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPhotoneoCalibPointReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPhotoneoCalibPointReq* internal_default_instance() {
    return reinterpret_cast<const AddPhotoneoCalibPointReq*>(
               &_AddPhotoneoCalibPointReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AddPhotoneoCalibPointReq& a, AddPhotoneoCalibPointReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPhotoneoCalibPointReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPhotoneoCalibPointReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPhotoneoCalibPointReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPhotoneoCalibPointReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddPhotoneoCalibPointReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddPhotoneoCalibPointReq& from) {
    AddPhotoneoCalibPointReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPhotoneoCalibPointReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.AddPhotoneoCalibPointReq";
  }
  protected:
  explicit AddPhotoneoCalibPointReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisionNameFieldNumber = 1,
    kPxFieldNumber = 2,
    kPyFieldNumber = 3,
    kPzFieldNumber = 4,
  };
  // string vision_name = 1;
  void clear_vision_name() ;
  const std::string& vision_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vision_name(Arg_&& arg, Args_... args);
  std::string* mutable_vision_name();
  PROTOBUF_NODISCARD std::string* release_vision_name();
  void set_allocated_vision_name(std::string* ptr);

  private:
  const std::string& _internal_vision_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vision_name(
      const std::string& value);
  std::string* _internal_mutable_vision_name();

  public:
  // double px = 2;
  void clear_px() ;
  double px() const;
  void set_px(double value);

  private:
  double _internal_px() const;
  void _internal_set_px(double value);

  public:
  // double py = 3;
  void clear_py() ;
  double py() const;
  void set_py(double value);

  private:
  double _internal_py() const;
  void _internal_set_py(double value);

  public:
  // double pz = 4;
  void clear_pz() ;
  double pz() const;
  void set_pz(double value);

  private:
  double _internal_pz() const;
  void _internal_set_pz(double value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.AddPhotoneoCalibPointReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 63, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr vision_name_;
    double px_;
    double py_;
    double pz_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class VisionServer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.VisionServer) */ {
 public:
  inline VisionServer() : VisionServer(nullptr) {}
  ~VisionServer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionServer(::google::protobuf::internal::ConstantInitialized);

  VisionServer(const VisionServer& from);
  VisionServer(VisionServer&& from) noexcept
    : VisionServer() {
    *this = ::std::move(from);
  }

  inline VisionServer& operator=(const VisionServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionServer& operator=(VisionServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionServer* internal_default_instance() {
    return reinterpret_cast<const VisionServer*>(
               &_VisionServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VisionServer& a, VisionServer& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionServer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionServer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionServer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionServer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionServer& from) {
    VisionServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionServer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.VisionServer";
  }
  protected:
  explicit VisionServer(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VisionServerType = VisionServer_VisionServerType;
  static constexpr VisionServerType INDYEYE = VisionServer_VisionServerType_INDYEYE;
  static constexpr VisionServerType PHOTONEO = VisionServer_VisionServerType_PHOTONEO;
  static constexpr VisionServerType HELIOS = VisionServer_VisionServerType_HELIOS;
  static inline bool VisionServerType_IsValid(int value) {
    return VisionServer_VisionServerType_IsValid(value);
  }
  static constexpr VisionServerType VisionServerType_MIN = VisionServer_VisionServerType_VisionServerType_MIN;
  static constexpr VisionServerType VisionServerType_MAX = VisionServer_VisionServerType_VisionServerType_MAX;
  static constexpr int VisionServerType_ARRAYSIZE = VisionServer_VisionServerType_VisionServerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VisionServerType_descriptor() {
    return VisionServer_VisionServerType_descriptor();
  }
  template <typename T>
  static inline const std::string& VisionServerType_Name(T value) {
    return VisionServer_VisionServerType_Name(value);
  }
  static inline bool VisionServerType_Parse(absl::string_view name, VisionServerType* value) {
    return VisionServer_VisionServerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIpFieldNumber = 3,
    kVisionServerTypeFieldNumber = 2,
    kPortFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string ip = 3;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // .Nrmk.IndyFramework.VisionServer.VisionServerType vision_server_type = 2;
  void clear_vision_server_type() ;
  ::Nrmk::IndyFramework::VisionServer_VisionServerType vision_server_type() const;
  void set_vision_server_type(::Nrmk::IndyFramework::VisionServer_VisionServerType value);

  private:
  ::Nrmk::IndyFramework::VisionServer_VisionServerType _internal_vision_server_type() const;
  void _internal_set_vision_server_type(::Nrmk::IndyFramework::VisionServer_VisionServerType value);

  public:
  // uint32 port = 4;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.VisionServer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    int vision_server_type_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class VisionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.VisionRequest) */ {
 public:
  inline VisionRequest() : VisionRequest(nullptr) {}
  ~VisionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionRequest(::google::protobuf::internal::ConstantInitialized);

  VisionRequest(const VisionRequest& from);
  VisionRequest(VisionRequest&& from) noexcept
    : VisionRequest() {
    *this = ::std::move(from);
  }

  inline VisionRequest& operator=(const VisionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionRequest& operator=(VisionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionRequest* internal_default_instance() {
    return reinterpret_cast<const VisionRequest*>(
               &_VisionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(VisionRequest& a, VisionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionRequest& from) {
    VisionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.VisionRequest";
  }
  protected:
  explicit VisionRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kVisionServerFieldNumber = 1,
    kFrameTypeFieldNumber = 3,
  };
  // string object = 2;
  void clear_object() ;
  const std::string& object() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object(Arg_&& arg, Args_... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* ptr);

  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(
      const std::string& value);
  std::string* _internal_mutable_object();

  public:
  // .Nrmk.IndyFramework.VisionServer vision_server = 1;
  bool has_vision_server() const;
  void clear_vision_server() ;
  const ::Nrmk::IndyFramework::VisionServer& vision_server() const;
  PROTOBUF_NODISCARD ::Nrmk::IndyFramework::VisionServer* release_vision_server();
  ::Nrmk::IndyFramework::VisionServer* mutable_vision_server();
  void set_allocated_vision_server(::Nrmk::IndyFramework::VisionServer* value);
  void unsafe_arena_set_allocated_vision_server(::Nrmk::IndyFramework::VisionServer* value);
  ::Nrmk::IndyFramework::VisionServer* unsafe_arena_release_vision_server();

  private:
  const ::Nrmk::IndyFramework::VisionServer& _internal_vision_server() const;
  ::Nrmk::IndyFramework::VisionServer* _internal_mutable_vision_server();

  public:
  // .Nrmk.IndyFramework.VisionFrameType frame_type = 3;
  void clear_frame_type() ;
  ::Nrmk::IndyFramework::VisionFrameType frame_type() const;
  void set_frame_type(::Nrmk::IndyFramework::VisionFrameType value);

  private:
  ::Nrmk::IndyFramework::VisionFrameType _internal_frame_type() const;
  void _internal_set_frame_type(::Nrmk::IndyFramework::VisionFrameType value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.VisionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr object_;
    ::Nrmk::IndyFramework::VisionServer* vision_server_;
    int frame_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class VisionResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.VisionResult) */ {
 public:
  inline VisionResult() : VisionResult(nullptr) {}
  ~VisionResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionResult(::google::protobuf::internal::ConstantInitialized);

  VisionResult(const VisionResult& from);
  VisionResult(VisionResult&& from) noexcept
    : VisionResult() {
    *this = ::std::move(from);
  }

  inline VisionResult& operator=(const VisionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionResult& operator=(VisionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionResult* internal_default_instance() {
    return reinterpret_cast<const VisionResult*>(
               &_VisionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(VisionResult& a, VisionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionResult& from) {
    VisionResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Nrmk.IndyFramework.VisionResult";
  }
  protected:
  explicit VisionResult(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 1,
    kObjectFieldNumber = 3,
    kMsgFieldNumber = 100,
    kFrameTypeFieldNumber = 2,
    kDetectedFieldNumber = 4,
    kPassedFieldNumber = 5,
  };
  // repeated float frame = 1;
  int frame_size() const;
  private:
  int _internal_frame_size() const;

  public:
  void clear_frame() ;
  float frame(int index) const;
  void set_frame(int index, float value);
  void add_frame(float value);
  const ::google::protobuf::RepeatedField<float>& frame() const;
  ::google::protobuf::RepeatedField<float>* mutable_frame();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_frame() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_frame();

  public:
  // string object = 3;
  void clear_object() ;
  const std::string& object() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object(Arg_&& arg, Args_... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* ptr);

  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(
      const std::string& value);
  std::string* _internal_mutable_object();

  public:
  // string msg = 100;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // .Nrmk.IndyFramework.VisionFrameType frame_type = 2;
  void clear_frame_type() ;
  ::Nrmk::IndyFramework::VisionFrameType frame_type() const;
  void set_frame_type(::Nrmk::IndyFramework::VisionFrameType value);

  private:
  ::Nrmk::IndyFramework::VisionFrameType _internal_frame_type() const;
  void _internal_set_frame_type(::Nrmk::IndyFramework::VisionFrameType value);

  public:
  // bool detected = 4;
  void clear_detected() ;
  bool detected() const;
  void set_detected(bool value);

  private:
  bool _internal_detected() const;
  void _internal_set_detected(bool value);

  public:
  // bool passed = 5;
  void clear_passed() ;
  bool passed() const;
  void set_passed(bool value);

  private:
  bool _internal_passed() const;
  void _internal_set_passed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.VisionResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 49, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> frame_;
    ::google::protobuf::internal::ArenaStringPtr object_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    int frame_type_;
    bool detected_;
    bool passed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Motor

// uint32 index = 1;
inline void Motor::clear_index() {
  _impl_.index_ = 0u;
}
inline ::uint32_t Motor::index() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Motor.index)
  return _internal_index();
}
inline void Motor::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Motor.index)
}
inline ::uint32_t Motor::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void Motor::_internal_set_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.index_ = value;
}

// bool enable = 2;
inline void Motor::clear_enable() {
  _impl_.enable_ = false;
}
inline bool Motor::enable() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Motor.enable)
  return _internal_enable();
}
inline void Motor::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Motor.enable)
}
inline bool Motor::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void Motor::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// Servo

// uint32 index = 1;
inline void Servo::clear_index() {
  _impl_.index_ = 0u;
}
inline ::uint32_t Servo::index() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Servo.index)
  return _internal_index();
}
inline void Servo::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Servo.index)
}
inline ::uint32_t Servo::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void Servo::_internal_set_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.index_ = value;
}

// bool enable = 2;
inline void Servo::clear_enable() {
  _impl_.enable_ = false;
}
inline bool Servo::enable() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Servo.enable)
  return _internal_enable();
}
inline void Servo::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Servo.enable)
}
inline bool Servo::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void Servo::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// GripperData

// .Nrmk.IndyFramework.GripperType gripper_type = 1;
inline void GripperData::clear_gripper_type() {
  _impl_.gripper_type_ = 0;
}
inline ::Nrmk::IndyFramework::GripperType GripperData::gripper_type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperData.gripper_type)
  return _internal_gripper_type();
}
inline void GripperData::set_gripper_type(::Nrmk::IndyFramework::GripperType value) {
  _internal_set_gripper_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperData.gripper_type)
}
inline ::Nrmk::IndyFramework::GripperType GripperData::_internal_gripper_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::GripperType>(_impl_.gripper_type_);
}
inline void GripperData::_internal_set_gripper_type(::Nrmk::IndyFramework::GripperType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gripper_type_ = value;
}

// int32 gripper_position = 2;
inline void GripperData::clear_gripper_position() {
  _impl_.gripper_position_ = 0;
}
inline ::int32_t GripperData::gripper_position() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperData.gripper_position)
  return _internal_gripper_position();
}
inline void GripperData::set_gripper_position(::int32_t value) {
  _internal_set_gripper_position(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperData.gripper_position)
}
inline ::int32_t GripperData::_internal_gripper_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gripper_position_;
}
inline void GripperData::_internal_set_gripper_position(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gripper_position_ = value;
}

// int32 gripper_state = 3;
inline void GripperData::clear_gripper_state() {
  _impl_.gripper_state_ = 0;
}
inline ::int32_t GripperData::gripper_state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperData.gripper_state)
  return _internal_gripper_state();
}
inline void GripperData::set_gripper_state(::int32_t value) {
  _internal_set_gripper_state(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperData.gripper_state)
}
inline ::int32_t GripperData::_internal_gripper_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gripper_state_;
}
inline void GripperData::_internal_set_gripper_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gripper_state_ = value;
}

// -------------------------------------------------------------------

// GripperCommand

// .Nrmk.IndyFramework.GripperCommand.GripperCommandType gripper_command = 1;
inline void GripperCommand::clear_gripper_command() {
  _impl_.gripper_command_ = 0;
}
inline ::Nrmk::IndyFramework::GripperCommand_GripperCommandType GripperCommand::gripper_command() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperCommand.gripper_command)
  return _internal_gripper_command();
}
inline void GripperCommand::set_gripper_command(::Nrmk::IndyFramework::GripperCommand_GripperCommandType value) {
  _internal_set_gripper_command(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperCommand.gripper_command)
}
inline ::Nrmk::IndyFramework::GripperCommand_GripperCommandType GripperCommand::_internal_gripper_command() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::GripperCommand_GripperCommandType>(_impl_.gripper_command_);
}
inline void GripperCommand::_internal_set_gripper_command(::Nrmk::IndyFramework::GripperCommand_GripperCommandType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gripper_command_ = value;
}

// .Nrmk.IndyFramework.GripperType gripper_type = 2;
inline void GripperCommand::clear_gripper_type() {
  _impl_.gripper_type_ = 0;
}
inline ::Nrmk::IndyFramework::GripperType GripperCommand::gripper_type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperCommand.gripper_type)
  return _internal_gripper_type();
}
inline void GripperCommand::set_gripper_type(::Nrmk::IndyFramework::GripperType value) {
  _internal_set_gripper_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperCommand.gripper_type)
}
inline ::Nrmk::IndyFramework::GripperType GripperCommand::_internal_gripper_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::GripperType>(_impl_.gripper_type_);
}
inline void GripperCommand::_internal_set_gripper_type(::Nrmk::IndyFramework::GripperType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gripper_type_ = value;
}

// repeated int32 gripper_pvt_data = 3;
inline int GripperCommand::_internal_gripper_pvt_data_size() const {
  return _internal_gripper_pvt_data().size();
}
inline int GripperCommand::gripper_pvt_data_size() const {
  return _internal_gripper_pvt_data_size();
}
inline void GripperCommand::clear_gripper_pvt_data() {
  _internal_mutable_gripper_pvt_data()->Clear();
}
inline ::int32_t GripperCommand::gripper_pvt_data(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
  return _internal_gripper_pvt_data().Get(index);
}
inline void GripperCommand::set_gripper_pvt_data(int index, ::int32_t value) {
  _internal_mutable_gripper_pvt_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
}
inline void GripperCommand::add_gripper_pvt_data(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_gripper_pvt_data()->Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& GripperCommand::gripper_pvt_data() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
  return _internal_gripper_pvt_data();
}
inline ::google::protobuf::RepeatedField<::int32_t>* GripperCommand::mutable_gripper_pvt_data() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_gripper_pvt_data();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& GripperCommand::_internal_gripper_pvt_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gripper_pvt_data_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* GripperCommand::_internal_mutable_gripper_pvt_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.gripper_pvt_data_;
}

// -------------------------------------------------------------------

// DigitalSignal

// uint32 address = 1;
inline void DigitalSignal::clear_address() {
  _impl_.address_ = 0u;
}
inline ::uint32_t DigitalSignal::address() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DigitalSignal.address)
  return _internal_address();
}
inline void DigitalSignal::set_address(::uint32_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DigitalSignal.address)
}
inline ::uint32_t DigitalSignal::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_;
}
inline void DigitalSignal::_internal_set_address(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_ = value;
}

// .Nrmk.IndyFramework.DigitalState state = 2;
inline void DigitalSignal::clear_state() {
  _impl_.state_ = 0;
}
inline ::Nrmk::IndyFramework::DigitalState DigitalSignal::state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DigitalSignal.state)
  return _internal_state();
}
inline void DigitalSignal::set_state(::Nrmk::IndyFramework::DigitalState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DigitalSignal.state)
}
inline ::Nrmk::IndyFramework::DigitalState DigitalSignal::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::DigitalState>(_impl_.state_);
}
inline void DigitalSignal::_internal_set_state(::Nrmk::IndyFramework::DigitalState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// EndLedDim

// uint32 led_dim = 1;
inline void EndLedDim::clear_led_dim() {
  _impl_.led_dim_ = 0u;
}
inline ::uint32_t EndLedDim::led_dim() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndLedDim.led_dim)
  return _internal_led_dim();
}
inline void EndLedDim::set_led_dim(::uint32_t value) {
  _internal_set_led_dim(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.EndLedDim.led_dim)
}
inline ::uint32_t EndLedDim::_internal_led_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.led_dim_;
}
inline void EndLedDim::_internal_set_led_dim(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.led_dim_ = value;
}

// -------------------------------------------------------------------

// EndtoolSignal

// string port = 1;
inline void EndtoolSignal::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& EndtoolSignal::port() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndtoolSignal.port)
  return _internal_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EndtoolSignal::set_port(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.EndtoolSignal.port)
}
inline std::string* EndtoolSignal::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.EndtoolSignal.port)
  return _s;
}
inline const std::string& EndtoolSignal::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_.Get();
}
inline void EndtoolSignal::_internal_set_port(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* EndtoolSignal::_internal_mutable_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.port_.Mutable( GetArenaForAllocation());
}
inline std::string* EndtoolSignal::release_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.EndtoolSignal.port)
  return _impl_.port_.Release();
}
inline void EndtoolSignal::set_allocated_port(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_.IsDefault()) {
          _impl_.port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.EndtoolSignal.port)
}

// repeated .Nrmk.IndyFramework.EndtoolState states = 2;
inline int EndtoolSignal::_internal_states_size() const {
  return _internal_states().size();
}
inline int EndtoolSignal::states_size() const {
  return _internal_states_size();
}
inline void EndtoolSignal::clear_states() {
  _internal_mutable_states()->Clear();
}
inline ::Nrmk::IndyFramework::EndtoolState EndtoolSignal::states(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndtoolSignal.states)
  return static_cast<::Nrmk::IndyFramework::EndtoolState>(_internal_states().Get(index));
}
inline void EndtoolSignal::set_states(int index, ::Nrmk::IndyFramework::EndtoolState value) {
  _internal_mutable_states()->Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.EndtoolSignal.states)
}
inline void EndtoolSignal::add_states(::Nrmk::IndyFramework::EndtoolState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_states()->Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.EndtoolSignal.states)
}
inline const ::google::protobuf::RepeatedField<int>& EndtoolSignal::states() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.EndtoolSignal.states)
  return _internal_states();
}
inline ::google::protobuf::RepeatedField<int>* EndtoolSignal::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.EndtoolSignal.states)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_states();
}
inline const ::google::protobuf::RepeatedField<int>& EndtoolSignal::_internal_states() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.states_;
}
inline ::google::protobuf::RepeatedField<int>* EndtoolSignal::_internal_mutable_states() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.states_;
}

// -------------------------------------------------------------------

// AnalogSignal

// uint32 address = 1;
inline void AnalogSignal::clear_address() {
  _impl_.address_ = 0u;
}
inline ::uint32_t AnalogSignal::address() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AnalogSignal.address)
  return _internal_address();
}
inline void AnalogSignal::set_address(::uint32_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AnalogSignal.address)
}
inline ::uint32_t AnalogSignal::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_;
}
inline void AnalogSignal::_internal_set_address(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_ = value;
}

// int32 voltage = 2;
inline void AnalogSignal::clear_voltage() {
  _impl_.voltage_ = 0;
}
inline ::int32_t AnalogSignal::voltage() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AnalogSignal.voltage)
  return _internal_voltage();
}
inline void AnalogSignal::set_voltage(::int32_t value) {
  _internal_set_voltage(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AnalogSignal.voltage)
}
inline ::int32_t AnalogSignal::_internal_voltage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voltage_;
}
inline void AnalogSignal::_internal_set_voltage(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.voltage_ = value;
}

// -------------------------------------------------------------------

// MotorList

// repeated .Nrmk.IndyFramework.Motor motors = 1;
inline int MotorList::_internal_motors_size() const {
  return _internal_motors().size();
}
inline int MotorList::motors_size() const {
  return _internal_motors_size();
}
inline void MotorList::clear_motors() {
  _internal_mutable_motors()->Clear();
}
inline ::Nrmk::IndyFramework::Motor* MotorList::mutable_motors(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.MotorList.motors)
  return _internal_mutable_motors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >*
MotorList::mutable_motors() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.MotorList.motors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_motors();
}
inline const ::Nrmk::IndyFramework::Motor& MotorList::motors(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.MotorList.motors)
    return _internal_motors().Get(index);
}
inline ::Nrmk::IndyFramework::Motor* MotorList::add_motors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Nrmk::IndyFramework::Motor* _add = _internal_mutable_motors()->Add();
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.MotorList.motors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >&
MotorList::motors() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.MotorList.motors)
  return _internal_motors();
}
inline const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::Motor>&
MotorList::_internal_motors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.motors_;
}
inline ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::Motor>*
MotorList::_internal_mutable_motors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.motors_;
}

// -------------------------------------------------------------------

// DigitalList

// repeated .Nrmk.IndyFramework.DigitalSignal signals = 1;
inline int DigitalList::_internal_signals_size() const {
  return _internal_signals().size();
}
inline int DigitalList::signals_size() const {
  return _internal_signals_size();
}
inline void DigitalList::clear_signals() {
  _internal_mutable_signals()->Clear();
}
inline ::Nrmk::IndyFramework::DigitalSignal* DigitalList::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DigitalList.signals)
  return _internal_mutable_signals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >*
DigitalList::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.DigitalList.signals)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_signals();
}
inline const ::Nrmk::IndyFramework::DigitalSignal& DigitalList::signals(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DigitalList.signals)
    return _internal_signals().Get(index);
}
inline ::Nrmk::IndyFramework::DigitalSignal* DigitalList::add_signals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Nrmk::IndyFramework::DigitalSignal* _add = _internal_mutable_signals()->Add();
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.DigitalList.signals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >&
DigitalList::signals() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.DigitalList.signals)
  return _internal_signals();
}
inline const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::DigitalSignal>&
DigitalList::_internal_signals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signals_;
}
inline ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::DigitalSignal>*
DigitalList::_internal_mutable_signals() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.signals_;
}

// -------------------------------------------------------------------

// EndtoolSignalList

// repeated .Nrmk.IndyFramework.EndtoolSignal signals = 1;
inline int EndtoolSignalList::_internal_signals_size() const {
  return _internal_signals().size();
}
inline int EndtoolSignalList::signals_size() const {
  return _internal_signals_size();
}
inline void EndtoolSignalList::clear_signals() {
  _internal_mutable_signals()->Clear();
}
inline ::Nrmk::IndyFramework::EndtoolSignal* EndtoolSignalList::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return _internal_mutable_signals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >*
EndtoolSignalList::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.EndtoolSignalList.signals)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_signals();
}
inline const ::Nrmk::IndyFramework::EndtoolSignal& EndtoolSignalList::signals(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndtoolSignalList.signals)
    return _internal_signals().Get(index);
}
inline ::Nrmk::IndyFramework::EndtoolSignal* EndtoolSignalList::add_signals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Nrmk::IndyFramework::EndtoolSignal* _add = _internal_mutable_signals()->Add();
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >&
EndtoolSignalList::signals() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return _internal_signals();
}
inline const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::EndtoolSignal>&
EndtoolSignalList::_internal_signals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signals_;
}
inline ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::EndtoolSignal>*
EndtoolSignalList::_internal_mutable_signals() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.signals_;
}

// -------------------------------------------------------------------

// AnalogList

// repeated .Nrmk.IndyFramework.AnalogSignal signals = 1;
inline int AnalogList::_internal_signals_size() const {
  return _internal_signals().size();
}
inline int AnalogList::signals_size() const {
  return _internal_signals_size();
}
inline void AnalogList::clear_signals() {
  _internal_mutable_signals()->Clear();
}
inline ::Nrmk::IndyFramework::AnalogSignal* AnalogList::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.AnalogList.signals)
  return _internal_mutable_signals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >*
AnalogList::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.AnalogList.signals)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_signals();
}
inline const ::Nrmk::IndyFramework::AnalogSignal& AnalogList::signals(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AnalogList.signals)
    return _internal_signals().Get(index);
}
inline ::Nrmk::IndyFramework::AnalogSignal* AnalogList::add_signals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Nrmk::IndyFramework::AnalogSignal* _add = _internal_mutable_signals()->Add();
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.AnalogList.signals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >&
AnalogList::signals() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.AnalogList.signals)
  return _internal_signals();
}
inline const ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::AnalogSignal>&
AnalogList::_internal_signals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signals_;
}
inline ::google::protobuf::RepeatedPtrField<::Nrmk::IndyFramework::AnalogSignal>*
AnalogList::_internal_mutable_signals() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.signals_;
}

// -------------------------------------------------------------------

// DeviceInfo

// uint32 num_joints = 1;
inline void DeviceInfo::clear_num_joints() {
  _impl_.num_joints_ = 0u;
}
inline ::uint32_t DeviceInfo::num_joints() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.num_joints)
  return _internal_num_joints();
}
inline void DeviceInfo::set_num_joints(::uint32_t value) {
  _internal_set_num_joints(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.num_joints)
}
inline ::uint32_t DeviceInfo::_internal_num_joints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_joints_;
}
inline void DeviceInfo::_internal_set_num_joints(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_joints_ = value;
}

// string robot_serial = 2;
inline void DeviceInfo::clear_robot_serial() {
  _impl_.robot_serial_.ClearToEmpty();
}
inline const std::string& DeviceInfo::robot_serial() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.robot_serial)
  return _internal_robot_serial();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInfo::set_robot_serial(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.robot_serial_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.robot_serial)
}
inline std::string* DeviceInfo::mutable_robot_serial() {
  std::string* _s = _internal_mutable_robot_serial();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.robot_serial)
  return _s;
}
inline const std::string& DeviceInfo::_internal_robot_serial() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.robot_serial_.Get();
}
inline void DeviceInfo::_internal_set_robot_serial(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.robot_serial_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_robot_serial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.robot_serial_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_robot_serial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.robot_serial)
  return _impl_.robot_serial_.Release();
}
inline void DeviceInfo::set_allocated_robot_serial(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.robot_serial_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.robot_serial_.IsDefault()) {
          _impl_.robot_serial_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.robot_serial)
}

// float payload = 3;
inline void DeviceInfo::clear_payload() {
  _impl_.payload_ = 0;
}
inline float DeviceInfo::payload() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.payload)
  return _internal_payload();
}
inline void DeviceInfo::set_payload(float value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.payload)
}
inline float DeviceInfo::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_;
}
inline void DeviceInfo::_internal_set_payload(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.payload_ = value;
}

// string io_board_fw_ver = 10;
inline void DeviceInfo::clear_io_board_fw_ver() {
  _impl_.io_board_fw_ver_.ClearToEmpty();
}
inline const std::string& DeviceInfo::io_board_fw_ver() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
  return _internal_io_board_fw_ver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInfo::set_io_board_fw_ver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.io_board_fw_ver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
}
inline std::string* DeviceInfo::mutable_io_board_fw_ver() {
  std::string* _s = _internal_mutable_io_board_fw_ver();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
  return _s;
}
inline const std::string& DeviceInfo::_internal_io_board_fw_ver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.io_board_fw_ver_.Get();
}
inline void DeviceInfo::_internal_set_io_board_fw_ver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.io_board_fw_ver_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_io_board_fw_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.io_board_fw_ver_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_io_board_fw_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
  return _impl_.io_board_fw_ver_.Release();
}
inline void DeviceInfo::set_allocated_io_board_fw_ver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.io_board_fw_ver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.io_board_fw_ver_.IsDefault()) {
          _impl_.io_board_fw_ver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
}

// repeated string core_board_fw_vers = 11;
inline int DeviceInfo::_internal_core_board_fw_vers_size() const {
  return _internal_core_board_fw_vers().size();
}
inline int DeviceInfo::core_board_fw_vers_size() const {
  return _internal_core_board_fw_vers_size();
}
inline void DeviceInfo::clear_core_board_fw_vers() {
  _internal_mutable_core_board_fw_vers()->Clear();
}
inline std::string* DeviceInfo::add_core_board_fw_vers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_core_board_fw_vers()->Add();
  // @@protoc_insertion_point(field_add_mutable:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return _s;
}
inline const std::string& DeviceInfo::core_board_fw_vers(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return _internal_core_board_fw_vers().Get(index);
}
inline std::string* DeviceInfo::mutable_core_board_fw_vers(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return _internal_mutable_core_board_fw_vers()->Mutable(index);
}
inline void DeviceInfo::set_core_board_fw_vers(int index, const std::string& value) {
  _internal_mutable_core_board_fw_vers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::set_core_board_fw_vers(int index, std::string&& value) {
  _internal_mutable_core_board_fw_vers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::set_core_board_fw_vers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_core_board_fw_vers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::set_core_board_fw_vers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_core_board_fw_vers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::set_core_board_fw_vers(int index, absl::string_view value) {
  _internal_mutable_core_board_fw_vers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_core_board_fw_vers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_core_board_fw_vers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_core_board_fw_vers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_core_board_fw_vers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_core_board_fw_vers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DeviceInfo::core_board_fw_vers() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return _internal_core_board_fw_vers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* DeviceInfo::mutable_core_board_fw_vers() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_core_board_fw_vers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DeviceInfo::_internal_core_board_fw_vers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.core_board_fw_vers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DeviceInfo::_internal_mutable_core_board_fw_vers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.core_board_fw_vers_;
}

// string endtool_board_fw_ver = 12;
inline void DeviceInfo::clear_endtool_board_fw_ver() {
  _impl_.endtool_board_fw_ver_.ClearToEmpty();
}
inline const std::string& DeviceInfo::endtool_board_fw_ver() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
  return _internal_endtool_board_fw_ver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInfo::set_endtool_board_fw_ver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.endtool_board_fw_ver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
}
inline std::string* DeviceInfo::mutable_endtool_board_fw_ver() {
  std::string* _s = _internal_mutable_endtool_board_fw_ver();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
  return _s;
}
inline const std::string& DeviceInfo::_internal_endtool_board_fw_ver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endtool_board_fw_ver_.Get();
}
inline void DeviceInfo::_internal_set_endtool_board_fw_ver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.endtool_board_fw_ver_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_endtool_board_fw_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.endtool_board_fw_ver_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_endtool_board_fw_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
  return _impl_.endtool_board_fw_ver_.Release();
}
inline void DeviceInfo::set_allocated_endtool_board_fw_ver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endtool_board_fw_ver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endtool_board_fw_ver_.IsDefault()) {
          _impl_.endtool_board_fw_ver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
}

// string controller_ver = 20;
inline void DeviceInfo::clear_controller_ver() {
  _impl_.controller_ver_.ClearToEmpty();
}
inline const std::string& DeviceInfo::controller_ver() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.controller_ver)
  return _internal_controller_ver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInfo::set_controller_ver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.controller_ver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.controller_ver)
}
inline std::string* DeviceInfo::mutable_controller_ver() {
  std::string* _s = _internal_mutable_controller_ver();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.controller_ver)
  return _s;
}
inline const std::string& DeviceInfo::_internal_controller_ver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.controller_ver_.Get();
}
inline void DeviceInfo::_internal_set_controller_ver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.controller_ver_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_controller_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.controller_ver_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_controller_ver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.controller_ver)
  return _impl_.controller_ver_.Release();
}
inline void DeviceInfo::set_allocated_controller_ver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.controller_ver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.controller_ver_.IsDefault()) {
          _impl_.controller_ver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.controller_ver)
}

// string controller_detail = 21;
inline void DeviceInfo::clear_controller_detail() {
  _impl_.controller_detail_.ClearToEmpty();
}
inline const std::string& DeviceInfo::controller_detail() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.controller_detail)
  return _internal_controller_detail();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInfo::set_controller_detail(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.controller_detail_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.controller_detail)
}
inline std::string* DeviceInfo::mutable_controller_detail() {
  std::string* _s = _internal_mutable_controller_detail();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.controller_detail)
  return _s;
}
inline const std::string& DeviceInfo::_internal_controller_detail() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.controller_detail_.Get();
}
inline void DeviceInfo::_internal_set_controller_detail(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.controller_detail_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_controller_detail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.controller_detail_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_controller_detail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.controller_detail)
  return _impl_.controller_detail_.Release();
}
inline void DeviceInfo::set_allocated_controller_detail(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.controller_detail_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.controller_detail_.IsDefault()) {
          _impl_.controller_detail_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.controller_detail)
}

// string controller_date = 22;
inline void DeviceInfo::clear_controller_date() {
  _impl_.controller_date_.ClearToEmpty();
}
inline const std::string& DeviceInfo::controller_date() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.controller_date)
  return _internal_controller_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInfo::set_controller_date(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.controller_date_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.controller_date)
}
inline std::string* DeviceInfo::mutable_controller_date() {
  std::string* _s = _internal_mutable_controller_date();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.controller_date)
  return _s;
}
inline const std::string& DeviceInfo::_internal_controller_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.controller_date_.Get();
}
inline void DeviceInfo::_internal_set_controller_date(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.controller_date_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_controller_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.controller_date_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_controller_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.controller_date)
  return _impl_.controller_date_.Release();
}
inline void DeviceInfo::set_allocated_controller_date(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.controller_date_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.controller_date_.IsDefault()) {
          _impl_.controller_date_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.controller_date)
}

// bool teleop_loaded = 30;
inline void DeviceInfo::clear_teleop_loaded() {
  _impl_.teleop_loaded_ = false;
}
inline bool DeviceInfo::teleop_loaded() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.teleop_loaded)
  return _internal_teleop_loaded();
}
inline void DeviceInfo::set_teleop_loaded(bool value) {
  _internal_set_teleop_loaded(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.teleop_loaded)
}
inline bool DeviceInfo::_internal_teleop_loaded() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teleop_loaded_;
}
inline void DeviceInfo::_internal_set_teleop_loaded(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.teleop_loaded_ = value;
}

// bool calibrated = 31;
inline void DeviceInfo::clear_calibrated() {
  _impl_.calibrated_ = false;
}
inline bool DeviceInfo::calibrated() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.calibrated)
  return _internal_calibrated();
}
inline void DeviceInfo::set_calibrated(bool value) {
  _internal_set_calibrated(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.calibrated)
}
inline bool DeviceInfo::_internal_calibrated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.calibrated_;
}
inline void DeviceInfo::_internal_set_calibrated(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.calibrated_ = value;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool DeviceInfo::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Response& DeviceInfo::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Response&>(::Nrmk::IndyFramework::_Response_default_instance_);
}
inline const ::Nrmk::IndyFramework::Response& DeviceInfo::response() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.response)
  return _internal_response();
}
inline void DeviceInfo::unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.DeviceInfo.response)
}
inline ::Nrmk::IndyFramework::Response* DeviceInfo::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Response* DeviceInfo::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.response)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* DeviceInfo::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaForAllocation());
    _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(p);
  }
  return _impl_.response_;
}
inline ::Nrmk::IndyFramework::Response* DeviceInfo::mutable_response() {
  ::Nrmk::IndyFramework::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.response)
  return _msg;
}
inline void DeviceInfo::set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.response)
}

// -------------------------------------------------------------------

// BrakeControlStyle

// .Nrmk.IndyFramework.BrakeControlStyle.ControlStyle style = 1;
inline void BrakeControlStyle::clear_style() {
  _impl_.style_ = 0;
}
inline ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle BrakeControlStyle::style() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.BrakeControlStyle.style)
  return _internal_style();
}
inline void BrakeControlStyle::set_style(::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.BrakeControlStyle.style)
}
inline ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle BrakeControlStyle::_internal_style() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle>(_impl_.style_);
}
inline void BrakeControlStyle::_internal_set_style(::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.style_ = value;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool BrakeControlStyle::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Response& BrakeControlStyle::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Response&>(::Nrmk::IndyFramework::_Response_default_instance_);
}
inline const ::Nrmk::IndyFramework::Response& BrakeControlStyle::response() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.BrakeControlStyle.response)
  return _internal_response();
}
inline void BrakeControlStyle::unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.BrakeControlStyle.response)
}
inline ::Nrmk::IndyFramework::Response* BrakeControlStyle::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Response* BrakeControlStyle::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.BrakeControlStyle.response)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* BrakeControlStyle::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaForAllocation());
    _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(p);
  }
  return _impl_.response_;
}
inline ::Nrmk::IndyFramework::Response* BrakeControlStyle::mutable_response() {
  ::Nrmk::IndyFramework::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.BrakeControlStyle.response)
  return _msg;
}
inline void BrakeControlStyle::set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.BrakeControlStyle.response)
}

// -------------------------------------------------------------------

// GetEL5001Data

// int32 status = 1;
inline void GetEL5001Data::clear_status() {
  _impl_.status_ = 0;
}
inline ::int32_t GetEL5001Data::status() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.status)
  return _internal_status();
}
inline void GetEL5001Data::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.status)
}
inline ::int32_t GetEL5001Data::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void GetEL5001Data::_internal_set_status(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// int32 value = 2;
inline void GetEL5001Data::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t GetEL5001Data::value() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.value)
  return _internal_value();
}
inline void GetEL5001Data::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.value)
}
inline ::int32_t GetEL5001Data::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void GetEL5001Data::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// int32 delta = 3;
inline void GetEL5001Data::clear_delta() {
  _impl_.delta_ = 0;
}
inline ::int32_t GetEL5001Data::delta() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.delta)
  return _internal_delta();
}
inline void GetEL5001Data::set_delta(::int32_t value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.delta)
}
inline ::int32_t GetEL5001Data::_internal_delta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.delta_;
}
inline void GetEL5001Data::_internal_set_delta(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.delta_ = value;
}

// float average = 4;
inline void GetEL5001Data::clear_average() {
  _impl_.average_ = 0;
}
inline float GetEL5001Data::average() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.average)
  return _internal_average();
}
inline void GetEL5001Data::set_average(float value) {
  _internal_set_average(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.average)
}
inline float GetEL5001Data::_internal_average() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_;
}
inline void GetEL5001Data::_internal_set_average(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_ = value;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool GetEL5001Data::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Response& GetEL5001Data::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Response&>(::Nrmk::IndyFramework::_Response_default_instance_);
}
inline const ::Nrmk::IndyFramework::Response& GetEL5001Data::response() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.response)
  return _internal_response();
}
inline void GetEL5001Data::unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.GetEL5001Data.response)
}
inline ::Nrmk::IndyFramework::Response* GetEL5001Data::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Response* GetEL5001Data::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.GetEL5001Data.response)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* GetEL5001Data::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaForAllocation());
    _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(p);
  }
  return _impl_.response_;
}
inline ::Nrmk::IndyFramework::Response* GetEL5001Data::mutable_response() {
  ::Nrmk::IndyFramework::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.GetEL5001Data.response)
  return _msg;
}
inline void GetEL5001Data::set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.GetEL5001Data.response)
}

// -------------------------------------------------------------------

// GetEL5101Data

// int32 status = 1;
inline void GetEL5101Data::clear_status() {
  _impl_.status_ = 0;
}
inline ::int32_t GetEL5101Data::status() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.status)
  return _internal_status();
}
inline void GetEL5101Data::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.status)
}
inline ::int32_t GetEL5101Data::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void GetEL5101Data::_internal_set_status(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// int32 value = 2;
inline void GetEL5101Data::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t GetEL5101Data::value() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.value)
  return _internal_value();
}
inline void GetEL5101Data::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.value)
}
inline ::int32_t GetEL5101Data::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void GetEL5101Data::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// int32 latch = 3;
inline void GetEL5101Data::clear_latch() {
  _impl_.latch_ = 0;
}
inline ::int32_t GetEL5101Data::latch() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.latch)
  return _internal_latch();
}
inline void GetEL5101Data::set_latch(::int32_t value) {
  _internal_set_latch(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.latch)
}
inline ::int32_t GetEL5101Data::_internal_latch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latch_;
}
inline void GetEL5101Data::_internal_set_latch(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.latch_ = value;
}

// int32 delta = 4;
inline void GetEL5101Data::clear_delta() {
  _impl_.delta_ = 0;
}
inline ::int32_t GetEL5101Data::delta() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.delta)
  return _internal_delta();
}
inline void GetEL5101Data::set_delta(::int32_t value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.delta)
}
inline ::int32_t GetEL5101Data::_internal_delta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.delta_;
}
inline void GetEL5101Data::_internal_set_delta(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.delta_ = value;
}

// float average = 5;
inline void GetEL5101Data::clear_average() {
  _impl_.average_ = 0;
}
inline float GetEL5101Data::average() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.average)
  return _internal_average();
}
inline void GetEL5101Data::set_average(float value) {
  _internal_set_average(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.average)
}
inline float GetEL5101Data::_internal_average() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_;
}
inline void GetEL5101Data::_internal_set_average(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_ = value;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool GetEL5101Data::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Response& GetEL5101Data::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Response&>(::Nrmk::IndyFramework::_Response_default_instance_);
}
inline const ::Nrmk::IndyFramework::Response& GetEL5101Data::response() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.response)
  return _internal_response();
}
inline void GetEL5101Data::unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.GetEL5101Data.response)
}
inline ::Nrmk::IndyFramework::Response* GetEL5101Data::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Response* GetEL5101Data::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.GetEL5101Data.response)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* GetEL5101Data::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaForAllocation());
    _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(p);
  }
  return _impl_.response_;
}
inline ::Nrmk::IndyFramework::Response* GetEL5101Data::mutable_response() {
  ::Nrmk::IndyFramework::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.GetEL5101Data.response)
  return _msg;
}
inline void GetEL5101Data::set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.GetEL5101Data.response)
}

// -------------------------------------------------------------------

// FTSensorData

// float ft_Fx = 1;
inline void FTSensorData::clear_ft_fx() {
  _impl_.ft_fx_ = 0;
}
inline float FTSensorData::ft_fx() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Fx)
  return _internal_ft_fx();
}
inline void FTSensorData::set_ft_fx(float value) {
  _internal_set_ft_fx(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Fx)
}
inline float FTSensorData::_internal_ft_fx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ft_fx_;
}
inline void FTSensorData::_internal_set_ft_fx(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ft_fx_ = value;
}

// float ft_Fy = 2;
inline void FTSensorData::clear_ft_fy() {
  _impl_.ft_fy_ = 0;
}
inline float FTSensorData::ft_fy() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Fy)
  return _internal_ft_fy();
}
inline void FTSensorData::set_ft_fy(float value) {
  _internal_set_ft_fy(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Fy)
}
inline float FTSensorData::_internal_ft_fy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ft_fy_;
}
inline void FTSensorData::_internal_set_ft_fy(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ft_fy_ = value;
}

// float ft_Fz = 3;
inline void FTSensorData::clear_ft_fz() {
  _impl_.ft_fz_ = 0;
}
inline float FTSensorData::ft_fz() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Fz)
  return _internal_ft_fz();
}
inline void FTSensorData::set_ft_fz(float value) {
  _internal_set_ft_fz(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Fz)
}
inline float FTSensorData::_internal_ft_fz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ft_fz_;
}
inline void FTSensorData::_internal_set_ft_fz(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ft_fz_ = value;
}

// float ft_Tx = 4;
inline void FTSensorData::clear_ft_tx() {
  _impl_.ft_tx_ = 0;
}
inline float FTSensorData::ft_tx() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Tx)
  return _internal_ft_tx();
}
inline void FTSensorData::set_ft_tx(float value) {
  _internal_set_ft_tx(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Tx)
}
inline float FTSensorData::_internal_ft_tx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ft_tx_;
}
inline void FTSensorData::_internal_set_ft_tx(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ft_tx_ = value;
}

// float ft_Ty = 5;
inline void FTSensorData::clear_ft_ty() {
  _impl_.ft_ty_ = 0;
}
inline float FTSensorData::ft_ty() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Ty)
  return _internal_ft_ty();
}
inline void FTSensorData::set_ft_ty(float value) {
  _internal_set_ft_ty(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Ty)
}
inline float FTSensorData::_internal_ft_ty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ft_ty_;
}
inline void FTSensorData::_internal_set_ft_ty(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ft_ty_ = value;
}

// float ft_Tz = 6;
inline void FTSensorData::clear_ft_tz() {
  _impl_.ft_tz_ = 0;
}
inline float FTSensorData::ft_tz() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Tz)
  return _internal_ft_tz();
}
inline void FTSensorData::set_ft_tz(float value) {
  _internal_set_ft_tz(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Tz)
}
inline float FTSensorData::_internal_ft_tz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ft_tz_;
}
inline void FTSensorData::_internal_set_ft_tz(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ft_tz_ = value;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool FTSensorData::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Response& FTSensorData::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Response&>(::Nrmk::IndyFramework::_Response_default_instance_);
}
inline const ::Nrmk::IndyFramework::Response& FTSensorData::response() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.response)
  return _internal_response();
}
inline void FTSensorData::unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.FTSensorData.response)
}
inline ::Nrmk::IndyFramework::Response* FTSensorData::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Response* FTSensorData::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.FTSensorData.response)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* FTSensorData::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaForAllocation());
    _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(p);
  }
  return _impl_.response_;
}
inline ::Nrmk::IndyFramework::Response* FTSensorData::mutable_response() {
  ::Nrmk::IndyFramework::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.FTSensorData.response)
  return _msg;
}
inline void FTSensorData::set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.FTSensorData.response)
}

// -------------------------------------------------------------------

// GetLoadFactorsRes

// repeated int32 percents = 1;
inline int GetLoadFactorsRes::_internal_percents_size() const {
  return _internal_percents().size();
}
inline int GetLoadFactorsRes::percents_size() const {
  return _internal_percents_size();
}
inline void GetLoadFactorsRes::clear_percents() {
  _internal_mutable_percents()->Clear();
}
inline ::int32_t GetLoadFactorsRes::percents(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
  return _internal_percents().Get(index);
}
inline void GetLoadFactorsRes::set_percents(int index, ::int32_t value) {
  _internal_mutable_percents()->Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
}
inline void GetLoadFactorsRes::add_percents(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_percents()->Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& GetLoadFactorsRes::percents() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
  return _internal_percents();
}
inline ::google::protobuf::RepeatedField<::int32_t>* GetLoadFactorsRes::mutable_percents() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_percents();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& GetLoadFactorsRes::_internal_percents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.percents_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* GetLoadFactorsRes::_internal_mutable_percents() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.percents_;
}

// repeated float torques = 2;
inline int GetLoadFactorsRes::_internal_torques_size() const {
  return _internal_torques().size();
}
inline int GetLoadFactorsRes::torques_size() const {
  return _internal_torques_size();
}
inline void GetLoadFactorsRes::clear_torques() {
  _internal_mutable_torques()->Clear();
}
inline float GetLoadFactorsRes::torques(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
  return _internal_torques().Get(index);
}
inline void GetLoadFactorsRes::set_torques(int index, float value) {
  _internal_mutable_torques()->Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
}
inline void GetLoadFactorsRes::add_torques(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_torques()->Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
}
inline const ::google::protobuf::RepeatedField<float>& GetLoadFactorsRes::torques() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
  return _internal_torques();
}
inline ::google::protobuf::RepeatedField<float>* GetLoadFactorsRes::mutable_torques() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_torques();
}

inline const ::google::protobuf::RepeatedField<float>& GetLoadFactorsRes::_internal_torques() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.torques_;
}
inline ::google::protobuf::RepeatedField<float>* GetLoadFactorsRes::_internal_mutable_torques() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.torques_;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool GetLoadFactorsRes::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Response& GetLoadFactorsRes::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Response&>(::Nrmk::IndyFramework::_Response_default_instance_);
}
inline const ::Nrmk::IndyFramework::Response& GetLoadFactorsRes::response() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetLoadFactorsRes.response)
  return _internal_response();
}
inline void GetLoadFactorsRes::unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.GetLoadFactorsRes.response)
}
inline ::Nrmk::IndyFramework::Response* GetLoadFactorsRes::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Response* GetLoadFactorsRes::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.GetLoadFactorsRes.response)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* GetLoadFactorsRes::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaForAllocation());
    _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(p);
  }
  return _impl_.response_;
}
inline ::Nrmk::IndyFramework::Response* GetLoadFactorsRes::mutable_response() {
  ::Nrmk::IndyFramework::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.GetLoadFactorsRes.response)
  return _msg;
}
inline void GetLoadFactorsRes::set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.GetLoadFactorsRes.response)
}

// -------------------------------------------------------------------

// SetAutoModeReq

// bool on = 1;
inline void SetAutoModeReq::clear_on() {
  _impl_.on_ = false;
}
inline bool SetAutoModeReq::on() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SetAutoModeReq.on)
  return _internal_on();
}
inline void SetAutoModeReq::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SetAutoModeReq.on)
}
inline bool SetAutoModeReq::_internal_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.on_;
}
inline void SetAutoModeReq::_internal_set_on(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_ = value;
}

// -------------------------------------------------------------------

// SetAutoModeRes

// string msg = 100;
inline void SetAutoModeRes::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SetAutoModeRes::msg() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SetAutoModeRes.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetAutoModeRes::set_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SetAutoModeRes.msg)
}
inline std::string* SetAutoModeRes::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SetAutoModeRes.msg)
  return _s;
}
inline const std::string& SetAutoModeRes::_internal_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msg_.Get();
}
inline void SetAutoModeRes::_internal_set_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAutoModeRes::_internal_mutable_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* SetAutoModeRes::release_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SetAutoModeRes.msg)
  return _impl_.msg_.Release();
}
inline void SetAutoModeRes::set_allocated_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SetAutoModeRes.msg)
}

// -------------------------------------------------------------------

// CheckAutoModeRes

// bool on = 1;
inline void CheckAutoModeRes::clear_on() {
  _impl_.on_ = false;
}
inline bool CheckAutoModeRes::on() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckAutoModeRes.on)
  return _internal_on();
}
inline void CheckAutoModeRes::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckAutoModeRes.on)
}
inline bool CheckAutoModeRes::_internal_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.on_;
}
inline void CheckAutoModeRes::_internal_set_on(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_ = value;
}

// string msg = 100;
inline void CheckAutoModeRes::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& CheckAutoModeRes::msg() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckAutoModeRes.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckAutoModeRes::set_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckAutoModeRes.msg)
}
inline std::string* CheckAutoModeRes::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.CheckAutoModeRes.msg)
  return _s;
}
inline const std::string& CheckAutoModeRes::_internal_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msg_.Get();
}
inline void CheckAutoModeRes::_internal_set_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckAutoModeRes::_internal_mutable_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* CheckAutoModeRes::release_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.CheckAutoModeRes.msg)
  return _impl_.msg_.Release();
}
inline void CheckAutoModeRes::set_allocated_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.CheckAutoModeRes.msg)
}

// -------------------------------------------------------------------

// CheckReducedModeRes

// bool on = 1;
inline void CheckReducedModeRes::clear_on() {
  _impl_.on_ = false;
}
inline bool CheckReducedModeRes::on() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckReducedModeRes.on)
  return _internal_on();
}
inline void CheckReducedModeRes::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckReducedModeRes.on)
}
inline bool CheckReducedModeRes::_internal_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.on_;
}
inline void CheckReducedModeRes::_internal_set_on(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_ = value;
}

// string msg = 100;
inline void CheckReducedModeRes::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& CheckReducedModeRes::msg() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckReducedModeRes.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckReducedModeRes::set_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckReducedModeRes.msg)
}
inline std::string* CheckReducedModeRes::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.CheckReducedModeRes.msg)
  return _s;
}
inline const std::string& CheckReducedModeRes::_internal_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msg_.Get();
}
inline void CheckReducedModeRes::_internal_set_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckReducedModeRes::_internal_mutable_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* CheckReducedModeRes::release_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.CheckReducedModeRes.msg)
  return _impl_.msg_.Release();
}
inline void CheckReducedModeRes::set_allocated_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.CheckReducedModeRes.msg)
}

// -------------------------------------------------------------------

// SafetyFunctionState

// uint32 id = 1;
inline void SafetyFunctionState::clear_id() {
  _impl_.id_ = 0u;
}
inline ::uint32_t SafetyFunctionState::id() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyFunctionState.id)
  return _internal_id();
}
inline void SafetyFunctionState::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyFunctionState.id)
}
inline ::uint32_t SafetyFunctionState::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SafetyFunctionState::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// uint32 state = 2;
inline void SafetyFunctionState::clear_state() {
  _impl_.state_ = 0u;
}
inline ::uint32_t SafetyFunctionState::state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyFunctionState.state)
  return _internal_state();
}
inline void SafetyFunctionState::set_state(::uint32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyFunctionState.state)
}
inline ::uint32_t SafetyFunctionState::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void SafetyFunctionState::_internal_set_state(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool SafetyFunctionState::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Response& SafetyFunctionState::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Response&>(::Nrmk::IndyFramework::_Response_default_instance_);
}
inline const ::Nrmk::IndyFramework::Response& SafetyFunctionState::response() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyFunctionState.response)
  return _internal_response();
}
inline void SafetyFunctionState::unsafe_arena_set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.SafetyFunctionState.response)
}
inline ::Nrmk::IndyFramework::Response* SafetyFunctionState::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Response* SafetyFunctionState::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SafetyFunctionState.response)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* SafetyFunctionState::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaForAllocation());
    _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(p);
  }
  return _impl_.response_;
}
inline ::Nrmk::IndyFramework::Response* SafetyFunctionState::mutable_response() {
  ::Nrmk::IndyFramework::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SafetyFunctionState.response)
  return _msg;
}
inline void SafetyFunctionState::set_allocated_response(::Nrmk::IndyFramework::Response* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_ = reinterpret_cast<::Nrmk::IndyFramework::Response*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SafetyFunctionState.response)
}

// -------------------------------------------------------------------

// SafetyControlData

// bool auto_mode = 1;
inline void SafetyControlData::clear_auto_mode() {
  _impl_.auto_mode_ = false;
}
inline bool SafetyControlData::auto_mode() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.auto_mode)
  return _internal_auto_mode();
}
inline void SafetyControlData::set_auto_mode(bool value) {
  _internal_set_auto_mode(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyControlData.auto_mode)
}
inline bool SafetyControlData::_internal_auto_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.auto_mode_;
}
inline void SafetyControlData::_internal_set_auto_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.auto_mode_ = value;
}

// bool reduced_mode = 2;
inline void SafetyControlData::clear_reduced_mode() {
  _impl_.reduced_mode_ = false;
}
inline bool SafetyControlData::reduced_mode() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.reduced_mode)
  return _internal_reduced_mode();
}
inline void SafetyControlData::set_reduced_mode(bool value) {
  _internal_set_reduced_mode(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyControlData.reduced_mode)
}
inline bool SafetyControlData::_internal_reduced_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reduced_mode_;
}
inline void SafetyControlData::_internal_set_reduced_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reduced_mode_ = value;
}

// bool enabler_pressed = 3;
inline void SafetyControlData::clear_enabler_pressed() {
  _impl_.enabler_pressed_ = false;
}
inline bool SafetyControlData::enabler_pressed() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.enabler_pressed)
  return _internal_enabler_pressed();
}
inline void SafetyControlData::set_enabler_pressed(bool value) {
  _internal_set_enabler_pressed(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyControlData.enabler_pressed)
}
inline bool SafetyControlData::_internal_enabler_pressed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabler_pressed_;
}
inline void SafetyControlData::_internal_set_enabler_pressed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabler_pressed_ = value;
}

// .Nrmk.IndyFramework.SafetyFunctionState safety_state = 5;
inline bool SafetyControlData::has_safety_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.safety_state_ != nullptr);
  return value;
}
inline void SafetyControlData::clear_safety_state() {
  if (_impl_.safety_state_ != nullptr) _impl_.safety_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Nrmk::IndyFramework::SafetyFunctionState& SafetyControlData::_internal_safety_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::SafetyFunctionState* p = _impl_.safety_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::SafetyFunctionState&>(::Nrmk::IndyFramework::_SafetyFunctionState_default_instance_);
}
inline const ::Nrmk::IndyFramework::SafetyFunctionState& SafetyControlData::safety_state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.safety_state)
  return _internal_safety_state();
}
inline void SafetyControlData::unsafe_arena_set_allocated_safety_state(::Nrmk::IndyFramework::SafetyFunctionState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.safety_state_);
  }
  _impl_.safety_state_ = reinterpret_cast<::Nrmk::IndyFramework::SafetyFunctionState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.SafetyControlData.safety_state)
}
inline ::Nrmk::IndyFramework::SafetyFunctionState* SafetyControlData::release_safety_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::SafetyFunctionState* released = _impl_.safety_state_;
  _impl_.safety_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::SafetyFunctionState* SafetyControlData::unsafe_arena_release_safety_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SafetyControlData.safety_state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::SafetyFunctionState* temp = _impl_.safety_state_;
  _impl_.safety_state_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::SafetyFunctionState* SafetyControlData::_internal_mutable_safety_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.safety_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::SafetyFunctionState>(GetArenaForAllocation());
    _impl_.safety_state_ = reinterpret_cast<::Nrmk::IndyFramework::SafetyFunctionState*>(p);
  }
  return _impl_.safety_state_;
}
inline ::Nrmk::IndyFramework::SafetyFunctionState* SafetyControlData::mutable_safety_state() {
  ::Nrmk::IndyFramework::SafetyFunctionState* _msg = _internal_mutable_safety_state();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SafetyControlData.safety_state)
  return _msg;
}
inline void SafetyControlData::set_allocated_safety_state(::Nrmk::IndyFramework::SafetyFunctionState* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Nrmk::IndyFramework::SafetyFunctionState*>(_impl_.safety_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::Nrmk::IndyFramework::SafetyFunctionState*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.safety_state_ = reinterpret_cast<::Nrmk::IndyFramework::SafetyFunctionState*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SafetyControlData.safety_state)
}

// -------------------------------------------------------------------

// SanderCommand

// .Nrmk.IndyFramework.SanderCommand.SanderType type = 1;
inline void SanderCommand::clear_type() {
  _impl_.type_ = 0;
}
inline ::Nrmk::IndyFramework::SanderCommand_SanderType SanderCommand::type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.type)
  return _internal_type();
}
inline void SanderCommand::set_type(::Nrmk::IndyFramework::SanderCommand_SanderType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.type)
}
inline ::Nrmk::IndyFramework::SanderCommand_SanderType SanderCommand::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::SanderCommand_SanderType>(_impl_.type_);
}
inline void SanderCommand::_internal_set_type(::Nrmk::IndyFramework::SanderCommand_SanderType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string ip = 2;
inline void SanderCommand::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& SanderCommand::ip() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SanderCommand::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.ip)
}
inline std::string* SanderCommand::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SanderCommand.ip)
  return _s;
}
inline const std::string& SanderCommand::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void SanderCommand::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* SanderCommand::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* SanderCommand::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SanderCommand.ip)
  return _impl_.ip_.Release();
}
inline void SanderCommand::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SanderCommand.ip)
}

// float speed = 3;
inline void SanderCommand::clear_speed() {
  _impl_.speed_ = 0;
}
inline float SanderCommand::speed() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.speed)
  return _internal_speed();
}
inline void SanderCommand::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.speed)
}
inline float SanderCommand::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void SanderCommand::_internal_set_speed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.speed_ = value;
}

// bool state = 10;
inline void SanderCommand::clear_state() {
  _impl_.state_ = false;
}
inline bool SanderCommand::state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.state)
  return _internal_state();
}
inline void SanderCommand::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.state)
}
inline bool SanderCommand::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void SanderCommand::_internal_set_state(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// Encoder

// .Nrmk.IndyFramework.Encoder.EncoderType type = 1;
inline void Encoder::clear_type() {
  _impl_.type_ = 0;
}
inline ::Nrmk::IndyFramework::Encoder_EncoderType Encoder::type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.type)
  return _internal_type();
}
inline void Encoder::set_type(::Nrmk::IndyFramework::Encoder_EncoderType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.type)
}
inline ::Nrmk::IndyFramework::Encoder_EncoderType Encoder::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::Encoder_EncoderType>(_impl_.type_);
}
inline void Encoder::_internal_set_type(::Nrmk::IndyFramework::Encoder_EncoderType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// int64 channel1 = 2;
inline void Encoder::clear_channel1() {
  _impl_.channel1_ = ::int64_t{0};
}
inline ::int64_t Encoder::channel1() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.channel1)
  return _internal_channel1();
}
inline void Encoder::set_channel1(::int64_t value) {
  _internal_set_channel1(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.channel1)
}
inline ::int64_t Encoder::_internal_channel1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel1_;
}
inline void Encoder::_internal_set_channel1(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel1_ = value;
}

// int64 channel2 = 3;
inline void Encoder::clear_channel2() {
  _impl_.channel2_ = ::int64_t{0};
}
inline ::int64_t Encoder::channel2() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.channel2)
  return _internal_channel2();
}
inline void Encoder::set_channel2(::int64_t value) {
  _internal_set_channel2(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.channel2)
}
inline ::int64_t Encoder::_internal_channel2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel2_;
}
inline void Encoder::_internal_set_channel2(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel2_ = value;
}

// int64 sample_num = 4;
inline void Encoder::clear_sample_num() {
  _impl_.sample_num_ = ::int64_t{0};
}
inline ::int64_t Encoder::sample_num() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.sample_num)
  return _internal_sample_num();
}
inline void Encoder::set_sample_num(::int64_t value) {
  _internal_set_sample_num(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.sample_num)
}
inline ::int64_t Encoder::_internal_sample_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_num_;
}
inline void Encoder::_internal_set_sample_num(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_num_ = value;
}

// float mm_per_tick = 5;
inline void Encoder::clear_mm_per_tick() {
  _impl_.mm_per_tick_ = 0;
}
inline float Encoder::mm_per_tick() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.mm_per_tick)
  return _internal_mm_per_tick();
}
inline void Encoder::set_mm_per_tick(float value) {
  _internal_set_mm_per_tick(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.mm_per_tick)
}
inline float Encoder::_internal_mm_per_tick() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mm_per_tick_;
}
inline void Encoder::_internal_set_mm_per_tick(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mm_per_tick_ = value;
}

// float vel_const_mmps = 6;
inline void Encoder::clear_vel_const_mmps() {
  _impl_.vel_const_mmps_ = 0;
}
inline float Encoder::vel_const_mmps() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.vel_const_mmps)
  return _internal_vel_const_mmps();
}
inline void Encoder::set_vel_const_mmps(float value) {
  _internal_set_vel_const_mmps(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.vel_const_mmps)
}
inline float Encoder::_internal_vel_const_mmps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vel_const_mmps_;
}
inline void Encoder::_internal_set_vel_const_mmps(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vel_const_mmps_ = value;
}

// bool reversed = 7;
inline void Encoder::clear_reversed() {
  _impl_.reversed_ = false;
}
inline bool Encoder::reversed() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.reversed)
  return _internal_reversed();
}
inline void Encoder::set_reversed(bool value) {
  _internal_set_reversed(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.reversed)
}
inline bool Encoder::_internal_reversed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reversed_;
}
inline void Encoder::_internal_set_reversed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reversed_ = value;
}

// -------------------------------------------------------------------

// Trigger

// .Nrmk.IndyFramework.Trigger.TriggerType type = 1;
inline void Trigger::clear_type() {
  _impl_.type_ = 0;
}
inline ::Nrmk::IndyFramework::Trigger_TriggerType Trigger::type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Trigger.type)
  return _internal_type();
}
inline void Trigger::set_type(::Nrmk::IndyFramework::Trigger_TriggerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Trigger.type)
}
inline ::Nrmk::IndyFramework::Trigger_TriggerType Trigger::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::Trigger_TriggerType>(_impl_.type_);
}
inline void Trigger::_internal_set_type(::Nrmk::IndyFramework::Trigger_TriggerType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// int64 channel = 2;
inline void Trigger::clear_channel() {
  _impl_.channel_ = ::int64_t{0};
}
inline ::int64_t Trigger::channel() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Trigger.channel)
  return _internal_channel();
}
inline void Trigger::set_channel(::int64_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Trigger.channel)
}
inline ::int64_t Trigger::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_;
}
inline void Trigger::_internal_set_channel(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_ = value;
}

// bool detect_rise = 3;
inline void Trigger::clear_detect_rise() {
  _impl_.detect_rise_ = false;
}
inline bool Trigger::detect_rise() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Trigger.detect_rise)
  return _internal_detect_rise();
}
inline void Trigger::set_detect_rise(bool value) {
  _internal_set_detect_rise(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Trigger.detect_rise)
}
inline bool Trigger::_internal_detect_rise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.detect_rise_;
}
inline void Trigger::_internal_set_detect_rise(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.detect_rise_ = value;
}

// -------------------------------------------------------------------

// Conveyor

// string name = 1;
inline void Conveyor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Conveyor::name() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Conveyor::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Conveyor.name)
}
inline std::string* Conveyor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.name)
  return _s;
}
inline const std::string& Conveyor::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Conveyor::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Conveyor::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Conveyor::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.name)
  return _impl_.name_.Release();
}
inline void Conveyor::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.name)
}

// .Nrmk.IndyFramework.Encoder encoder = 2;
inline bool Conveyor::has_encoder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.encoder_ != nullptr);
  return value;
}
inline void Conveyor::clear_encoder() {
  if (_impl_.encoder_ != nullptr) _impl_.encoder_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Nrmk::IndyFramework::Encoder& Conveyor::_internal_encoder() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Encoder* p = _impl_.encoder_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Encoder&>(::Nrmk::IndyFramework::_Encoder_default_instance_);
}
inline const ::Nrmk::IndyFramework::Encoder& Conveyor::encoder() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.encoder)
  return _internal_encoder();
}
inline void Conveyor::unsafe_arena_set_allocated_encoder(::Nrmk::IndyFramework::Encoder* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.encoder_);
  }
  _impl_.encoder_ = reinterpret_cast<::Nrmk::IndyFramework::Encoder*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.Conveyor.encoder)
}
inline ::Nrmk::IndyFramework::Encoder* Conveyor::release_encoder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Encoder* released = _impl_.encoder_;
  _impl_.encoder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Encoder* Conveyor::unsafe_arena_release_encoder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.encoder)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::Encoder* temp = _impl_.encoder_;
  _impl_.encoder_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Encoder* Conveyor::_internal_mutable_encoder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.encoder_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Encoder>(GetArenaForAllocation());
    _impl_.encoder_ = reinterpret_cast<::Nrmk::IndyFramework::Encoder*>(p);
  }
  return _impl_.encoder_;
}
inline ::Nrmk::IndyFramework::Encoder* Conveyor::mutable_encoder() {
  ::Nrmk::IndyFramework::Encoder* _msg = _internal_mutable_encoder();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.encoder)
  return _msg;
}
inline void Conveyor::set_allocated_encoder(::Nrmk::IndyFramework::Encoder* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Nrmk::IndyFramework::Encoder*>(_impl_.encoder_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::Nrmk::IndyFramework::Encoder*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.encoder_ = reinterpret_cast<::Nrmk::IndyFramework::Encoder*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.encoder)
}

// .Nrmk.IndyFramework.Trigger trigger = 3;
inline bool Conveyor::has_trigger() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trigger_ != nullptr);
  return value;
}
inline void Conveyor::clear_trigger() {
  if (_impl_.trigger_ != nullptr) _impl_.trigger_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Nrmk::IndyFramework::Trigger& Conveyor::_internal_trigger() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Trigger* p = _impl_.trigger_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Trigger&>(::Nrmk::IndyFramework::_Trigger_default_instance_);
}
inline const ::Nrmk::IndyFramework::Trigger& Conveyor::trigger() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.trigger)
  return _internal_trigger();
}
inline void Conveyor::unsafe_arena_set_allocated_trigger(::Nrmk::IndyFramework::Trigger* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trigger_);
  }
  _impl_.trigger_ = reinterpret_cast<::Nrmk::IndyFramework::Trigger*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.Conveyor.trigger)
}
inline ::Nrmk::IndyFramework::Trigger* Conveyor::release_trigger() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Nrmk::IndyFramework::Trigger* released = _impl_.trigger_;
  _impl_.trigger_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Trigger* Conveyor::unsafe_arena_release_trigger() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.trigger)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Nrmk::IndyFramework::Trigger* temp = _impl_.trigger_;
  _impl_.trigger_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Trigger* Conveyor::_internal_mutable_trigger() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trigger_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Trigger>(GetArenaForAllocation());
    _impl_.trigger_ = reinterpret_cast<::Nrmk::IndyFramework::Trigger*>(p);
  }
  return _impl_.trigger_;
}
inline ::Nrmk::IndyFramework::Trigger* Conveyor::mutable_trigger() {
  ::Nrmk::IndyFramework::Trigger* _msg = _internal_mutable_trigger();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.trigger)
  return _msg;
}
inline void Conveyor::set_allocated_trigger(::Nrmk::IndyFramework::Trigger* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Nrmk::IndyFramework::Trigger*>(_impl_.trigger_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::Nrmk::IndyFramework::Trigger*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.trigger_ = reinterpret_cast<::Nrmk::IndyFramework::Trigger*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.trigger)
}

// float offset_dist = 4;
inline void Conveyor::clear_offset_dist() {
  _impl_.offset_dist_ = 0;
}
inline float Conveyor::offset_dist() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.offset_dist)
  return _internal_offset_dist();
}
inline void Conveyor::set_offset_dist(float value) {
  _internal_set_offset_dist(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Conveyor.offset_dist)
}
inline float Conveyor::_internal_offset_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_dist_;
}
inline void Conveyor::_internal_set_offset_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_dist_ = value;
}

// float working_dist = 5;
inline void Conveyor::clear_working_dist() {
  _impl_.working_dist_ = 0;
}
inline float Conveyor::working_dist() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.working_dist)
  return _internal_working_dist();
}
inline void Conveyor::set_working_dist(float value) {
  _internal_set_working_dist(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Conveyor.working_dist)
}
inline float Conveyor::_internal_working_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.working_dist_;
}
inline void Conveyor::_internal_set_working_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.working_dist_ = value;
}

// .Nrmk.IndyFramework.Vector direction = 6;
inline bool Conveyor::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.direction_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::Vector& Conveyor::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::Vector* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::Vector&>(::Nrmk::IndyFramework::_Vector_default_instance_);
}
inline const ::Nrmk::IndyFramework::Vector& Conveyor::direction() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.direction)
  return _internal_direction();
}
inline void Conveyor::unsafe_arena_set_allocated_direction(::Nrmk::IndyFramework::Vector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = reinterpret_cast<::Nrmk::IndyFramework::Vector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.Conveyor.direction)
}
inline ::Nrmk::IndyFramework::Vector* Conveyor::release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Nrmk::IndyFramework::Vector* released = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::Vector* Conveyor::unsafe_arena_release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.direction)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Nrmk::IndyFramework::Vector* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Vector* Conveyor::_internal_mutable_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Vector>(GetArenaForAllocation());
    _impl_.direction_ = reinterpret_cast<::Nrmk::IndyFramework::Vector*>(p);
  }
  return _impl_.direction_;
}
inline ::Nrmk::IndyFramework::Vector* Conveyor::mutable_direction() {
  ::Nrmk::IndyFramework::Vector* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.direction)
  return _msg;
}
inline void Conveyor::set_allocated_direction(::Nrmk::IndyFramework::Vector* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.direction_ = reinterpret_cast<::Nrmk::IndyFramework::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.direction)
}

// .Nrmk.IndyFramework.PosePair starting_pose = 10;
inline bool Conveyor::has_starting_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starting_pose_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::PosePair& Conveyor::_internal_starting_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::PosePair* p = _impl_.starting_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::PosePair&>(::Nrmk::IndyFramework::_PosePair_default_instance_);
}
inline const ::Nrmk::IndyFramework::PosePair& Conveyor::starting_pose() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.starting_pose)
  return _internal_starting_pose();
}
inline void Conveyor::unsafe_arena_set_allocated_starting_pose(::Nrmk::IndyFramework::PosePair* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starting_pose_);
  }
  _impl_.starting_pose_ = reinterpret_cast<::Nrmk::IndyFramework::PosePair*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.Conveyor.starting_pose)
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::release_starting_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Nrmk::IndyFramework::PosePair* released = _impl_.starting_pose_;
  _impl_.starting_pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::unsafe_arena_release_starting_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.starting_pose)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Nrmk::IndyFramework::PosePair* temp = _impl_.starting_pose_;
  _impl_.starting_pose_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::_internal_mutable_starting_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.starting_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::PosePair>(GetArenaForAllocation());
    _impl_.starting_pose_ = reinterpret_cast<::Nrmk::IndyFramework::PosePair*>(p);
  }
  return _impl_.starting_pose_;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::mutable_starting_pose() {
  ::Nrmk::IndyFramework::PosePair* _msg = _internal_mutable_starting_pose();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.starting_pose)
  return _msg;
}
inline void Conveyor::set_allocated_starting_pose(::Nrmk::IndyFramework::PosePair* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starting_pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.starting_pose_ = reinterpret_cast<::Nrmk::IndyFramework::PosePair*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.starting_pose)
}

// .Nrmk.IndyFramework.PosePair terminal_pose = 11;
inline bool Conveyor::has_terminal_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.terminal_pose_ != nullptr);
  return value;
}
inline const ::Nrmk::IndyFramework::PosePair& Conveyor::_internal_terminal_pose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::PosePair* p = _impl_.terminal_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::PosePair&>(::Nrmk::IndyFramework::_PosePair_default_instance_);
}
inline const ::Nrmk::IndyFramework::PosePair& Conveyor::terminal_pose() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.terminal_pose)
  return _internal_terminal_pose();
}
inline void Conveyor::unsafe_arena_set_allocated_terminal_pose(::Nrmk::IndyFramework::PosePair* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.terminal_pose_);
  }
  _impl_.terminal_pose_ = reinterpret_cast<::Nrmk::IndyFramework::PosePair*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.Conveyor.terminal_pose)
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::release_terminal_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Nrmk::IndyFramework::PosePair* released = _impl_.terminal_pose_;
  _impl_.terminal_pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::unsafe_arena_release_terminal_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.terminal_pose)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Nrmk::IndyFramework::PosePair* temp = _impl_.terminal_pose_;
  _impl_.terminal_pose_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::_internal_mutable_terminal_pose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.terminal_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::PosePair>(GetArenaForAllocation());
    _impl_.terminal_pose_ = reinterpret_cast<::Nrmk::IndyFramework::PosePair*>(p);
  }
  return _impl_.terminal_pose_;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::mutable_terminal_pose() {
  ::Nrmk::IndyFramework::PosePair* _msg = _internal_mutable_terminal_pose();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.terminal_pose)
  return _msg;
}
inline void Conveyor::set_allocated_terminal_pose(::Nrmk::IndyFramework::PosePair* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.terminal_pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.terminal_pose_ = reinterpret_cast<::Nrmk::IndyFramework::PosePair*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.terminal_pose)
}

// -------------------------------------------------------------------

// ConveyorState

// float velocity = 1;
inline void ConveyorState::clear_velocity() {
  _impl_.velocity_ = 0;
}
inline float ConveyorState::velocity() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.ConveyorState.velocity)
  return _internal_velocity();
}
inline void ConveyorState::set_velocity(float value) {
  _internal_set_velocity(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.ConveyorState.velocity)
}
inline float ConveyorState::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.velocity_;
}
inline void ConveyorState::_internal_set_velocity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.velocity_ = value;
}

// float triggered = 2;
inline void ConveyorState::clear_triggered() {
  _impl_.triggered_ = 0;
}
inline float ConveyorState::triggered() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.ConveyorState.triggered)
  return _internal_triggered();
}
inline void ConveyorState::set_triggered(float value) {
  _internal_set_triggered(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.ConveyorState.triggered)
}
inline float ConveyorState::_internal_triggered() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.triggered_;
}
inline void ConveyorState::_internal_set_triggered(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.triggered_ = value;
}

// -------------------------------------------------------------------

// AddPhotoneoCalibPointReq

// string vision_name = 1;
inline void AddPhotoneoCalibPointReq::clear_vision_name() {
  _impl_.vision_name_.ClearToEmpty();
}
inline const std::string& AddPhotoneoCalibPointReq::vision_name() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.vision_name)
  return _internal_vision_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddPhotoneoCalibPointReq::set_vision_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vision_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.vision_name)
}
inline std::string* AddPhotoneoCalibPointReq::mutable_vision_name() {
  std::string* _s = _internal_mutable_vision_name();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.vision_name)
  return _s;
}
inline const std::string& AddPhotoneoCalibPointReq::_internal_vision_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vision_name_.Get();
}
inline void AddPhotoneoCalibPointReq::_internal_set_vision_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vision_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddPhotoneoCalibPointReq::_internal_mutable_vision_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.vision_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AddPhotoneoCalibPointReq::release_vision_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.vision_name)
  return _impl_.vision_name_.Release();
}
inline void AddPhotoneoCalibPointReq::set_allocated_vision_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vision_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vision_name_.IsDefault()) {
          _impl_.vision_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.vision_name)
}

// double px = 2;
inline void AddPhotoneoCalibPointReq::clear_px() {
  _impl_.px_ = 0;
}
inline double AddPhotoneoCalibPointReq::px() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.px)
  return _internal_px();
}
inline void AddPhotoneoCalibPointReq::set_px(double value) {
  _internal_set_px(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.px)
}
inline double AddPhotoneoCalibPointReq::_internal_px() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.px_;
}
inline void AddPhotoneoCalibPointReq::_internal_set_px(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.px_ = value;
}

// double py = 3;
inline void AddPhotoneoCalibPointReq::clear_py() {
  _impl_.py_ = 0;
}
inline double AddPhotoneoCalibPointReq::py() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.py)
  return _internal_py();
}
inline void AddPhotoneoCalibPointReq::set_py(double value) {
  _internal_set_py(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.py)
}
inline double AddPhotoneoCalibPointReq::_internal_py() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.py_;
}
inline void AddPhotoneoCalibPointReq::_internal_set_py(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.py_ = value;
}

// double pz = 4;
inline void AddPhotoneoCalibPointReq::clear_pz() {
  _impl_.pz_ = 0;
}
inline double AddPhotoneoCalibPointReq::pz() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.pz)
  return _internal_pz();
}
inline void AddPhotoneoCalibPointReq::set_pz(double value) {
  _internal_set_pz(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AddPhotoneoCalibPointReq.pz)
}
inline double AddPhotoneoCalibPointReq::_internal_pz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pz_;
}
inline void AddPhotoneoCalibPointReq::_internal_set_pz(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pz_ = value;
}

// -------------------------------------------------------------------

// VisionServer

// string name = 1;
inline void VisionServer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& VisionServer::name() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionServer.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionServer::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionServer.name)
}
inline std::string* VisionServer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.VisionServer.name)
  return _s;
}
inline const std::string& VisionServer::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void VisionServer::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionServer::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* VisionServer::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.VisionServer.name)
  return _impl_.name_.Release();
}
inline void VisionServer::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.VisionServer.name)
}

// .Nrmk.IndyFramework.VisionServer.VisionServerType vision_server_type = 2;
inline void VisionServer::clear_vision_server_type() {
  _impl_.vision_server_type_ = 0;
}
inline ::Nrmk::IndyFramework::VisionServer_VisionServerType VisionServer::vision_server_type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionServer.vision_server_type)
  return _internal_vision_server_type();
}
inline void VisionServer::set_vision_server_type(::Nrmk::IndyFramework::VisionServer_VisionServerType value) {
  _internal_set_vision_server_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionServer.vision_server_type)
}
inline ::Nrmk::IndyFramework::VisionServer_VisionServerType VisionServer::_internal_vision_server_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::VisionServer_VisionServerType>(_impl_.vision_server_type_);
}
inline void VisionServer::_internal_set_vision_server_type(::Nrmk::IndyFramework::VisionServer_VisionServerType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vision_server_type_ = value;
}

// string ip = 3;
inline void VisionServer::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& VisionServer::ip() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionServer.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionServer::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionServer.ip)
}
inline std::string* VisionServer::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.VisionServer.ip)
  return _s;
}
inline const std::string& VisionServer::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void VisionServer::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionServer::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* VisionServer::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.VisionServer.ip)
  return _impl_.ip_.Release();
}
inline void VisionServer::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.VisionServer.ip)
}

// uint32 port = 4;
inline void VisionServer::clear_port() {
  _impl_.port_ = 0u;
}
inline ::uint32_t VisionServer::port() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionServer.port)
  return _internal_port();
}
inline void VisionServer::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionServer.port)
}
inline ::uint32_t VisionServer::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void VisionServer::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// VisionRequest

// .Nrmk.IndyFramework.VisionServer vision_server = 1;
inline bool VisionRequest::has_vision_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vision_server_ != nullptr);
  return value;
}
inline void VisionRequest::clear_vision_server() {
  if (_impl_.vision_server_ != nullptr) _impl_.vision_server_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Nrmk::IndyFramework::VisionServer& VisionRequest::_internal_vision_server() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Nrmk::IndyFramework::VisionServer* p = _impl_.vision_server_;
  return p != nullptr ? *p : reinterpret_cast<const ::Nrmk::IndyFramework::VisionServer&>(::Nrmk::IndyFramework::_VisionServer_default_instance_);
}
inline const ::Nrmk::IndyFramework::VisionServer& VisionRequest::vision_server() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionRequest.vision_server)
  return _internal_vision_server();
}
inline void VisionRequest::unsafe_arena_set_allocated_vision_server(::Nrmk::IndyFramework::VisionServer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vision_server_);
  }
  _impl_.vision_server_ = reinterpret_cast<::Nrmk::IndyFramework::VisionServer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Nrmk.IndyFramework.VisionRequest.vision_server)
}
inline ::Nrmk::IndyFramework::VisionServer* VisionRequest::release_vision_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::VisionServer* released = _impl_.vision_server_;
  _impl_.vision_server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Nrmk::IndyFramework::VisionServer* VisionRequest::unsafe_arena_release_vision_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.VisionRequest.vision_server)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Nrmk::IndyFramework::VisionServer* temp = _impl_.vision_server_;
  _impl_.vision_server_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::VisionServer* VisionRequest::_internal_mutable_vision_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vision_server_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::VisionServer>(GetArenaForAllocation());
    _impl_.vision_server_ = reinterpret_cast<::Nrmk::IndyFramework::VisionServer*>(p);
  }
  return _impl_.vision_server_;
}
inline ::Nrmk::IndyFramework::VisionServer* VisionRequest::mutable_vision_server() {
  ::Nrmk::IndyFramework::VisionServer* _msg = _internal_mutable_vision_server();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.VisionRequest.vision_server)
  return _msg;
}
inline void VisionRequest::set_allocated_vision_server(::Nrmk::IndyFramework::VisionServer* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Nrmk::IndyFramework::VisionServer*>(_impl_.vision_server_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::Nrmk::IndyFramework::VisionServer*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.vision_server_ = reinterpret_cast<::Nrmk::IndyFramework::VisionServer*>(value);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.VisionRequest.vision_server)
}

// string object = 2;
inline void VisionRequest::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& VisionRequest::object() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionRequest.object)
  return _internal_object();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionRequest::set_object(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionRequest.object)
}
inline std::string* VisionRequest::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.VisionRequest.object)
  return _s;
}
inline const std::string& VisionRequest::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.object_.Get();
}
inline void VisionRequest::_internal_set_object(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionRequest::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.object_.Mutable( GetArenaForAllocation());
}
inline std::string* VisionRequest::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.VisionRequest.object)
  return _impl_.object_.Release();
}
inline void VisionRequest::set_allocated_object(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.object_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_.IsDefault()) {
          _impl_.object_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.VisionRequest.object)
}

// .Nrmk.IndyFramework.VisionFrameType frame_type = 3;
inline void VisionRequest::clear_frame_type() {
  _impl_.frame_type_ = 0;
}
inline ::Nrmk::IndyFramework::VisionFrameType VisionRequest::frame_type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionRequest.frame_type)
  return _internal_frame_type();
}
inline void VisionRequest::set_frame_type(::Nrmk::IndyFramework::VisionFrameType value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionRequest.frame_type)
}
inline ::Nrmk::IndyFramework::VisionFrameType VisionRequest::_internal_frame_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::VisionFrameType>(_impl_.frame_type_);
}
inline void VisionRequest::_internal_set_frame_type(::Nrmk::IndyFramework::VisionFrameType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_type_ = value;
}

// -------------------------------------------------------------------

// VisionResult

// repeated float frame = 1;
inline int VisionResult::_internal_frame_size() const {
  return _internal_frame().size();
}
inline int VisionResult::frame_size() const {
  return _internal_frame_size();
}
inline void VisionResult::clear_frame() {
  _internal_mutable_frame()->Clear();
}
inline float VisionResult::frame(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionResult.frame)
  return _internal_frame().Get(index);
}
inline void VisionResult::set_frame(int index, float value) {
  _internal_mutable_frame()->Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionResult.frame)
}
inline void VisionResult::add_frame(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_frame()->Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.VisionResult.frame)
}
inline const ::google::protobuf::RepeatedField<float>& VisionResult::frame() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.VisionResult.frame)
  return _internal_frame();
}
inline ::google::protobuf::RepeatedField<float>* VisionResult::mutable_frame() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.VisionResult.frame)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_frame();
}

inline const ::google::protobuf::RepeatedField<float>& VisionResult::_internal_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_;
}
inline ::google::protobuf::RepeatedField<float>* VisionResult::_internal_mutable_frame() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.frame_;
}

// .Nrmk.IndyFramework.VisionFrameType frame_type = 2;
inline void VisionResult::clear_frame_type() {
  _impl_.frame_type_ = 0;
}
inline ::Nrmk::IndyFramework::VisionFrameType VisionResult::frame_type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionResult.frame_type)
  return _internal_frame_type();
}
inline void VisionResult::set_frame_type(::Nrmk::IndyFramework::VisionFrameType value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionResult.frame_type)
}
inline ::Nrmk::IndyFramework::VisionFrameType VisionResult::_internal_frame_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Nrmk::IndyFramework::VisionFrameType>(_impl_.frame_type_);
}
inline void VisionResult::_internal_set_frame_type(::Nrmk::IndyFramework::VisionFrameType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_type_ = value;
}

// string object = 3;
inline void VisionResult::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& VisionResult::object() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionResult.object)
  return _internal_object();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionResult::set_object(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionResult.object)
}
inline std::string* VisionResult::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.VisionResult.object)
  return _s;
}
inline const std::string& VisionResult::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.object_.Get();
}
inline void VisionResult::_internal_set_object(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionResult::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.object_.Mutable( GetArenaForAllocation());
}
inline std::string* VisionResult::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.VisionResult.object)
  return _impl_.object_.Release();
}
inline void VisionResult::set_allocated_object(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.object_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_.IsDefault()) {
          _impl_.object_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.VisionResult.object)
}

// bool detected = 4;
inline void VisionResult::clear_detected() {
  _impl_.detected_ = false;
}
inline bool VisionResult::detected() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionResult.detected)
  return _internal_detected();
}
inline void VisionResult::set_detected(bool value) {
  _internal_set_detected(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionResult.detected)
}
inline bool VisionResult::_internal_detected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.detected_;
}
inline void VisionResult::_internal_set_detected(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.detected_ = value;
}

// bool passed = 5;
inline void VisionResult::clear_passed() {
  _impl_.passed_ = false;
}
inline bool VisionResult::passed() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionResult.passed)
  return _internal_passed();
}
inline void VisionResult::set_passed(bool value) {
  _internal_set_passed(value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionResult.passed)
}
inline bool VisionResult::_internal_passed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passed_;
}
inline void VisionResult::_internal_set_passed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.passed_ = value;
}

// string msg = 100;
inline void VisionResult::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& VisionResult::msg() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.VisionResult.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionResult::set_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.VisionResult.msg)
}
inline std::string* VisionResult::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.VisionResult.msg)
  return _s;
}
inline const std::string& VisionResult::_internal_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msg_.Get();
}
inline void VisionResult::_internal_set_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionResult::_internal_mutable_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* VisionResult::release_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.VisionResult.msg)
  return _impl_.msg_.Release();
}
inline void VisionResult::set_allocated_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.VisionResult.msg)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace IndyFramework
}  // namespace Nrmk


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::Nrmk::IndyFramework::GripperCommand_GripperCommandType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::GripperCommand_GripperCommandType>() {
  return ::Nrmk::IndyFramework::GripperCommand_GripperCommandType_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle>() {
  return ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::SanderCommand_SanderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::SanderCommand_SanderType>() {
  return ::Nrmk::IndyFramework::SanderCommand_SanderType_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::Encoder_EncoderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::Encoder_EncoderType>() {
  return ::Nrmk::IndyFramework::Encoder_EncoderType_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::Trigger_TriggerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::Trigger_TriggerType>() {
  return ::Nrmk::IndyFramework::Trigger_TriggerType_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::VisionServer_VisionServerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::VisionServer_VisionServerType>() {
  return ::Nrmk::IndyFramework::VisionServer_VisionServerType_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::GripperType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::GripperType>() {
  return ::Nrmk::IndyFramework::GripperType_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::DigitalState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::DigitalState>() {
  return ::Nrmk::IndyFramework::DigitalState_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::EndtoolState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::EndtoolState>() {
  return ::Nrmk::IndyFramework::EndtoolState_descriptor();
}
template <>
struct is_proto_enum<::Nrmk::IndyFramework::VisionFrameType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Nrmk::IndyFramework::VisionFrameType>() {
  return ::Nrmk::IndyFramework::VisionFrameType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_device_5fmsgs_2eproto_2epb_2eh
