syntax = "proto3";
package Nrmk.IndyFramework;
import "common_msgs.proto";

//////////////////////////Motor/////////////////////////
message Motor {
  uint32 index = 1;
  bool enable = 2;
}

//////////////////////////Servo/////////////////////////
message Servo {
  uint32 index = 1;
  bool enable = 2;
}

//////////////////////////485Gripper/////////////////////////
enum GripperType{
  NONE              = 0;
  ROBOTIQ_GRIPPER   = 1;
  DH_GRIPPER        = 2;
}

message GripperData {
    GripperType gripper_type = 1;
    int32 gripper_position = 2;
    int32 gripper_state = 3;
}

message GripperCommand{
    enum GripperCommandType{
      AUTO_DETECT   = 0;
      ACTIVATE      = 1;
      RE_ACTIVATE   = 2;
      SET_PVT       = 3;
    }
    GripperCommandType gripper_command = 1;
    GripperType gripper_type = 2;
    repeated int32 gripper_pvt_data = 3;
}

//////////////////////////DigitalSignal/////////////////////////
message DigitalSignal {
  uint32 address = 1;
  DigitalState state = 2;
}

//////////////////////////DigitalState/////////////////////////
enum DigitalState {
  OFF_STATE = 0;
  ON_STATE = 1;
  UNUSED_STATE = 2;
}

//////////////////////////EndtoolState/////////////////////////
enum EndtoolState {
  UNUSED = 0;
  HIGH_PNP = 2;
  HIGH_NPN = 1;
  LOW_NPN = -1;
  LOW_PNP = -2;
}
message EndLedDim {
    uint32 led_dim = 1;
}
//enum EndToolPort {
//  PORT_C = 0;
//  PORT_B = 1;
//  PORT_A = 2;
//}

//////////////////////////DigitalSignal/////////////////////////
message EndtoolSignal {
  string port = 1;
  repeated EndtoolState states = 2;
}

//////////////////////////AnalogSignal/////////////////////////
message AnalogSignal {
  uint32 address = 1;
  int32 voltage = 2;
}

//////////////////////////MotorList/////////////////////////
message MotorList {
  repeated Motor motors = 1;
}

//////////////////////////DigitalList/////////////////////////
message DigitalList {
  repeated DigitalSignal signals = 1;
}

//////////////////////////EndtoolSignalList/////////////////////////
message EndtoolSignalList {
  repeated EndtoolSignal signals = 1;
}


//////////////////////////AnalogList/////////////////////////
message AnalogList {
  repeated AnalogSignal signals = 1;
}

//////////////////////////DeviceInfo/////////////////////////
message DeviceInfo {
  uint32 num_joints = 1;
  string robot_serial = 2;
  float payload = 3;

  string io_board_fw_ver = 10;
  repeated string core_board_fw_vers = 11;
  string endtool_board_fw_ver = 12;

  string controller_ver = 20;
  string controller_detail = 21;
  string controller_date = 22;

  bool teleop_loaded = 30;
  bool calibrated = 31;

  Response response = 100;
}
//////////////////////////BrakeControlStyle/////////////////////////
message BrakeControlStyle {
  enum ControlStyle {
    UNAVAILABLE = 0;
    CONCURRENT = 1;
    INDIVIDUAL = 2;
  }
  ControlStyle style = 1;

  Response response = 100;
}
//////////////////////////GetEL5001Data/////////////////////////
message GetEL5001Data {
  int32 status = 1;
  int32 value = 2;
  int32 delta = 3;
  float average = 4;

  Response response = 100;
}
//////////////////////////GetEL5101Data/////////////////////////
message GetEL5101Data {
  int32 status = 1;
  int32 value = 2;
  int32 latch = 3;
  int32 delta = 4;
  float average = 5;

  Response response = 100;
}

//////////////////////////GetFTSensorData/////////////////////////
message FTSensorData{
  float ft_Fx = 1;
  float ft_Fy = 2;
  float ft_Fz = 3;
  float ft_Tx = 4;
  float ft_Ty = 5;
  float ft_Tz = 6;

  Response response = 100;

}
//////////////////////////GetLoadFactors/////////////////////////
message GetLoadFactorsRes{
  repeated int32 percents = 1;    // percent
  repeated float torques = 2;     // Nm
  Response response = 100;
}

//////////////////////////SetAutoMode/////////////////////////
message SetAutoModeReq {
  bool on = 1;
}

message SetAutoModeRes {
  string msg = 100;
}

//////////////////////////CheckAutoMode/////////////////////////
message CheckAutoModeRes {
  bool on = 1;
  string msg = 100;
}

//////////////////////////CheckReducedMode/////////////////////////
message CheckReducedModeRes {
  bool on = 1;
  string msg = 100;
}

//////////////////////////RequestSafetyFunction/////////////////////////
message SafetyFunctionState {
  uint32 id = 1;
  uint32 state = 2;
  Response response = 100;
}

//////////////////////////GetSafetyState/////////////////////////
message SafetyControlData{
  bool auto_mode = 1;
  bool reduced_mode = 2;
  bool enabler_pressed = 3;

  SafetyFunctionState safety_state = 5;
}

//////////////////////////SanderCommand/////////////////////////
message SanderCommand {
  enum SanderType{
    SANDER_ONROBOT=0;
  }
  SanderType type = 1;
  string ip = 2;
  float speed = 3;
  bool state = 10;
}

//////////////////////////Conveyor/////////////////////////
message Encoder {
  enum EncoderType {
    CONSTANT = 0;
    QUADRATURE = 1;
    RISING = 2;
    FALLING = 3;
    MODBUS = 4;
  }
  EncoderType type = 1;
  int64 channel1 = 2;
  int64 channel2 = 3;
  int64 sample_num = 4;
  float mm_per_tick = 5;
  float vel_const_mmps = 6;
  bool reversed = 7;
}
message Trigger {
  enum TriggerType {
    DIGITAL = 0;
    MODBUS = 1;
  }
  TriggerType type = 1;
  int64 channel = 2;
  bool detect_rise = 3;
}
message Conveyor {
  string name = 1;
  Encoder encoder = 2;
  Trigger trigger = 3;
  float offset_dist = 4;
  float working_dist = 5;
  Nrmk.IndyFramework.Vector direction = 6;
  PosePair starting_pose = 10;
  PosePair terminal_pose = 11;
}

//////////////////////////GetConveyorState/////////////////////////
message ConveyorState {
  float velocity = 1;
  float triggered = 2;
}

  ///////////////Photoneo Calibration//////////////////////
message AddPhotoneoCalibPointReq{
    string vision_name = 1;
    double px = 2;
    double py = 3;
    double pz = 4;
}

//////////////////////////Vision/////////////////////////
/// even duplicated, not to import hri_msgs.proto in device_msgs.proto ///
message VisionServer {
  enum VisionServerType {
    INDYEYE = 0;
    PHOTONEO = 1;
    HELIOS = 2;
  }
  string name = 1;
  VisionServerType vision_server_type = 2;
  string ip = 3;
  uint32 port = 4;
}

enum VisionFrameType {
  OBJECT = 0;
  END_EFFECTOR = 1;
}

message VisionRequest {
  VisionServer vision_server = 1;
  string object = 2;
  VisionFrameType frame_type = 3;
}

message VisionResult {
  repeated float frame = 1;
  VisionFrameType frame_type = 2;
  string object = 3;
  bool detected = 4;
  bool passed = 5;
  string msg = 100;
} // ouput dims: mm, deg


