// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ethercat.proto
#ifndef GRPC_ethercat_2eproto__INCLUDED
#define GRPC_ethercat_2eproto__INCLUDED

#include "ethercat.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace Nrmk {
namespace IndyFramework {

class EtherCAT final {
 public:
  static constexpr char const* service_full_name() {
    return "Nrmk.IndyFramework.EtherCAT";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Master and slave status
    virtual ::grpc::Status GetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::MasterStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MasterStatus>> AsyncGetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MasterStatus>>(AsyncGetMasterStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MasterStatus>> PrepareAsyncGetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MasterStatus>>(PrepareAsyncGetMasterStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SlaveStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveStatus>> AsyncGetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveStatus>>(AsyncGetSlaveStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveStatus>> PrepareAsyncGetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveStatus>>(PrepareAsyncGetSlaveStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatDomainStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>> AsyncGetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>>(AsyncGetRxDomainStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>> PrepareAsyncGetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>>(PrepareAsyncGetRxDomainStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatDomainStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>> AsyncGetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>>(AsyncGetTxDomainStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>> PrepareAsyncGetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>>(PrepareAsyncGetTxDomainStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status IsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatSystemReady* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatSystemReady>> AsyncIsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatSystemReady>>(AsyncIsSystemReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatSystemReady>> PrepareAsyncIsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatSystemReady>>(PrepareAsyncIsSystemReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status IsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatServoOn* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatServoOn>> AsyncIsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatServoOn>>(AsyncIsServoOnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatServoOn>> PrepareAsyncIsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatServoOn>>(PrepareAsyncIsServoOnRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SlaveTypeNum* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveTypeNum>> AsyncGetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveTypeNum>>(AsyncGetSlaveTypeNumRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveTypeNum>> PrepareAsyncGetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveTypeNum>>(PrepareAsyncGetSlaveTypeNumRaw(context, request, cq));
    }
    virtual ::grpc::Status ResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncResetOverflowCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncResetOverflowCountRaw(context, request, cq));
    }
    // Servo PDO
    virtual ::grpc::Status SetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoRxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoRx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRx>> AsyncGetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRx>>(AsyncGetServoRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRx>> PrepareAsyncGetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRx>>(PrepareAsyncGetServoRxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoTx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTx>> AsyncGetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTx>>(AsyncGetServoTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTx>> PrepareAsyncGetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTx>>(PrepareAsyncGetServoTxRaw(context, request, cq));
    }
    virtual ::grpc::Status SetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoRxKebaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoRxKebaRaw(context, request, cq));
    }
    virtual ::grpc::Status GetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoRxKeba* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRxKeba>> AsyncGetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRxKeba>>(AsyncGetServoRxKebaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRxKeba>> PrepareAsyncGetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRxKeba>>(PrepareAsyncGetServoRxKebaRaw(context, request, cq));
    }
    virtual ::grpc::Status GetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoTxKeba* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTxKeba>> AsyncGetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTxKeba>>(AsyncGetServoTxKebaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTxKeba>> PrepareAsyncGetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTxKeba>>(PrepareAsyncGetServoTxKebaRaw(context, request, cq));
    }
    virtual ::grpc::Status SetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoOnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoOnRaw(context, request, cq));
    }
    virtual ::grpc::Status SetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoOffRaw(context, request, cq));
    }
    // rpc GetServoDI(IntVal) returns (IntVal) {}
    // rpc GetServoErrorCode(ServoIndex) returns (IntVal) {}
    // rpc GetServoMaxTorque(ServoIndex) returns (IntVal) {}
    // rpc SetServoMaxTorque(ServoParam) returns (Empty) {}
    // rpc GetServoMaxMotorSpeed(ServoIndex) returns (ServoIndex) {}
    virtual ::grpc::Status SetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoMaxMotorSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoMaxMotorSpeedRaw(context, request, cq));
    }
    // Servo SDO
    virtual ::grpc::Status GetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoTemp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTemp>> AsyncGetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTemp>>(AsyncGetServoTemperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTemp>> PrepareAsyncGetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTemp>>(PrepareAsyncGetServoTemperatureRaw(context, request, cq));
    }
    virtual ::grpc::Status GetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoError* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoError>> AsyncGetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoError>>(AsyncGetServoErrorCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoError>> PrepareAsyncGetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoError>>(PrepareAsyncGetServoErrorCodeRaw(context, request, cq));
    }
    virtual ::grpc::Status ResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncResetServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncResetServoRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetCOREManualBrakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetCOREManualBrakeRaw(context, request, cq));
    }
    // Endtool PDO
    virtual ::grpc::Status SetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndtoolRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndtoolRxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRx>> AsyncGetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRx>>(AsyncGetEndtoolRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRx>> PrepareAsyncGetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRx>>(PrepareAsyncGetEndtoolRxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolTx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolTx>> AsyncGetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolTx>>(AsyncGetEndtoolTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolTx>> PrepareAsyncGetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolTx>>(PrepareAsyncGetEndtoolTxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolDockingTx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolDockingTx>> AsyncGetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolDockingTx>>(AsyncGetEndtoolDockingTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolDockingTx>> PrepareAsyncGetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolDockingTx>>(PrepareAsyncGetEndtoolDockingTxRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndtoolRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndtoolRS485RxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>> AsyncGetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(AsyncGetEndtoolRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>> PrepareAsyncGetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(PrepareAsyncGetEndtoolRS485RxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>> AsyncGetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(AsyncGetEndtoolRS485TxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>> PrepareAsyncGetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(PrepareAsyncGetEndtoolRS485TxRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndtoolLedDimRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndtoolLedDimRaw(context, request, cq));
    }
    // IOBoard PDO
    virtual ::grpc::Status SetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetIOBoardRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetIOBoardRxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IOBoardTx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardTx>> AsyncGetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardTx>>(AsyncGetIOBoardTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardTx>> PrepareAsyncGetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardTx>>(PrepareAsyncGetIOBoardTxRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IOBoardRx* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardRx>> AsyncGetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardRx>>(AsyncGetIOBoardRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardRx>> PrepareAsyncGetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardRx>>(PrepareAsyncGetIOBoardRxRaw(context, request, cq));
    }
    // DIO PDO
    virtual ::grpc::Status GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::Nrmk::IndyFramework::DIODigitalInput* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalInput>> AsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalInput>>(AsyncGetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalInput>> PrepareAsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalInput>>(PrepareAsyncGetDIRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::Nrmk::IndyFramework::DIODigitalOutput* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalOutput>> AsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalOutput>>(AsyncGetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalOutput>> PrepareAsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalOutput>>(PrepareAsyncGetDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    // FT PDO
    //
    // Servo SDO
    //
    // rpc GetCOREErrorCodeSDO(EcatIndex) returns (SDOIntVal) {}
    // rpc GetCORETemperature1SDO(EcatIndex) returns (SDOFloatVal) {}
    // rpc GetCORETemperature2SDO(EcatIndex) returns (SDOFloatVal) {}
    // rpc GetCORETemperature3SDO(EcatIndex) returns (SDOStrVal) {}
    //
    virtual ::grpc::Status GetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetMaxTorqueSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetMaxTorqueSDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetProfileVelSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetProfileVelSDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetProfileAccSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetProfileAccSDORaw(context, request, cq));
    }
    virtual ::grpc::Status GetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetProfileDecSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetProfileDecSDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetMaxTorqueSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetMaxTorqueSDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetProfileVelSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetProfileVelSDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetProfileAccSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetProfileAccSDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetProfileDecSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetProfileDecSDORaw(context, request, cq));
    }
    // rpc ResetWelconDriver(EcatIndex) returns (Empty) {}
    //
    // Agri CamRobot
    virtual ::grpc::Status GetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::RobotZeroCount* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::RobotZeroCount>> AsyncGetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::RobotZeroCount>>(AsyncGetRobotZeroCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::RobotZeroCount>> PrepareAsyncGetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::RobotZeroCount>>(PrepareAsyncGetRobotZeroCountRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> AsyncSetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(AsyncSetRobotZeroAsCurrentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetRobotZeroAsCurrentRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Master and slave status
      virtual void GetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::MasterStatus* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::MasterStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveStatus* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatSystemReady* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatSystemReady* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatServoOn* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatServoOn* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveTypeNum* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveTypeNum* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Servo PDO
      virtual void SetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRxKeba* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRxKeba* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTxKeba* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTxKeba* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // rpc GetServoDI(IntVal) returns (IntVal) {}
      // rpc GetServoErrorCode(ServoIndex) returns (IntVal) {}
      // rpc GetServoMaxTorque(ServoIndex) returns (IntVal) {}
      // rpc SetServoMaxTorque(ServoParam) returns (Empty) {}
      // rpc GetServoMaxMotorSpeed(ServoIndex) returns (ServoIndex) {}
      virtual void SetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Servo SDO
      virtual void GetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTemp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTemp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoError* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoError* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Endtool PDO
      virtual void SetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolTx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolTx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolDockingTx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolDockingTx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // IOBoard PDO
      virtual void SetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardTx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardTx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardRx* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardRx* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // DIO PDO
      virtual void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalInput* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalInput* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalOutput* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalOutput* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // FT PDO
      //
      // Servo SDO
      //
      // rpc GetCOREErrorCodeSDO(EcatIndex) returns (SDOIntVal) {}
      // rpc GetCORETemperature1SDO(EcatIndex) returns (SDOFloatVal) {}
      // rpc GetCORETemperature2SDO(EcatIndex) returns (SDOFloatVal) {}
      // rpc GetCORETemperature3SDO(EcatIndex) returns (SDOStrVal) {}
      //
      virtual void GetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // rpc ResetWelconDriver(EcatIndex) returns (Empty) {}
      //
      // Agri CamRobot
      virtual void GetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::RobotZeroCount* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::RobotZeroCount* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MasterStatus>* AsyncGetMasterStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::MasterStatus>* PrepareAsyncGetMasterStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveStatus>* AsyncGetSlaveStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveStatus>* PrepareAsyncGetSlaveStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>* AsyncGetRxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>* PrepareAsyncGetRxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>* AsyncGetTxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatDomainStatus>* PrepareAsyncGetTxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatSystemReady>* AsyncIsSystemReadyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatSystemReady>* PrepareAsyncIsSystemReadyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatServoOn>* AsyncIsServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EcatServoOn>* PrepareAsyncIsServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveTypeNum>* AsyncGetSlaveTypeNumRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SlaveTypeNum>* PrepareAsyncGetSlaveTypeNumRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncResetOverflowCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncResetOverflowCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRx>* AsyncGetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRx>* PrepareAsyncGetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTx>* AsyncGetServoTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTx>* PrepareAsyncGetServoTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRxKeba>* AsyncGetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoRxKeba>* PrepareAsyncGetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTxKeba>* AsyncGetServoTxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTxKeba>* PrepareAsyncGetServoTxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetServoOffRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoOffRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetServoMaxMotorSpeedRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoMaxMotorSpeedRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTemp>* AsyncGetServoTemperatureRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoTemp>* PrepareAsyncGetServoTemperatureRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoError>* AsyncGetServoErrorCodeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::ServoError>* PrepareAsyncGetServoErrorCodeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncResetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncResetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetCOREManualBrakeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetCOREManualBrakeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRx>* AsyncGetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRx>* PrepareAsyncGetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolTx>* AsyncGetEndtoolTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolTx>* PrepareAsyncGetEndtoolTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolDockingTx>* AsyncGetEndtoolDockingTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolDockingTx>* PrepareAsyncGetEndtoolDockingTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>* AsyncGetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Rx>* PrepareAsyncGetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>* AsyncGetEndtoolRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::EndtoolRS485Tx>* PrepareAsyncGetEndtoolRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetEndtoolLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndtoolLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardTx>* AsyncGetIOBoardTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardTx>* PrepareAsyncGetIOBoardTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardRx>* AsyncGetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::IOBoardRx>* PrepareAsyncGetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalInput>* AsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalInput>* PrepareAsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalOutput>* AsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::DIODigitalOutput>* PrepareAsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::RobotZeroCount>* AsyncGetRobotZeroCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::RobotZeroCount>* PrepareAsyncGetRobotZeroCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* AsyncSetRobotZeroAsCurrentRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetRobotZeroAsCurrentRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::MasterStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MasterStatus>> AsyncGetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MasterStatus>>(AsyncGetMasterStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MasterStatus>> PrepareAsyncGetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MasterStatus>>(PrepareAsyncGetMasterStatusRaw(context, request, cq));
    }
    ::grpc::Status GetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SlaveStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveStatus>> AsyncGetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveStatus>>(AsyncGetSlaveStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveStatus>> PrepareAsyncGetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveStatus>>(PrepareAsyncGetSlaveStatusRaw(context, request, cq));
    }
    ::grpc::Status GetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatDomainStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>> AsyncGetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>>(AsyncGetRxDomainStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>> PrepareAsyncGetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>>(PrepareAsyncGetRxDomainStatusRaw(context, request, cq));
    }
    ::grpc::Status GetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatDomainStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>> AsyncGetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>>(AsyncGetTxDomainStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>> PrepareAsyncGetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>>(PrepareAsyncGetTxDomainStatusRaw(context, request, cq));
    }
    ::grpc::Status IsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatSystemReady* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatSystemReady>> AsyncIsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatSystemReady>>(AsyncIsSystemReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatSystemReady>> PrepareAsyncIsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatSystemReady>>(PrepareAsyncIsSystemReadyRaw(context, request, cq));
    }
    ::grpc::Status IsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EcatServoOn* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatServoOn>> AsyncIsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatServoOn>>(AsyncIsServoOnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatServoOn>> PrepareAsyncIsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatServoOn>>(PrepareAsyncIsServoOnRaw(context, request, cq));
    }
    ::grpc::Status GetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::SlaveTypeNum* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveTypeNum>> AsyncGetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveTypeNum>>(AsyncGetSlaveTypeNumRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveTypeNum>> PrepareAsyncGetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveTypeNum>>(PrepareAsyncGetSlaveTypeNumRaw(context, request, cq));
    }
    ::grpc::Status ResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncResetOverflowCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncResetOverflowCountRaw(context, request, cq));
    }
    ::grpc::Status SetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoRxRaw(context, request, cq));
    }
    ::grpc::Status GetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoRx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRx>> AsyncGetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRx>>(AsyncGetServoRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRx>> PrepareAsyncGetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRx>>(PrepareAsyncGetServoRxRaw(context, request, cq));
    }
    ::grpc::Status GetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoTx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTx>> AsyncGetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTx>>(AsyncGetServoTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTx>> PrepareAsyncGetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTx>>(PrepareAsyncGetServoTxRaw(context, request, cq));
    }
    ::grpc::Status SetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoRxKebaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoRxKebaRaw(context, request, cq));
    }
    ::grpc::Status GetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoRxKeba* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRxKeba>> AsyncGetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRxKeba>>(AsyncGetServoRxKebaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRxKeba>> PrepareAsyncGetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRxKeba>>(PrepareAsyncGetServoRxKebaRaw(context, request, cq));
    }
    ::grpc::Status GetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoTxKeba* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTxKeba>> AsyncGetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTxKeba>>(AsyncGetServoTxKebaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTxKeba>> PrepareAsyncGetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTxKeba>>(PrepareAsyncGetServoTxKebaRaw(context, request, cq));
    }
    ::grpc::Status SetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoOnRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoOnRaw(context, request, cq));
    }
    ::grpc::Status SetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoOffRaw(context, request, cq));
    }
    ::grpc::Status SetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetServoMaxMotorSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetServoMaxMotorSpeedRaw(context, request, cq));
    }
    ::grpc::Status GetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoTemp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTemp>> AsyncGetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTemp>>(AsyncGetServoTemperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTemp>> PrepareAsyncGetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTemp>>(PrepareAsyncGetServoTemperatureRaw(context, request, cq));
    }
    ::grpc::Status GetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::ServoError* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoError>> AsyncGetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoError>>(AsyncGetServoErrorCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoError>> PrepareAsyncGetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoError>>(PrepareAsyncGetServoErrorCodeRaw(context, request, cq));
    }
    ::grpc::Status ResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncResetServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncResetServoRaw(context, request, cq));
    }
    ::grpc::Status SetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetCOREManualBrakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetCOREManualBrakeRaw(context, request, cq));
    }
    ::grpc::Status SetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndtoolRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndtoolRxRaw(context, request, cq));
    }
    ::grpc::Status GetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRx>> AsyncGetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRx>>(AsyncGetEndtoolRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRx>> PrepareAsyncGetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRx>>(PrepareAsyncGetEndtoolRxRaw(context, request, cq));
    }
    ::grpc::Status GetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolTx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolTx>> AsyncGetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolTx>>(AsyncGetEndtoolTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolTx>> PrepareAsyncGetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolTx>>(PrepareAsyncGetEndtoolTxRaw(context, request, cq));
    }
    ::grpc::Status GetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolDockingTx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolDockingTx>> AsyncGetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolDockingTx>>(AsyncGetEndtoolDockingTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolDockingTx>> PrepareAsyncGetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolDockingTx>>(PrepareAsyncGetEndtoolDockingTxRaw(context, request, cq));
    }
    ::grpc::Status SetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndtoolRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndtoolRS485RxRaw(context, request, cq));
    }
    ::grpc::Status GetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>> AsyncGetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(AsyncGetEndtoolRS485RxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>> PrepareAsyncGetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>>(PrepareAsyncGetEndtoolRS485RxRaw(context, request, cq));
    }
    ::grpc::Status GetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>> AsyncGetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(AsyncGetEndtoolRS485TxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>> PrepareAsyncGetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>>(PrepareAsyncGetEndtoolRS485TxRaw(context, request, cq));
    }
    ::grpc::Status SetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetEndtoolLedDimRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetEndtoolLedDimRaw(context, request, cq));
    }
    ::grpc::Status SetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetIOBoardRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetIOBoardRxRaw(context, request, cq));
    }
    ::grpc::Status GetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IOBoardTx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardTx>> AsyncGetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardTx>>(AsyncGetIOBoardTxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardTx>> PrepareAsyncGetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardTx>>(PrepareAsyncGetIOBoardTxRaw(context, request, cq));
    }
    ::grpc::Status GetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::Nrmk::IndyFramework::IOBoardRx* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardRx>> AsyncGetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardRx>>(AsyncGetIOBoardRxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardRx>> PrepareAsyncGetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardRx>>(PrepareAsyncGetIOBoardRxRaw(context, request, cq));
    }
    ::grpc::Status GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::Nrmk::IndyFramework::DIODigitalInput* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalInput>> AsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalInput>>(AsyncGetDIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalInput>> PrepareAsyncGetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalInput>>(PrepareAsyncGetDIRaw(context, request, cq));
    }
    ::grpc::Status GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::Nrmk::IndyFramework::DIODigitalOutput* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalOutput>> AsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalOutput>>(AsyncGetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalOutput>> PrepareAsyncGetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalOutput>>(PrepareAsyncGetDORaw(context, request, cq));
    }
    ::grpc::Status SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    ::grpc::Status GetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetMaxTorqueSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetMaxTorqueSDORaw(context, request, cq));
    }
    ::grpc::Status GetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetProfileVelSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetProfileVelSDORaw(context, request, cq));
    }
    ::grpc::Status GetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetProfileAccSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetProfileAccSDORaw(context, request, cq));
    }
    ::grpc::Status GetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::Nrmk::IndyFramework::SDOIntVal* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> AsyncGetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(AsyncGetProfileDecSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>> PrepareAsyncGetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>>(PrepareAsyncGetProfileDecSDORaw(context, request, cq));
    }
    ::grpc::Status SetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetMaxTorqueSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetMaxTorqueSDORaw(context, request, cq));
    }
    ::grpc::Status SetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetProfileVelSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetProfileVelSDORaw(context, request, cq));
    }
    ::grpc::Status SetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetProfileAccSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetProfileAccSDORaw(context, request, cq));
    }
    ::grpc::Status SetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetProfileDecSDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetProfileDecSDORaw(context, request, cq));
    }
    ::grpc::Status GetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::RobotZeroCount* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::RobotZeroCount>> AsyncGetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::RobotZeroCount>>(AsyncGetRobotZeroCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::RobotZeroCount>> PrepareAsyncGetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::RobotZeroCount>>(PrepareAsyncGetRobotZeroCountRaw(context, request, cq));
    }
    ::grpc::Status SetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::Nrmk::IndyFramework::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> AsyncSetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(AsyncSetRobotZeroAsCurrentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>> PrepareAsyncSetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>>(PrepareAsyncSetRobotZeroAsCurrentRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::MasterStatus* response, std::function<void(::grpc::Status)>) override;
      void GetMasterStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::MasterStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveStatus* response, std::function<void(::grpc::Status)>) override;
      void GetSlaveStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, std::function<void(::grpc::Status)>) override;
      void GetRxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, std::function<void(::grpc::Status)>) override;
      void GetTxDomainStatus(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatSystemReady* response, std::function<void(::grpc::Status)>) override;
      void IsSystemReady(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatSystemReady* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatServoOn* response, std::function<void(::grpc::Status)>) override;
      void IsServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatServoOn* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveTypeNum* response, std::function<void(::grpc::Status)>) override;
      void GetSlaveTypeNum(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveTypeNum* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void ResetOverflowCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRx* response, std::function<void(::grpc::Status)>) override;
      void GetServoRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTx* response, std::function<void(::grpc::Status)>) override;
      void GetServoTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRxKeba* response, std::function<void(::grpc::Status)>) override;
      void GetServoRxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRxKeba* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTxKeba* response, std::function<void(::grpc::Status)>) override;
      void GetServoTxKeba(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTxKeba* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetServoOn(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetServoOff(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetServoMaxMotorSpeed(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTemp* response, std::function<void(::grpc::Status)>) override;
      void GetServoTemperature(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTemp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoError* response, std::function<void(::grpc::Status)>) override;
      void GetServoErrorCode(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoError* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void ResetServo(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetCOREManualBrake(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRx* response, std::function<void(::grpc::Status)>) override;
      void GetEndtoolRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolTx* response, std::function<void(::grpc::Status)>) override;
      void GetEndtoolTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolTx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolDockingTx* response, std::function<void(::grpc::Status)>) override;
      void GetEndtoolDockingTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolDockingTx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, std::function<void(::grpc::Status)>) override;
      void GetEndtoolRS485Rx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, std::function<void(::grpc::Status)>) override;
      void GetEndtoolRS485Tx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetEndtoolLedDim(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardTx* response, std::function<void(::grpc::Status)>) override;
      void GetIOBoardTx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardTx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardRx* response, std::function<void(::grpc::Status)>) override;
      void GetIOBoardRx(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardRx* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalInput* response, std::function<void(::grpc::Status)>) override;
      void GetDI(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalInput* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalOutput* response, std::function<void(::grpc::Status)>) override;
      void GetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalOutput* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) override;
      void GetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) override;
      void GetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) override;
      void GetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, std::function<void(::grpc::Status)>) override;
      void GetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetMaxTorqueSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetProfileVelSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetProfileAccSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetProfileDecSDO(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::RobotZeroCount* response, std::function<void(::grpc::Status)>) override;
      void GetRobotZeroCount(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::RobotZeroCount* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetRobotZeroAsCurrent(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MasterStatus>* AsyncGetMasterStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::MasterStatus>* PrepareAsyncGetMasterStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveStatus>* AsyncGetSlaveStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveStatus>* PrepareAsyncGetSlaveStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>* AsyncGetRxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>* PrepareAsyncGetRxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>* AsyncGetTxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatDomainStatus>* PrepareAsyncGetTxDomainStatusRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatSystemReady>* AsyncIsSystemReadyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatSystemReady>* PrepareAsyncIsSystemReadyRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatServoOn>* AsyncIsServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EcatServoOn>* PrepareAsyncIsServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveTypeNum>* AsyncGetSlaveTypeNumRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SlaveTypeNum>* PrepareAsyncGetSlaveTypeNumRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncResetOverflowCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncResetOverflowCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRx>* AsyncGetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRx>* PrepareAsyncGetServoRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTx>* AsyncGetServoTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTx>* PrepareAsyncGetServoTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRxKeba>* AsyncGetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoRxKeba>* PrepareAsyncGetServoRxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTxKeba>* AsyncGetServoTxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTxKeba>* PrepareAsyncGetServoTxKebaRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoOnRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetServoOffRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoOffRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetServoMaxMotorSpeedRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetServoMaxMotorSpeedRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTemp>* AsyncGetServoTemperatureRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoTemp>* PrepareAsyncGetServoTemperatureRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoError>* AsyncGetServoErrorCodeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::ServoError>* PrepareAsyncGetServoErrorCodeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncResetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncResetServoRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetCOREManualBrakeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetCOREManualBrakeRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoBrake& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRx>* AsyncGetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRx>* PrepareAsyncGetEndtoolRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolTx>* AsyncGetEndtoolTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolTx>* PrepareAsyncGetEndtoolTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolDockingTx>* AsyncGetEndtoolDockingTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolDockingTx>* PrepareAsyncGetEndtoolDockingTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>* AsyncGetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Rx>* PrepareAsyncGetEndtoolRS485RxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>* AsyncGetEndtoolRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::EndtoolRS485Tx>* PrepareAsyncGetEndtoolRS485TxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetEndtoolLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetEndtoolLedDimRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::LedDim& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::IOBoardRx& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardTx>* AsyncGetIOBoardTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardTx>* PrepareAsyncGetIOBoardTxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardRx>* AsyncGetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::IOBoardRx>* PrepareAsyncGetIOBoardRxRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalInput>* AsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalInput>* PrepareAsyncGetDIRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalOutput>* AsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::DIODigitalOutput>* PrepareAsyncGetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIOIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* AsyncGetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::SDOIntVal>* PrepareAsyncGetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::EcatIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetMaxTorqueSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetProfileVelSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetProfileAccSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetProfileDecSDORaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoParam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::RobotZeroCount>* AsyncGetRobotZeroCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::RobotZeroCount>* PrepareAsyncGetRobotZeroCountRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* AsyncSetRobotZeroAsCurrentRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Nrmk::IndyFramework::Empty>* PrepareAsyncSetRobotZeroAsCurrentRaw(::grpc::ClientContext* context, const ::Nrmk::IndyFramework::ServoIndex& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetMasterStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSlaveStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRxDomainStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTxDomainStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_IsSystemReady_;
    const ::grpc::internal::RpcMethod rpcmethod_IsServoOn_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSlaveTypeNum_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetOverflowCount_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServoRx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServoRx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServoTx_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServoRxKeba_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServoRxKeba_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServoTxKeba_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServoOn_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServoOff_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServoMaxMotorSpeed_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServoTemperature_;
    const ::grpc::internal::RpcMethod rpcmethod_GetServoErrorCode_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetServo_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCOREManualBrake_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndtoolRx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndtoolRx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndtoolTx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndtoolDockingTx_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndtoolRS485Rx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndtoolRS485Rx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEndtoolRS485Tx_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndtoolLedDim_;
    const ::grpc::internal::RpcMethod rpcmethod_SetIOBoardRx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIOBoardTx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIOBoardRx_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMaxTorqueSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProfileVelSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProfileAccSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProfileDecSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMaxTorqueSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetProfileVelSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetProfileAccSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetProfileDecSDO_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRobotZeroCount_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRobotZeroAsCurrent_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Master and slave status
    virtual ::grpc::Status GetMasterStatus(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::MasterStatus* response);
    virtual ::grpc::Status GetSlaveStatus(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveStatus* response);
    virtual ::grpc::Status GetRxDomainStatus(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response);
    virtual ::grpc::Status GetTxDomainStatus(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response);
    virtual ::grpc::Status IsSystemReady(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatSystemReady* response);
    virtual ::grpc::Status IsServoOn(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatServoOn* response);
    virtual ::grpc::Status GetSlaveTypeNum(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveTypeNum* response);
    virtual ::grpc::Status ResetOverflowCount(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response);
    // Servo PDO
    virtual ::grpc::Status SetServoRx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoRxIndex* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetServoRx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRx* response);
    virtual ::grpc::Status GetServoTx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTx* response);
    virtual ::grpc::Status SetServoRxKeba(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetServoRxKeba(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRxKeba* response);
    virtual ::grpc::Status GetServoTxKeba(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTxKeba* response);
    virtual ::grpc::Status SetServoOn(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SetServoOff(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response);
    // rpc GetServoDI(IntVal) returns (IntVal) {}
    // rpc GetServoErrorCode(ServoIndex) returns (IntVal) {}
    // rpc GetServoMaxTorque(ServoIndex) returns (IntVal) {}
    // rpc SetServoMaxTorque(ServoParam) returns (Empty) {}
    // rpc GetServoMaxMotorSpeed(ServoIndex) returns (ServoIndex) {}
    virtual ::grpc::Status SetServoMaxMotorSpeed(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response);
    // Servo SDO
    virtual ::grpc::Status GetServoTemperature(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTemp* response);
    virtual ::grpc::Status GetServoErrorCode(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoError* response);
    virtual ::grpc::Status ResetServo(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SetCOREManualBrake(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoBrake* request, ::Nrmk::IndyFramework::Empty* response);
    // Endtool PDO
    virtual ::grpc::Status SetEndtoolRx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EndtoolRx* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetEndtoolRx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRx* response);
    virtual ::grpc::Status GetEndtoolTx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolTx* response);
    virtual ::grpc::Status GetEndtoolDockingTx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolDockingTx* response);
    virtual ::grpc::Status SetEndtoolRS485Rx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetEndtoolRS485Rx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response);
    virtual ::grpc::Status GetEndtoolRS485Tx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response);
    virtual ::grpc::Status SetEndtoolLedDim(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::LedDim* request, ::Nrmk::IndyFramework::Empty* response);
    // IOBoard PDO
    virtual ::grpc::Status SetIOBoardRx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::IOBoardRx* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status GetIOBoardTx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardTx* response);
    virtual ::grpc::Status GetIOBoardRx(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardRx* response);
    // DIO PDO
    virtual ::grpc::Status GetDI(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalInput* response);
    virtual ::grpc::Status GetDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalOutput* response);
    virtual ::grpc::Status SetDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput* request, ::Nrmk::IndyFramework::Empty* response);
    // FT PDO
    //
    // Servo SDO
    //
    // rpc GetCOREErrorCodeSDO(EcatIndex) returns (SDOIntVal) {}
    // rpc GetCORETemperature1SDO(EcatIndex) returns (SDOFloatVal) {}
    // rpc GetCORETemperature2SDO(EcatIndex) returns (SDOFloatVal) {}
    // rpc GetCORETemperature3SDO(EcatIndex) returns (SDOStrVal) {}
    //
    virtual ::grpc::Status GetMaxTorqueSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response);
    virtual ::grpc::Status GetProfileVelSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response);
    virtual ::grpc::Status GetProfileAccSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response);
    virtual ::grpc::Status GetProfileDecSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response);
    virtual ::grpc::Status SetMaxTorqueSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SetProfileVelSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SetProfileAccSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response);
    virtual ::grpc::Status SetProfileDecSDO(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response);
    // rpc ResetWelconDriver(EcatIndex) returns (Empty) {}
    //
    // Agri CamRobot
    virtual ::grpc::Status GetRobotZeroCount(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::RobotZeroCount* response);
    virtual ::grpc::Status SetRobotZeroAsCurrent(::grpc::ServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMasterStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMasterStatus() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetMasterStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMasterStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::MasterStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMasterStatus(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::MasterStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSlaveStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSlaveStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetSlaveStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSlaveStatus(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SlaveStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRxDomainStatus() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetRxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRxDomainStatus(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EcatDomainStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTxDomainStatus() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetTxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTxDomainStatus(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EcatDomainStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsSystemReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsSystemReady() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_IsSystemReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSystemReady(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatSystemReady* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsSystemReady(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EcatSystemReady>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsServoOn() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_IsServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatServoOn* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsServoOn(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EcatServoOn>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSlaveTypeNum : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSlaveTypeNum() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetSlaveTypeNum() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveTypeNum(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveTypeNum* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSlaveTypeNum(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SlaveTypeNum>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetOverflowCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetOverflowCount() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ResetOverflowCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetOverflowCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetOverflowCount(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServoRx() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoRx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoRxIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServoRx() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoRx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ServoRx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServoTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServoTx() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetServoTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoTx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ServoTx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServoRxKeba() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_SetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndexKeba* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoRxKeba(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoRxIndexKeba* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServoRxKeba() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoRxKeba(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ServoRxKeba>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServoTxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServoTxKeba() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetServoTxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoTxKeba(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ServoTxKeba>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServoOn() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_SetServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoOn(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServoOff() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SetServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOff(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoOff(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServoMaxMotorSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServoMaxMotorSpeed() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_SetServoMaxMotorSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoMaxMotorSpeed(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoMaxMotorSpeed(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoParam* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServoTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServoTemperature() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetServoTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTemperature(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTemp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoTemperature(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ServoTemp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServoErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServoErrorCode() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetServoErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoErrorCode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoError* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoErrorCode(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::ServoError>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetServo() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_ResetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetServo(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCOREManualBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCOREManualBrake() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_SetCOREManualBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCOREManualBrake(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoBrake* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCOREManualBrake(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoBrake* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndtoolRx() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_SetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndtoolRx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EndtoolRx* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndtoolRx() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_GetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolRx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolRx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndtoolTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndtoolTx() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetEndtoolTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolTx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolTx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndtoolDockingTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndtoolDockingTx() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_GetEndtoolDockingTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolDockingTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolDockingTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolDockingTx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolDockingTx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_SetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndtoolRS485Rx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_GetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolRS485Rx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolRS485Rx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEndtoolRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEndtoolRS485Tx() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_GetEndtoolRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolRS485Tx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::EndtoolRS485Tx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndtoolLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndtoolLedDim() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_SetEndtoolLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::LedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndtoolLedDim(::grpc::ServerContext* context, ::Nrmk::IndyFramework::LedDim* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetIOBoardRx() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_SetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IOBoardRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetIOBoardRx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::IOBoardRx* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIOBoardTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIOBoardTx() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_GetIOBoardTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOBoardTx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::IOBoardTx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIOBoardRx() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_GetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOBoardRx(::grpc::ServerContext* context, ::Nrmk::IndyFramework::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::IOBoardRx>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDI() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalInput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDI(::grpc::ServerContext* context, ::Nrmk::IndyFramework::DIOIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::DIODigitalInput>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDO() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalOutput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::DIOIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::DIODigitalOutput>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDO() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIODigitalOutput* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::DIODigitalOutput* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_GetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMaxTorqueSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EcatIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SDOIntVal>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProfileVelSDO() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_GetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProfileVelSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EcatIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SDOIntVal>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProfileAccSDO() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProfileAccSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EcatIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SDOIntVal>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProfileDecSDO() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_GetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProfileDecSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::EcatIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::SDOIntVal>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_SetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaxTorqueSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoParam* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetProfileVelSDO() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_SetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileVelSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoParam* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetProfileAccSDO() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_SetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileAccSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoParam* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetProfileDecSDO() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_SetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileDecSDO(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoParam* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRobotZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRobotZeroCount() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetRobotZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotZeroCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::RobotZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotZeroCount(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::RobotZeroCount>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRobotZeroAsCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRobotZeroAsCurrent() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_SetRobotZeroAsCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRobotZeroAsCurrent(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRobotZeroAsCurrent(::grpc::ServerContext* context, ::Nrmk::IndyFramework::ServoIndex* request, ::grpc::ServerAsyncResponseWriter< ::Nrmk::IndyFramework::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetMasterStatus<WithAsyncMethod_GetSlaveStatus<WithAsyncMethod_GetRxDomainStatus<WithAsyncMethod_GetTxDomainStatus<WithAsyncMethod_IsSystemReady<WithAsyncMethod_IsServoOn<WithAsyncMethod_GetSlaveTypeNum<WithAsyncMethod_ResetOverflowCount<WithAsyncMethod_SetServoRx<WithAsyncMethod_GetServoRx<WithAsyncMethod_GetServoTx<WithAsyncMethod_SetServoRxKeba<WithAsyncMethod_GetServoRxKeba<WithAsyncMethod_GetServoTxKeba<WithAsyncMethod_SetServoOn<WithAsyncMethod_SetServoOff<WithAsyncMethod_SetServoMaxMotorSpeed<WithAsyncMethod_GetServoTemperature<WithAsyncMethod_GetServoErrorCode<WithAsyncMethod_ResetServo<WithAsyncMethod_SetCOREManualBrake<WithAsyncMethod_SetEndtoolRx<WithAsyncMethod_GetEndtoolRx<WithAsyncMethod_GetEndtoolTx<WithAsyncMethod_GetEndtoolDockingTx<WithAsyncMethod_SetEndtoolRS485Rx<WithAsyncMethod_GetEndtoolRS485Rx<WithAsyncMethod_GetEndtoolRS485Tx<WithAsyncMethod_SetEndtoolLedDim<WithAsyncMethod_SetIOBoardRx<WithAsyncMethod_GetIOBoardTx<WithAsyncMethod_GetIOBoardRx<WithAsyncMethod_GetDI<WithAsyncMethod_GetDO<WithAsyncMethod_SetDO<WithAsyncMethod_GetMaxTorqueSDO<WithAsyncMethod_GetProfileVelSDO<WithAsyncMethod_GetProfileAccSDO<WithAsyncMethod_GetProfileDecSDO<WithAsyncMethod_SetMaxTorqueSDO<WithAsyncMethod_SetProfileVelSDO<WithAsyncMethod_SetProfileAccSDO<WithAsyncMethod_SetProfileDecSDO<WithAsyncMethod_GetRobotZeroCount<WithAsyncMethod_SetRobotZeroAsCurrent<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetMasterStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMasterStatus() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::MasterStatus>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::MasterStatus* response) { return this->GetMasterStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetMasterStatus(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::MasterStatus>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::MasterStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMasterStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMasterStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::MasterStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMasterStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::MasterStatus* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSlaveStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSlaveStatus() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveStatus>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveStatus* response) { return this->GetSlaveStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetSlaveStatus(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveStatus>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSlaveStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSlaveStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveStatus* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRxDomainStatus() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response) { return this->GetRxDomainStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetRxDomainStatus(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRxDomainStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTxDomainStatus() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatDomainStatus* response) { return this->GetTxDomainStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetTxDomainStatus(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTxDomainStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsSystemReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsSystemReady() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatSystemReady>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatSystemReady* response) { return this->IsSystemReady(context, request, response); }));}
    void SetMessageAllocatorFor_IsSystemReady(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatSystemReady>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatSystemReady>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsSystemReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSystemReady(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatSystemReady* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsSystemReady(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatSystemReady* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsServoOn() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatServoOn>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EcatServoOn* response) { return this->IsServoOn(context, request, response); }));}
    void SetMessageAllocatorFor_IsServoOn(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatServoOn>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatServoOn>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatServoOn* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsServoOn(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatServoOn* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSlaveTypeNum : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSlaveTypeNum() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveTypeNum>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::SlaveTypeNum* response) { return this->GetSlaveTypeNum(context, request, response); }));}
    void SetMessageAllocatorFor_GetSlaveTypeNum(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveTypeNum>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveTypeNum>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSlaveTypeNum() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveTypeNum(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveTypeNum* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSlaveTypeNum(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveTypeNum* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetOverflowCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetOverflowCount() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::Empty* response) { return this->ResetOverflowCount(context, request, response); }));}
    void SetMessageAllocatorFor_ResetOverflowCount(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetOverflowCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetOverflowCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetOverflowCount(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServoRx() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoRxIndex, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoRxIndex* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetServoRx(context, request, response); }));}
    void SetMessageAllocatorFor_SetServoRx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoRxIndex, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoRxIndex, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoRx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServoRx() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRx* response) { return this->GetServoRx(context, request, response); }));}
    void SetMessageAllocatorFor_GetServoRx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoRx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServoTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServoTx() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTx* response) { return this->GetServoTx(context, request, response); }));}
    void SetMessageAllocatorFor_GetServoTx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServoTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoTx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServoRxKeba() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoRxIndexKeba, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoRxIndexKeba* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetServoRxKeba(context, request, response); }));}
    void SetMessageAllocatorFor_SetServoRxKeba(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoRxIndexKeba, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoRxIndexKeba, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndexKeba* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoRxKeba(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndexKeba* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServoRxKeba() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRxKeba>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoRxKeba* response) { return this->GetServoRxKeba(context, request, response); }));}
    void SetMessageAllocatorFor_GetServoRxKeba(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRxKeba>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRxKeba>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoRxKeba(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRxKeba* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServoTxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServoTxKeba() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTxKeba>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTxKeba* response) { return this->GetServoTxKeba(context, request, response); }));}
    void SetMessageAllocatorFor_GetServoTxKeba(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTxKeba>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTxKeba>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServoTxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoTxKeba(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTxKeba* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServoOn() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetServoOn(context, request, response); }));}
    void SetMessageAllocatorFor_SetServoOn(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoOn(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServoOff() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetServoOff(context, request, response); }));}
    void SetMessageAllocatorFor_SetServoOff(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOff(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoOff(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServoMaxMotorSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServoMaxMotorSpeed() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetServoMaxMotorSpeed(context, request, response); }));}
    void SetMessageAllocatorFor_SetServoMaxMotorSpeed(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServoMaxMotorSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoMaxMotorSpeed(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoMaxMotorSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServoTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServoTemperature() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTemp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoTemp* response) { return this->GetServoTemperature(context, request, response); }));}
    void SetMessageAllocatorFor_GetServoTemperature(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTemp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTemp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServoTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTemperature(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTemp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoTemperature(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTemp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetServoErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServoErrorCode() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoError>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::ServoError* response) { return this->GetServoErrorCode(context, request, response); }));}
    void SetMessageAllocatorFor_GetServoErrorCode(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoError>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoError>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServoErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoErrorCode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoError* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoErrorCode(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoError* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetServo() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response) { return this->ResetServo(context, request, response); }));}
    void SetMessageAllocatorFor_ResetServo(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetServo(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCOREManualBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCOREManualBrake() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoBrake, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoBrake* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetCOREManualBrake(context, request, response); }));}
    void SetMessageAllocatorFor_SetCOREManualBrake(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoBrake, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoBrake, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCOREManualBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCOREManualBrake(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoBrake* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCOREManualBrake(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoBrake* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndtoolRx() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolRx, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EndtoolRx* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetEndtoolRx(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndtoolRx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EndtoolRx, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolRx, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndtoolRx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndtoolRx() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRx* response) { return this->GetEndtoolRx(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndtoolRx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolRx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndtoolTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndtoolTx() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolTx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolTx* response) { return this->GetEndtoolTx(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndtoolTx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolTx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolTx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndtoolTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolTx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolTx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndtoolDockingTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndtoolDockingTx() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolDockingTx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolDockingTx* response) { return this->GetEndtoolDockingTx(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndtoolDockingTx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolDockingTx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolDockingTx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndtoolDockingTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolDockingTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolDockingTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolDockingTx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolDockingTx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EndtoolRS485Rx* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetEndtoolRS485Rx(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndtoolRS485Rx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndtoolRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Rx* response) { return this->GetEndtoolRS485Rx(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndtoolRS485Rx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEndtoolRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEndtoolRS485Tx() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::EndtoolRS485Tx* response) { return this->GetEndtoolRS485Tx(context, request, response); }));}
    void SetMessageAllocatorFor_GetEndtoolRS485Tx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEndtoolRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolRS485Tx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndtoolLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndtoolLedDim() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::LedDim, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::LedDim* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetEndtoolLedDim(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndtoolLedDim(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::LedDim, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::LedDim, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndtoolLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::LedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndtoolLedDim(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::LedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetIOBoardRx() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::IOBoardRx, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::IOBoardRx* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetIOBoardRx(context, request, response); }));}
    void SetMessageAllocatorFor_SetIOBoardRx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::IOBoardRx, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::IOBoardRx, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IOBoardRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetIOBoardRx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::IOBoardRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetIOBoardTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetIOBoardTx() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardTx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardTx* response) { return this->GetIOBoardTx(context, request, response); }));}
    void SetMessageAllocatorFor_GetIOBoardTx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardTx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardTx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetIOBoardTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIOBoardTx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardTx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetIOBoardRx() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardRx>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::Empty* request, ::Nrmk::IndyFramework::IOBoardRx* response) { return this->GetIOBoardRx(context, request, response); }));}
    void SetMessageAllocatorFor_GetIOBoardRx(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardRx>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardRx>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIOBoardRx(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardRx* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDI() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalInput>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalInput* response) { return this->GetDI(context, request, response); }));}
    void SetMessageAllocatorFor_GetDI(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalInput>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalInput>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalInput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDI(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalInput* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDO() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalOutput>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::DIOIndex* request, ::Nrmk::IndyFramework::DIODigitalOutput* response) { return this->GetDO(context, request, response); }));}
    void SetMessageAllocatorFor_GetDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalOutput>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalOutput>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalOutput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalOutput* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDO() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DIODigitalOutput, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::DIODigitalOutput* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::DIODigitalOutput, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::DIODigitalOutput, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIODigitalOutput* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::DIODigitalOutput* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response) { return this->GetMaxTorqueSDO(context, request, response); }));}
    void SetMessageAllocatorFor_GetMaxTorqueSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMaxTorqueSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetProfileVelSDO() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response) { return this->GetProfileVelSDO(context, request, response); }));}
    void SetMessageAllocatorFor_GetProfileVelSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProfileVelSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetProfileAccSDO() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response) { return this->GetProfileAccSDO(context, request, response); }));}
    void SetMessageAllocatorFor_GetProfileAccSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProfileAccSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetProfileDecSDO() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::EcatIndex* request, ::Nrmk::IndyFramework::SDOIntVal* response) { return this->GetProfileDecSDO(context, request, response); }));}
    void SetMessageAllocatorFor_GetProfileDecSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProfileDecSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetMaxTorqueSDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetMaxTorqueSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetMaxTorqueSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetProfileVelSDO() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetProfileVelSDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetProfileVelSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileVelSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetProfileAccSDO() {
      ::grpc::Service::MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetProfileAccSDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetProfileAccSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileAccSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetProfileDecSDO() {
      ::grpc::Service::MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoParam* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetProfileDecSDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetProfileDecSDO(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileDecSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRobotZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRobotZeroCount() {
      ::grpc::Service::MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::RobotZeroCount>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::RobotZeroCount* response) { return this->GetRobotZeroCount(context, request, response); }));}
    void SetMessageAllocatorFor_GetRobotZeroCount(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::RobotZeroCount>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::RobotZeroCount>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRobotZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotZeroCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::RobotZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRobotZeroCount(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::RobotZeroCount* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRobotZeroAsCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRobotZeroAsCurrent() {
      ::grpc::Service::MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Nrmk::IndyFramework::ServoIndex* request, ::Nrmk::IndyFramework::Empty* response) { return this->SetRobotZeroAsCurrent(context, request, response); }));}
    void SetMessageAllocatorFor_SetRobotZeroAsCurrent(
        ::grpc::MessageAllocator< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRobotZeroAsCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRobotZeroAsCurrent(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRobotZeroAsCurrent(
      ::grpc::CallbackServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetMasterStatus<WithCallbackMethod_GetSlaveStatus<WithCallbackMethod_GetRxDomainStatus<WithCallbackMethod_GetTxDomainStatus<WithCallbackMethod_IsSystemReady<WithCallbackMethod_IsServoOn<WithCallbackMethod_GetSlaveTypeNum<WithCallbackMethod_ResetOverflowCount<WithCallbackMethod_SetServoRx<WithCallbackMethod_GetServoRx<WithCallbackMethod_GetServoTx<WithCallbackMethod_SetServoRxKeba<WithCallbackMethod_GetServoRxKeba<WithCallbackMethod_GetServoTxKeba<WithCallbackMethod_SetServoOn<WithCallbackMethod_SetServoOff<WithCallbackMethod_SetServoMaxMotorSpeed<WithCallbackMethod_GetServoTemperature<WithCallbackMethod_GetServoErrorCode<WithCallbackMethod_ResetServo<WithCallbackMethod_SetCOREManualBrake<WithCallbackMethod_SetEndtoolRx<WithCallbackMethod_GetEndtoolRx<WithCallbackMethod_GetEndtoolTx<WithCallbackMethod_GetEndtoolDockingTx<WithCallbackMethod_SetEndtoolRS485Rx<WithCallbackMethod_GetEndtoolRS485Rx<WithCallbackMethod_GetEndtoolRS485Tx<WithCallbackMethod_SetEndtoolLedDim<WithCallbackMethod_SetIOBoardRx<WithCallbackMethod_GetIOBoardTx<WithCallbackMethod_GetIOBoardRx<WithCallbackMethod_GetDI<WithCallbackMethod_GetDO<WithCallbackMethod_SetDO<WithCallbackMethod_GetMaxTorqueSDO<WithCallbackMethod_GetProfileVelSDO<WithCallbackMethod_GetProfileAccSDO<WithCallbackMethod_GetProfileDecSDO<WithCallbackMethod_SetMaxTorqueSDO<WithCallbackMethod_SetProfileVelSDO<WithCallbackMethod_SetProfileAccSDO<WithCallbackMethod_SetProfileDecSDO<WithCallbackMethod_GetRobotZeroCount<WithCallbackMethod_SetRobotZeroAsCurrent<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetMasterStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMasterStatus() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetMasterStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMasterStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::MasterStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSlaveStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSlaveStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetSlaveStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRxDomainStatus() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetRxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTxDomainStatus() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetTxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsSystemReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsSystemReady() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_IsSystemReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSystemReady(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatSystemReady* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsServoOn() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_IsServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatServoOn* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSlaveTypeNum : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSlaveTypeNum() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetSlaveTypeNum() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveTypeNum(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveTypeNum* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetOverflowCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetOverflowCount() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ResetOverflowCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetOverflowCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServoRx() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServoRx() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServoTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServoTx() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetServoTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServoRxKeba() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_SetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndexKeba* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServoRxKeba() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServoTxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServoTxKeba() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetServoTxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServoOn() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_SetServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServoOff() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SetServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOff(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServoMaxMotorSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServoMaxMotorSpeed() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_SetServoMaxMotorSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoMaxMotorSpeed(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServoTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServoTemperature() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetServoTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTemperature(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTemp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetServoErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServoErrorCode() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetServoErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoErrorCode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoError* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetServo() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_ResetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCOREManualBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCOREManualBrake() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_SetCOREManualBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCOREManualBrake(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoBrake* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndtoolRx() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_SetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndtoolRx() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_GetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndtoolTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndtoolTx() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetEndtoolTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndtoolDockingTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndtoolDockingTx() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_GetEndtoolDockingTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolDockingTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolDockingTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_SetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_GetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEndtoolRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEndtoolRS485Tx() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_GetEndtoolRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndtoolLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndtoolLedDim() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_SetEndtoolLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::LedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetIOBoardRx() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_SetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IOBoardRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIOBoardTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIOBoardTx() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_GetIOBoardTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIOBoardRx() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_GetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDI() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalInput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDO() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalOutput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDO() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIODigitalOutput* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_GetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProfileVelSDO() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_GetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProfileAccSDO() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProfileDecSDO() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_GetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_SetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetProfileVelSDO() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_SetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetProfileAccSDO() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_SetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetProfileDecSDO() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_SetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRobotZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRobotZeroCount() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetRobotZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotZeroCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::RobotZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRobotZeroAsCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRobotZeroAsCurrent() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_SetRobotZeroAsCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRobotZeroAsCurrent(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMasterStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMasterStatus() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetMasterStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMasterStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::MasterStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMasterStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSlaveStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSlaveStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetSlaveStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSlaveStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRxDomainStatus() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetRxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRxDomainStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTxDomainStatus() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetTxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTxDomainStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsSystemReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsSystemReady() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_IsSystemReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSystemReady(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatSystemReady* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsSystemReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsServoOn() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_IsServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatServoOn* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsServoOn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSlaveTypeNum : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSlaveTypeNum() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetSlaveTypeNum() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveTypeNum(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveTypeNum* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSlaveTypeNum(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetOverflowCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetOverflowCount() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ResetOverflowCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetOverflowCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetOverflowCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServoRx() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoRx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServoRx() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoRx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServoTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServoTx() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetServoTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoTx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServoRxKeba() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_SetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndexKeba* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoRxKeba(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServoRxKeba() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoRxKeba(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServoTxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServoTxKeba() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetServoTxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoTxKeba(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServoOn() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_SetServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoOn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServoOff() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SetServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOff(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoOff(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServoMaxMotorSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServoMaxMotorSpeed() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_SetServoMaxMotorSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoMaxMotorSpeed(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoMaxMotorSpeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServoTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServoTemperature() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetServoTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTemperature(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTemp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoTemperature(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServoErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServoErrorCode() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetServoErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoErrorCode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoError* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServoErrorCode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetServo() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_ResetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetServo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCOREManualBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCOREManualBrake() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_SetCOREManualBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCOREManualBrake(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoBrake* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCOREManualBrake(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndtoolRx() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_SetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndtoolRx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndtoolRx() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_GetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolRx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndtoolTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndtoolTx() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetEndtoolTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolTx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndtoolDockingTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndtoolDockingTx() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_GetEndtoolDockingTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolDockingTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolDockingTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolDockingTx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_SetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndtoolRS485Rx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_GetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolRS485Rx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEndtoolRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEndtoolRS485Tx() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_GetEndtoolRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEndtoolRS485Tx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndtoolLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndtoolLedDim() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_SetEndtoolLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::LedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndtoolLedDim(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetIOBoardRx() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_SetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IOBoardRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetIOBoardRx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIOBoardTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIOBoardTx() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_GetIOBoardTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOBoardTx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIOBoardRx() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_GetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOBoardRx(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDI() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalInput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDO() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalOutput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDO() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIODigitalOutput* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_GetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMaxTorqueSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProfileVelSDO() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_GetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProfileVelSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProfileAccSDO() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProfileAccSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProfileDecSDO() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_GetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProfileDecSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_SetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMaxTorqueSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetProfileVelSDO() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_SetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileVelSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetProfileAccSDO() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_SetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileAccSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetProfileDecSDO() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_SetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileDecSDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRobotZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRobotZeroCount() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetRobotZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotZeroCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::RobotZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotZeroCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRobotZeroAsCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRobotZeroAsCurrent() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_SetRobotZeroAsCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRobotZeroAsCurrent(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRobotZeroAsCurrent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMasterStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMasterStatus() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMasterStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMasterStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMasterStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::MasterStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMasterStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSlaveStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSlaveStatus() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSlaveStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSlaveStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSlaveStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRxDomainStatus() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRxDomainStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRxDomainStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTxDomainStatus() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTxDomainStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTxDomainStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsSystemReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsSystemReady() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsSystemReady(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsSystemReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSystemReady(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatSystemReady* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsSystemReady(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsServoOn() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsServoOn(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatServoOn* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsServoOn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSlaveTypeNum : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSlaveTypeNum() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSlaveTypeNum(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSlaveTypeNum() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSlaveTypeNum(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveTypeNum* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSlaveTypeNum(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetOverflowCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetOverflowCount() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetOverflowCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetOverflowCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetOverflowCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetOverflowCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServoRx() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServoRx(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoRx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServoRx() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServoRx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoRx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServoTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServoTx() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServoTx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServoTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoTx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServoRxKeba() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServoRxKeba(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndexKeba* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoRxKeba(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServoRxKeba() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServoRxKeba(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoRxKeba(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServoTxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServoTxKeba() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServoTxKeba(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServoTxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoTxKeba(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServoOn() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServoOn(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoOn(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServoOff() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServoOff(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoOff(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoOff(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServoMaxMotorSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServoMaxMotorSpeed() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServoMaxMotorSpeed(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServoMaxMotorSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoMaxMotorSpeed(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoMaxMotorSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServoTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServoTemperature() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServoTemperature(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServoTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoTemperature(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTemp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoTemperature(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServoErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServoErrorCode() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServoErrorCode(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServoErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServoErrorCode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoError* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServoErrorCode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetServo() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetServo(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetServo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCOREManualBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCOREManualBrake() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCOREManualBrake(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCOREManualBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCOREManualBrake(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoBrake* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCOREManualBrake(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndtoolRx() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndtoolRx(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndtoolRx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndtoolRx() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndtoolRx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolRx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndtoolTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndtoolTx() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndtoolTx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndtoolTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolTx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndtoolDockingTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndtoolDockingTx() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndtoolDockingTx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndtoolDockingTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolDockingTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolDockingTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolDockingTx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndtoolRS485Rx(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndtoolRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndtoolRS485Rx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolRS485Rx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEndtoolRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEndtoolRS485Tx() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEndtoolRS485Tx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEndtoolRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEndtoolRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEndtoolRS485Tx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndtoolLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndtoolLedDim() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndtoolLedDim(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndtoolLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndtoolLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::LedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndtoolLedDim(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetIOBoardRx() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetIOBoardRx(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IOBoardRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetIOBoardRx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetIOBoardTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetIOBoardTx() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetIOBoardTx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetIOBoardTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIOBoardTx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetIOBoardRx() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetIOBoardRx(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIOBoardRx(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDI() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDI(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalInput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDO() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalOutput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDO() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIODigitalOutput* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMaxTorqueSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMaxTorqueSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetProfileVelSDO() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProfileVelSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProfileVelSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetProfileAccSDO() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProfileAccSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProfileAccSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetProfileDecSDO() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProfileDecSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProfileDecSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetMaxTorqueSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetMaxTorqueSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetProfileVelSDO() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetProfileVelSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileVelSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetProfileAccSDO() {
      ::grpc::Service::MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetProfileAccSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileAccSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetProfileDecSDO() {
      ::grpc::Service::MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetProfileDecSDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileDecSDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRobotZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRobotZeroCount() {
      ::grpc::Service::MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRobotZeroCount(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRobotZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotZeroCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::RobotZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRobotZeroCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRobotZeroAsCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRobotZeroAsCurrent() {
      ::grpc::Service::MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRobotZeroAsCurrent(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRobotZeroAsCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRobotZeroAsCurrent(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRobotZeroAsCurrent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMasterStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMasterStatus() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::MasterStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::MasterStatus>* streamer) {
                       return this->StreamedGetMasterStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMasterStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMasterStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::MasterStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMasterStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::MasterStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSlaveStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSlaveStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveStatus>* streamer) {
                       return this->StreamedGetSlaveStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSlaveStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSlaveStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSlaveStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::SlaveStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRxDomainStatus() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>* streamer) {
                       return this->StreamedGetRxDomainStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRxDomainStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EcatDomainStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTxDomainStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTxDomainStatus() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatDomainStatus>* streamer) {
                       return this->StreamedGetTxDomainStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTxDomainStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTxDomainStatus(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatDomainStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTxDomainStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EcatDomainStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsSystemReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsSystemReady() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatSystemReady>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatSystemReady>* streamer) {
                       return this->StreamedIsSystemReady(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsSystemReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsSystemReady(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatSystemReady* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsSystemReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EcatSystemReady>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsServoOn() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatServoOn>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EcatServoOn>* streamer) {
                       return this->StreamedIsServoOn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EcatServoOn* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsServoOn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EcatServoOn>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSlaveTypeNum : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSlaveTypeNum() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveTypeNum>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::SlaveTypeNum>* streamer) {
                       return this->StreamedGetSlaveTypeNum(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSlaveTypeNum() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSlaveTypeNum(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::SlaveTypeNum* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSlaveTypeNum(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::SlaveTypeNum>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetOverflowCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetOverflowCount() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedResetOverflowCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetOverflowCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetOverflowCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetOverflowCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServoRx() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoRxIndex, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoRxIndex, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetServoRx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServoRx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoRxIndex,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServoRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServoRx() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRx>* streamer) {
                       return this->StreamedGetServoRx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServoRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServoRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServoRx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::ServoRx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServoTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServoTx() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTx>* streamer) {
                       return this->StreamedGetServoTx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServoTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServoTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServoTx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::ServoTx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServoRxKeba() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoRxIndexKeba, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoRxIndexKeba, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetServoRxKeba(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoRxIndexKeba* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServoRxKeba(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoRxIndexKeba,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServoRxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServoRxKeba() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRxKeba>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoRxKeba>* streamer) {
                       return this->StreamedGetServoRxKeba(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServoRxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServoRxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoRxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServoRxKeba(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::ServoRxKeba>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServoTxKeba : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServoTxKeba() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTxKeba>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTxKeba>* streamer) {
                       return this->StreamedGetServoTxKeba(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServoTxKeba() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServoTxKeba(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTxKeba* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServoTxKeba(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::ServoTxKeba>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServoOn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServoOn() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetServoOn(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServoOn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServoOn(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServoOn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServoOff() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetServoOff(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServoOff(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServoOff(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServoMaxMotorSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServoMaxMotorSpeed() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetServoMaxMotorSpeed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServoMaxMotorSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServoMaxMotorSpeed(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServoMaxMotorSpeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoParam,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServoTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServoTemperature() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTemp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoTemp>* streamer) {
                       return this->StreamedGetServoTemperature(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServoTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServoTemperature(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoTemp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServoTemperature(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::ServoTemp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServoErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServoErrorCode() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoError>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::ServoError>* streamer) {
                       return this->StreamedGetServoErrorCode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServoErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServoErrorCode(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::ServoError* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServoErrorCode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::ServoError>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetServo() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedResetServo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetServo(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetServo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCOREManualBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCOREManualBrake() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoBrake, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoBrake, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetCOREManualBrake(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCOREManualBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCOREManualBrake(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoBrake* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCOREManualBrake(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoBrake,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndtoolRx() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EndtoolRx, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EndtoolRx, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetEndtoolRx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndtoolRx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EndtoolRx,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndtoolRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndtoolRx() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRx>* streamer) {
                       return this->StreamedGetEndtoolRx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndtoolRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndtoolRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndtoolRx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolRx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndtoolTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndtoolTx() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolTx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolTx>* streamer) {
                       return this->StreamedGetEndtoolTx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndtoolTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndtoolTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndtoolTx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolTx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndtoolDockingTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndtoolDockingTx() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolDockingTx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolDockingTx>* streamer) {
                       return this->StreamedGetEndtoolDockingTx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndtoolDockingTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndtoolDockingTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolDockingTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndtoolDockingTx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolDockingTx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EndtoolRS485Rx, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetEndtoolRS485Rx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EndtoolRS485Rx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndtoolRS485Rx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EndtoolRS485Rx,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndtoolRS485Rx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndtoolRS485Rx() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Rx>* streamer) {
                       return this->StreamedGetEndtoolRS485Rx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndtoolRS485Rx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndtoolRS485Rx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Rx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndtoolRS485Rx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolRS485Rx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEndtoolRS485Tx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEndtoolRS485Tx() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::EndtoolRS485Tx>* streamer) {
                       return this->StreamedGetEndtoolRS485Tx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEndtoolRS485Tx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEndtoolRS485Tx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::EndtoolRS485Tx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEndtoolRS485Tx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::EndtoolRS485Tx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndtoolLedDim : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndtoolLedDim() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::LedDim, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::LedDim, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetEndtoolLedDim(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndtoolLedDim() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndtoolLedDim(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::LedDim* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndtoolLedDim(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::LedDim,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetIOBoardRx() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::IOBoardRx, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::IOBoardRx, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetIOBoardRx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::IOBoardRx* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetIOBoardRx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::IOBoardRx,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIOBoardTx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIOBoardTx() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardTx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardTx>* streamer) {
                       return this->StreamedGetIOBoardTx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetIOBoardTx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIOBoardTx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardTx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIOBoardTx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::IOBoardTx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIOBoardRx : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIOBoardRx() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardRx>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::Empty, ::Nrmk::IndyFramework::IOBoardRx>* streamer) {
                       return this->StreamedGetIOBoardRx(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetIOBoardRx() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIOBoardRx(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::Empty* /*request*/, ::Nrmk::IndyFramework::IOBoardRx* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIOBoardRx(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::Empty,::Nrmk::IndyFramework::IOBoardRx>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDI() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalInput>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalInput>* streamer) {
                       return this->StreamedGetDI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDI(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalInput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::DIOIndex,::Nrmk::IndyFramework::DIODigitalInput>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDO() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalOutput>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::DIOIndex, ::Nrmk::IndyFramework::DIODigitalOutput>* streamer) {
                       return this->StreamedGetDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIOIndex* /*request*/, ::Nrmk::IndyFramework::DIODigitalOutput* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::DIOIndex,::Nrmk::IndyFramework::DIODigitalOutput>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDO() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::DIODigitalOutput, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::DIODigitalOutput, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::DIODigitalOutput* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::DIODigitalOutput,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* streamer) {
                       return this->StreamedGetMaxTorqueSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMaxTorqueSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EcatIndex,::Nrmk::IndyFramework::SDOIntVal>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProfileVelSDO() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* streamer) {
                       return this->StreamedGetProfileVelSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProfileVelSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EcatIndex,::Nrmk::IndyFramework::SDOIntVal>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProfileAccSDO() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* streamer) {
                       return this->StreamedGetProfileAccSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProfileAccSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EcatIndex,::Nrmk::IndyFramework::SDOIntVal>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProfileDecSDO() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::EcatIndex, ::Nrmk::IndyFramework::SDOIntVal>* streamer) {
                       return this->StreamedGetProfileDecSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::EcatIndex* /*request*/, ::Nrmk::IndyFramework::SDOIntVal* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProfileDecSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::EcatIndex,::Nrmk::IndyFramework::SDOIntVal>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMaxTorqueSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetMaxTorqueSDO() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetMaxTorqueSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetMaxTorqueSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMaxTorqueSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMaxTorqueSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoParam,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetProfileVelSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetProfileVelSDO() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetProfileVelSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetProfileVelSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetProfileVelSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetProfileVelSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoParam,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetProfileAccSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetProfileAccSDO() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetProfileAccSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetProfileAccSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetProfileAccSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetProfileAccSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoParam,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetProfileDecSDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetProfileDecSDO() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoParam, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetProfileDecSDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetProfileDecSDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetProfileDecSDO(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoParam* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetProfileDecSDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoParam,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRobotZeroCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRobotZeroCount() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::RobotZeroCount>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::RobotZeroCount>* streamer) {
                       return this->StreamedGetRobotZeroCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRobotZeroCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRobotZeroCount(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::RobotZeroCount* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRobotZeroCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::RobotZeroCount>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRobotZeroAsCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRobotZeroAsCurrent() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Nrmk::IndyFramework::ServoIndex, ::Nrmk::IndyFramework::Empty>* streamer) {
                       return this->StreamedSetRobotZeroAsCurrent(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRobotZeroAsCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRobotZeroAsCurrent(::grpc::ServerContext* /*context*/, const ::Nrmk::IndyFramework::ServoIndex* /*request*/, ::Nrmk::IndyFramework::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRobotZeroAsCurrent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Nrmk::IndyFramework::ServoIndex,::Nrmk::IndyFramework::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetMasterStatus<WithStreamedUnaryMethod_GetSlaveStatus<WithStreamedUnaryMethod_GetRxDomainStatus<WithStreamedUnaryMethod_GetTxDomainStatus<WithStreamedUnaryMethod_IsSystemReady<WithStreamedUnaryMethod_IsServoOn<WithStreamedUnaryMethod_GetSlaveTypeNum<WithStreamedUnaryMethod_ResetOverflowCount<WithStreamedUnaryMethod_SetServoRx<WithStreamedUnaryMethod_GetServoRx<WithStreamedUnaryMethod_GetServoTx<WithStreamedUnaryMethod_SetServoRxKeba<WithStreamedUnaryMethod_GetServoRxKeba<WithStreamedUnaryMethod_GetServoTxKeba<WithStreamedUnaryMethod_SetServoOn<WithStreamedUnaryMethod_SetServoOff<WithStreamedUnaryMethod_SetServoMaxMotorSpeed<WithStreamedUnaryMethod_GetServoTemperature<WithStreamedUnaryMethod_GetServoErrorCode<WithStreamedUnaryMethod_ResetServo<WithStreamedUnaryMethod_SetCOREManualBrake<WithStreamedUnaryMethod_SetEndtoolRx<WithStreamedUnaryMethod_GetEndtoolRx<WithStreamedUnaryMethod_GetEndtoolTx<WithStreamedUnaryMethod_GetEndtoolDockingTx<WithStreamedUnaryMethod_SetEndtoolRS485Rx<WithStreamedUnaryMethod_GetEndtoolRS485Rx<WithStreamedUnaryMethod_GetEndtoolRS485Tx<WithStreamedUnaryMethod_SetEndtoolLedDim<WithStreamedUnaryMethod_SetIOBoardRx<WithStreamedUnaryMethod_GetIOBoardTx<WithStreamedUnaryMethod_GetIOBoardRx<WithStreamedUnaryMethod_GetDI<WithStreamedUnaryMethod_GetDO<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_GetMaxTorqueSDO<WithStreamedUnaryMethod_GetProfileVelSDO<WithStreamedUnaryMethod_GetProfileAccSDO<WithStreamedUnaryMethod_GetProfileDecSDO<WithStreamedUnaryMethod_SetMaxTorqueSDO<WithStreamedUnaryMethod_SetProfileVelSDO<WithStreamedUnaryMethod_SetProfileAccSDO<WithStreamedUnaryMethod_SetProfileDecSDO<WithStreamedUnaryMethod_GetRobotZeroCount<WithStreamedUnaryMethod_SetRobotZeroAsCurrent<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetMasterStatus<WithStreamedUnaryMethod_GetSlaveStatus<WithStreamedUnaryMethod_GetRxDomainStatus<WithStreamedUnaryMethod_GetTxDomainStatus<WithStreamedUnaryMethod_IsSystemReady<WithStreamedUnaryMethod_IsServoOn<WithStreamedUnaryMethod_GetSlaveTypeNum<WithStreamedUnaryMethod_ResetOverflowCount<WithStreamedUnaryMethod_SetServoRx<WithStreamedUnaryMethod_GetServoRx<WithStreamedUnaryMethod_GetServoTx<WithStreamedUnaryMethod_SetServoRxKeba<WithStreamedUnaryMethod_GetServoRxKeba<WithStreamedUnaryMethod_GetServoTxKeba<WithStreamedUnaryMethod_SetServoOn<WithStreamedUnaryMethod_SetServoOff<WithStreamedUnaryMethod_SetServoMaxMotorSpeed<WithStreamedUnaryMethod_GetServoTemperature<WithStreamedUnaryMethod_GetServoErrorCode<WithStreamedUnaryMethod_ResetServo<WithStreamedUnaryMethod_SetCOREManualBrake<WithStreamedUnaryMethod_SetEndtoolRx<WithStreamedUnaryMethod_GetEndtoolRx<WithStreamedUnaryMethod_GetEndtoolTx<WithStreamedUnaryMethod_GetEndtoolDockingTx<WithStreamedUnaryMethod_SetEndtoolRS485Rx<WithStreamedUnaryMethod_GetEndtoolRS485Rx<WithStreamedUnaryMethod_GetEndtoolRS485Tx<WithStreamedUnaryMethod_SetEndtoolLedDim<WithStreamedUnaryMethod_SetIOBoardRx<WithStreamedUnaryMethod_GetIOBoardTx<WithStreamedUnaryMethod_GetIOBoardRx<WithStreamedUnaryMethod_GetDI<WithStreamedUnaryMethod_GetDO<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_GetMaxTorqueSDO<WithStreamedUnaryMethod_GetProfileVelSDO<WithStreamedUnaryMethod_GetProfileAccSDO<WithStreamedUnaryMethod_GetProfileDecSDO<WithStreamedUnaryMethod_SetMaxTorqueSDO<WithStreamedUnaryMethod_SetProfileVelSDO<WithStreamedUnaryMethod_SetProfileAccSDO<WithStreamedUnaryMethod_SetProfileDecSDO<WithStreamedUnaryMethod_GetRobotZeroCount<WithStreamedUnaryMethod_SetRobotZeroAsCurrent<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace IndyFramework
}  // namespace Nrmk


#endif  // GRPC_ethercat_2eproto__INCLUDED
