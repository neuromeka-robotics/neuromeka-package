// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: shared_msgs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_shared_5fmsgs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_shared_5fmsgs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_shared_5fmsgs_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_shared_5fmsgs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_shared_5fmsgs_2eproto;
namespace IndyFramework {
namespace Protobuf {
namespace Shared {
class AnalogSignal;
struct AnalogSignalDefaultTypeInternal;
extern AnalogSignalDefaultTypeInternal _AnalogSignal_default_instance_;
class BoolVariable;
struct BoolVariableDefaultTypeInternal;
extern BoolVariableDefaultTypeInternal _BoolVariable_default_instance_;
class DigitalSignal;
struct DigitalSignalDefaultTypeInternal;
extern DigitalSignalDefaultTypeInternal _DigitalSignal_default_instance_;
class FloatVariable;
struct FloatVariableDefaultTypeInternal;
extern FloatVariableDefaultTypeInternal _FloatVariable_default_instance_;
class IntVariable;
struct IntVariableDefaultTypeInternal;
extern IntVariableDefaultTypeInternal _IntVariable_default_instance_;
class JPosVariable;
struct JPosVariableDefaultTypeInternal;
extern JPosVariableDefaultTypeInternal _JPosVariable_default_instance_;
class ModbusServer;
struct ModbusServerDefaultTypeInternal;
extern ModbusServerDefaultTypeInternal _ModbusServer_default_instance_;
class ModbusVariable;
struct ModbusVariableDefaultTypeInternal;
extern ModbusVariableDefaultTypeInternal _ModbusVariable_default_instance_;
class MoveSJPoint;
struct MoveSJPointDefaultTypeInternal;
extern MoveSJPointDefaultTypeInternal _MoveSJPoint_default_instance_;
class MoveSJTPoint;
struct MoveSJTPointDefaultTypeInternal;
extern MoveSJTPointDefaultTypeInternal _MoveSJTPoint_default_instance_;
class MoveSLPoint;
struct MoveSLPointDefaultTypeInternal;
extern MoveSLPointDefaultTypeInternal _MoveSLPoint_default_instance_;
class MoveSLTPoint;
struct MoveSLTPointDefaultTypeInternal;
extern MoveSLTPointDefaultTypeInternal _MoveSLTPoint_default_instance_;
class NamedJointPosition;
struct NamedJointPositionDefaultTypeInternal;
extern NamedJointPositionDefaultTypeInternal _NamedJointPosition_default_instance_;
class NamedReferencePosition;
struct NamedReferencePositionDefaultTypeInternal;
extern NamedReferencePositionDefaultTypeInternal _NamedReferencePosition_default_instance_;
class NamedTaskPosition;
struct NamedTaskPositionDefaultTypeInternal;
extern NamedTaskPositionDefaultTypeInternal _NamedTaskPosition_default_instance_;
class PalletPoint;
struct PalletPointDefaultTypeInternal;
extern PalletPointDefaultTypeInternal _PalletPoint_default_instance_;
class TPosVariable;
struct TPosVariableDefaultTypeInternal;
extern TPosVariableDefaultTypeInternal _TPosVariable_default_instance_;
class Tool;
struct ToolDefaultTypeInternal;
extern ToolDefaultTypeInternal _Tool_default_instance_;
class VisionServer;
struct VisionServerDefaultTypeInternal;
extern VisionServerDefaultTypeInternal _VisionServer_default_instance_;
}  // namespace Shared
}  // namespace Protobuf
}  // namespace IndyFramework
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace IndyFramework {
namespace Protobuf {
namespace Shared {
enum Tool_ToolType : int {
  Tool_ToolType_DIGITAL_OUTPUT = 0,
  Tool_ToolType_MODBUS = 1,
  Tool_ToolType_Tool_ToolType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Tool_ToolType_Tool_ToolType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Tool_ToolType_IsValid(int value);
constexpr Tool_ToolType Tool_ToolType_ToolType_MIN = static_cast<Tool_ToolType>(0);
constexpr Tool_ToolType Tool_ToolType_ToolType_MAX = static_cast<Tool_ToolType>(1);
constexpr int Tool_ToolType_ToolType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Tool_ToolType_descriptor();
template <typename T>
const std::string& Tool_ToolType_Name(T value) {
  static_assert(std::is_same<T, Tool_ToolType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ToolType_Name().");
  return Tool_ToolType_Name(static_cast<Tool_ToolType>(value));
}
template <>
inline const std::string& Tool_ToolType_Name(Tool_ToolType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Tool_ToolType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Tool_ToolType_Parse(absl::string_view name, Tool_ToolType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tool_ToolType>(
      Tool_ToolType_descriptor(), name, value);
}
enum VisionServer_VisionServerType : int {
  VisionServer_VisionServerType_INDYEYE = 0,
  VisionServer_VisionServerType_PICKIT = 1,
  VisionServer_VisionServerType_OMRON = 2,
  VisionServer_VisionServerType_VisionServer_VisionServerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VisionServer_VisionServerType_VisionServer_VisionServerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VisionServer_VisionServerType_IsValid(int value);
constexpr VisionServer_VisionServerType VisionServer_VisionServerType_VisionServerType_MIN = static_cast<VisionServer_VisionServerType>(0);
constexpr VisionServer_VisionServerType VisionServer_VisionServerType_VisionServerType_MAX = static_cast<VisionServer_VisionServerType>(2);
constexpr int VisionServer_VisionServerType_VisionServerType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VisionServer_VisionServerType_descriptor();
template <typename T>
const std::string& VisionServer_VisionServerType_Name(T value) {
  static_assert(std::is_same<T, VisionServer_VisionServerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VisionServerType_Name().");
  return VisionServer_VisionServerType_Name(static_cast<VisionServer_VisionServerType>(value));
}
template <>
inline const std::string& VisionServer_VisionServerType_Name(VisionServer_VisionServerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VisionServer_VisionServerType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VisionServer_VisionServerType_Parse(absl::string_view name, VisionServer_VisionServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisionServer_VisionServerType>(
      VisionServer_VisionServerType_descriptor(), name, value);
}
enum MotionState : int {
  IDLING = 0,
  RUNNING = 1,
  PAUSING = 2,
  STOPPING = 3,
  MotionState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MotionState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MotionState_IsValid(int value);
constexpr MotionState MotionState_MIN = static_cast<MotionState>(0);
constexpr MotionState MotionState_MAX = static_cast<MotionState>(3);
constexpr int MotionState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
MotionState_descriptor();
template <typename T>
const std::string& MotionState_Name(T value) {
  static_assert(std::is_same<T, MotionState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MotionState_Name().");
  return MotionState_Name(static_cast<MotionState>(value));
}
template <>
inline const std::string& MotionState_Name(MotionState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MotionState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool MotionState_Parse(absl::string_view name, MotionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionState>(
      MotionState_descriptor(), name, value);
}
enum EndToolPortType : int {
  END_TOOL_PORT_TYPE_A = 0,
  END_TOOL_PORT_TYPE_B = 1,
  END_TOOL_PORT_TYPE_AB = 2,
  END_TOOL_PORT_TYPE_REVC = 3,
  EndToolPortType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EndToolPortType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EndToolPortType_IsValid(int value);
constexpr EndToolPortType EndToolPortType_MIN = static_cast<EndToolPortType>(0);
constexpr EndToolPortType EndToolPortType_MAX = static_cast<EndToolPortType>(3);
constexpr int EndToolPortType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
EndToolPortType_descriptor();
template <typename T>
const std::string& EndToolPortType_Name(T value) {
  static_assert(std::is_same<T, EndToolPortType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EndToolPortType_Name().");
  return EndToolPortType_Name(static_cast<EndToolPortType>(value));
}
template <>
inline const std::string& EndToolPortType_Name(EndToolPortType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EndToolPortType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool EndToolPortType_Parse(absl::string_view name, EndToolPortType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EndToolPortType>(
      EndToolPortType_descriptor(), name, value);
}
enum ControlBoxType : int {
  NORMAL_2 = 0,
  NORMAL_3 = 1,
  KEY_2 = 2,
  KEY_3 = 3,
  ControlBoxType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControlBoxType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControlBoxType_IsValid(int value);
constexpr ControlBoxType ControlBoxType_MIN = static_cast<ControlBoxType>(0);
constexpr ControlBoxType ControlBoxType_MAX = static_cast<ControlBoxType>(3);
constexpr int ControlBoxType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ControlBoxType_descriptor();
template <typename T>
const std::string& ControlBoxType_Name(T value) {
  static_assert(std::is_same<T, ControlBoxType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControlBoxType_Name().");
  return ControlBoxType_Name(static_cast<ControlBoxType>(value));
}
template <>
inline const std::string& ControlBoxType_Name(ControlBoxType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ControlBoxType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ControlBoxType_Parse(absl::string_view name, ControlBoxType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlBoxType>(
      ControlBoxType_descriptor(), name, value);
}
enum VariableType : int {
  VariableTypeInt = 0,
  VariableTypeFloat = 1,
  VariableTypeBool = 2,
  VariableTypeModbus = 3,
  VariableTypeJPos = 4,
  VariableTypeTPos = 5,
  VariableType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VariableType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VariableType_IsValid(int value);
constexpr VariableType VariableType_MIN = static_cast<VariableType>(0);
constexpr VariableType VariableType_MAX = static_cast<VariableType>(5);
constexpr int VariableType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
VariableType_descriptor();
template <typename T>
const std::string& VariableType_Name(T value) {
  static_assert(std::is_same<T, VariableType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VariableType_Name().");
  return VariableType_Name(static_cast<VariableType>(value));
}
template <>
inline const std::string& VariableType_Name(VariableType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VariableType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool VariableType_Parse(absl::string_view name, VariableType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VariableType>(
      VariableType_descriptor(), name, value);
}
enum ProgramState : int {
  PROGRAM_STATE_STOPPED = 0,
  PROGRAM_STATE_RUNNING = 1,
  PROGRAM_STATE_PAUSED = 2,
  PROGRAM_STATE_ERROR = 3,
  PROGRAM_STATE_COLLISION = 4,
  ProgramState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProgramState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProgramState_IsValid(int value);
constexpr ProgramState ProgramState_MIN = static_cast<ProgramState>(0);
constexpr ProgramState ProgramState_MAX = static_cast<ProgramState>(4);
constexpr int ProgramState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ProgramState_descriptor();
template <typename T>
const std::string& ProgramState_Name(T value) {
  static_assert(std::is_same<T, ProgramState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProgramState_Name().");
  return ProgramState_Name(static_cast<ProgramState>(value));
}
template <>
inline const std::string& ProgramState_Name(ProgramState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProgramState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ProgramState_Parse(absl::string_view name, ProgramState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProgramState>(
      ProgramState_descriptor(), name, value);
}
enum ProgramControl : int {
  PROGRAM_CTRL_NONE = 0,
  PROGRAM_CTRL_RUN = 1,
  PROGRAM_CTRL_PAUSE = 2,
  PROGRAM_CTRL_STOP = 3,
  ProgramControl_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProgramControl_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProgramControl_IsValid(int value);
constexpr ProgramControl ProgramControl_MIN = static_cast<ProgramControl>(0);
constexpr ProgramControl ProgramControl_MAX = static_cast<ProgramControl>(3);
constexpr int ProgramControl_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ProgramControl_descriptor();
template <typename T>
const std::string& ProgramControl_Name(T value) {
  static_assert(std::is_same<T, ProgramControl>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProgramControl_Name().");
  return ProgramControl_Name(static_cast<ProgramControl>(value));
}
template <>
inline const std::string& ProgramControl_Name(ProgramControl value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProgramControl_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ProgramControl_Parse(absl::string_view name, ProgramControl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProgramControl>(
      ProgramControl_descriptor(), name, value);
}
enum ProgramCategory : int {
  PROGRAM_CAT_NORMAL = 0,
  PROGRAM_CAT_INDEX = 1,
  ProgramCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProgramCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProgramCategory_IsValid(int value);
constexpr ProgramCategory ProgramCategory_MIN = static_cast<ProgramCategory>(0);
constexpr ProgramCategory ProgramCategory_MAX = static_cast<ProgramCategory>(1);
constexpr int ProgramCategory_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ProgramCategory_descriptor();
template <typename T>
const std::string& ProgramCategory_Name(T value) {
  static_assert(std::is_same<T, ProgramCategory>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProgramCategory_Name().");
  return ProgramCategory_Name(static_cast<ProgramCategory>(value));
}
template <>
inline const std::string& ProgramCategory_Name(ProgramCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProgramCategory_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ProgramCategory_Parse(absl::string_view name, ProgramCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProgramCategory>(
      ProgramCategory_descriptor(), name, value);
}
enum JointBaseType : int {
  JOINT_BASE_TYPE_ABSOLUTE = 0,
  JOINT_BASE_TYPE_RELATIVE = 1,
  JointBaseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  JointBaseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool JointBaseType_IsValid(int value);
constexpr JointBaseType JointBaseType_MIN = static_cast<JointBaseType>(0);
constexpr JointBaseType JointBaseType_MAX = static_cast<JointBaseType>(1);
constexpr int JointBaseType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
JointBaseType_descriptor();
template <typename T>
const std::string& JointBaseType_Name(T value) {
  static_assert(std::is_same<T, JointBaseType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JointBaseType_Name().");
  return JointBaseType_Name(static_cast<JointBaseType>(value));
}
template <>
inline const std::string& JointBaseType_Name(JointBaseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<JointBaseType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool JointBaseType_Parse(absl::string_view name, JointBaseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JointBaseType>(
      JointBaseType_descriptor(), name, value);
}
enum TaskBaseType : int {
  TASK_BASE_TYPE_ABSOLUTE = 0,
  TASK_BASE_TYPE_RELATIVE = 1,
  TASK_BASE_TYPE_TCP = 2,
  TaskBaseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskBaseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskBaseType_IsValid(int value);
constexpr TaskBaseType TaskBaseType_MIN = static_cast<TaskBaseType>(0);
constexpr TaskBaseType TaskBaseType_MAX = static_cast<TaskBaseType>(2);
constexpr int TaskBaseType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TaskBaseType_descriptor();
template <typename T>
const std::string& TaskBaseType_Name(T value) {
  static_assert(std::is_same<T, TaskBaseType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskBaseType_Name().");
  return TaskBaseType_Name(static_cast<TaskBaseType>(value));
}
template <>
inline const std::string& TaskBaseType_Name(TaskBaseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskBaseType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TaskBaseType_Parse(absl::string_view name, TaskBaseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskBaseType>(
      TaskBaseType_descriptor(), name, value);
}
enum BlendingType : int {
  BLENDING_TYPE_NONE = 0,
  BLENDING_TYPE_OVERRIDE = 1,
  BLENDING_TYPE_DUPLICATE = 2,
  BLENDING_TYPE_INTERRUPT = 3,
  BlendingType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BlendingType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BlendingType_IsValid(int value);
constexpr BlendingType BlendingType_MIN = static_cast<BlendingType>(0);
constexpr BlendingType BlendingType_MAX = static_cast<BlendingType>(3);
constexpr int BlendingType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
BlendingType_descriptor();
template <typename T>
const std::string& BlendingType_Name(T value) {
  static_assert(std::is_same<T, BlendingType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BlendingType_Name().");
  return BlendingType_Name(static_cast<BlendingType>(value));
}
template <>
inline const std::string& BlendingType_Name(BlendingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BlendingType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool BlendingType_Parse(absl::string_view name, BlendingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlendingType>(
      BlendingType_descriptor(), name, value);
}
enum CircularSettingType : int {
  POINT_SET = 0,
  CENTER_AXIS = 1,
  CircularSettingType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CircularSettingType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CircularSettingType_IsValid(int value);
constexpr CircularSettingType CircularSettingType_MIN = static_cast<CircularSettingType>(0);
constexpr CircularSettingType CircularSettingType_MAX = static_cast<CircularSettingType>(1);
constexpr int CircularSettingType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
CircularSettingType_descriptor();
template <typename T>
const std::string& CircularSettingType_Name(T value) {
  static_assert(std::is_same<T, CircularSettingType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CircularSettingType_Name().");
  return CircularSettingType_Name(static_cast<CircularSettingType>(value));
}
template <>
inline const std::string& CircularSettingType_Name(CircularSettingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CircularSettingType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool CircularSettingType_Parse(absl::string_view name, CircularSettingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CircularSettingType>(
      CircularSettingType_descriptor(), name, value);
}
enum CircularMovingType : int {
  CONSTANT = 0,
  RADIAL = 1,
  SMOOTH = 2,
  CircularMovingType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CircularMovingType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CircularMovingType_IsValid(int value);
constexpr CircularMovingType CircularMovingType_MIN = static_cast<CircularMovingType>(0);
constexpr CircularMovingType CircularMovingType_MAX = static_cast<CircularMovingType>(2);
constexpr int CircularMovingType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CircularMovingType_descriptor();
template <typename T>
const std::string& CircularMovingType_Name(T value) {
  static_assert(std::is_same<T, CircularMovingType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CircularMovingType_Name().");
  return CircularMovingType_Name(static_cast<CircularMovingType>(value));
}
template <>
inline const std::string& CircularMovingType_Name(CircularMovingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CircularMovingType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CircularMovingType_Parse(absl::string_view name, CircularMovingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CircularMovingType>(
      CircularMovingType_descriptor(), name, value);
}
enum TrajState : int {
  TRAJSTATE_NONE = 0,
  TRAJSTATE_INIT = 1,
  TRAJSTATE_CALC = 2,
  TRAJSTATE_STBY = 3,
  TRAJSTATE_ACC = 4,
  TRAJSTATE_CRZ = 5,
  TRAJSTATE_DEC = 6,
  TRAJSTATE_CANC = 7,
  TRAJSTATE_FIN = 8,
  TRAJSTATE_ERR = 9,
  TrajState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrajState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrajState_IsValid(int value);
constexpr TrajState TrajState_MIN = static_cast<TrajState>(0);
constexpr TrajState TrajState_MAX = static_cast<TrajState>(9);
constexpr int TrajState_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
TrajState_descriptor();
template <typename T>
const std::string& TrajState_Name(T value) {
  static_assert(std::is_same<T, TrajState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TrajState_Name().");
  return TrajState_Name(static_cast<TrajState>(value));
}
template <>
inline const std::string& TrajState_Name(TrajState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrajState_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool TrajState_Parse(absl::string_view name, TrajState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajState>(
      TrajState_descriptor(), name, value);
}
enum TrajCondition : int {
  TRAJ_STARTED = 0,
  TRAJ_ACC_DONE = 1,
  TRAJ_CRZ_DONE = 2,
  TRAJ_DEC_DONE = 3,
  TrajCondition_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrajCondition_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrajCondition_IsValid(int value);
constexpr TrajCondition TrajCondition_MIN = static_cast<TrajCondition>(0);
constexpr TrajCondition TrajCondition_MAX = static_cast<TrajCondition>(3);
constexpr int TrajCondition_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TrajCondition_descriptor();
template <typename T>
const std::string& TrajCondition_Name(T value) {
  static_assert(std::is_same<T, TrajCondition>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TrajCondition_Name().");
  return TrajCondition_Name(static_cast<TrajCondition>(value));
}
template <>
inline const std::string& TrajCondition_Name(TrajCondition value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrajCondition_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TrajCondition_Parse(absl::string_view name, TrajCondition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajCondition>(
      TrajCondition_descriptor(), name, value);
}
enum CollisionPolicy : int {
  COLLISION_POLICY_NO_DETECT = 0,
  COLLISION_POLICY_PAUSE = 1,
  COLLISION_POLICY_RESUME_AFTER_SLEEP = 2,
  COLLISION_POLICY_STOP = 3,
  CollisionPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CollisionPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CollisionPolicy_IsValid(int value);
constexpr CollisionPolicy CollisionPolicy_MIN = static_cast<CollisionPolicy>(0);
constexpr CollisionPolicy CollisionPolicy_MAX = static_cast<CollisionPolicy>(3);
constexpr int CollisionPolicy_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
CollisionPolicy_descriptor();
template <typename T>
const std::string& CollisionPolicy_Name(T value) {
  static_assert(std::is_same<T, CollisionPolicy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CollisionPolicy_Name().");
  return CollisionPolicy_Name(static_cast<CollisionPolicy>(value));
}
template <>
inline const std::string& CollisionPolicy_Name(CollisionPolicy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CollisionPolicy_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool CollisionPolicy_Parse(absl::string_view name, CollisionPolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollisionPolicy>(
      CollisionPolicy_descriptor(), name, value);
}
enum StopCategory : int {
  STOP_CAT_IMMEDIATE_BRAKE = 0,
  STOP_CAT_REDUCE_SPEED_AND_BRAKE = 1,
  STOP_CAT_REDUCE_SPEED = 2,
  StopCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StopCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StopCategory_IsValid(int value);
constexpr StopCategory StopCategory_MIN = static_cast<StopCategory>(0);
constexpr StopCategory StopCategory_MAX = static_cast<StopCategory>(2);
constexpr int StopCategory_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
StopCategory_descriptor();
template <typename T>
const std::string& StopCategory_Name(T value) {
  static_assert(std::is_same<T, StopCategory>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StopCategory_Name().");
  return StopCategory_Name(static_cast<StopCategory>(value));
}
template <>
inline const std::string& StopCategory_Name(StopCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StopCategory_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool StopCategory_Parse(absl::string_view name, StopCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopCategory>(
      StopCategory_descriptor(), name, value);
}
enum PauseCategory : int {
  PAUSE_CAT_REDUCE_SPEED = 0,
  PAUSE_CAT_IMMEDIATE = 1,
  PauseCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PauseCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PauseCategory_IsValid(int value);
constexpr PauseCategory PauseCategory_MIN = static_cast<PauseCategory>(0);
constexpr PauseCategory PauseCategory_MAX = static_cast<PauseCategory>(1);
constexpr int PauseCategory_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PauseCategory_descriptor();
template <typename T>
const std::string& PauseCategory_Name(T value) {
  static_assert(std::is_same<T, PauseCategory>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PauseCategory_Name().");
  return PauseCategory_Name(static_cast<PauseCategory>(value));
}
template <>
inline const std::string& PauseCategory_Name(PauseCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PauseCategory_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PauseCategory_Parse(absl::string_view name, PauseCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PauseCategory>(
      PauseCategory_descriptor(), name, value);
}
enum EyeCommandType : int {
  EYE_COMMAND_TYPE_DETECT = 0,
  EYE_COMMAND_TYPE_EXTRACT = 1,
  EyeCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EyeCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EyeCommandType_IsValid(int value);
constexpr EyeCommandType EyeCommandType_MIN = static_cast<EyeCommandType>(0);
constexpr EyeCommandType EyeCommandType_MAX = static_cast<EyeCommandType>(1);
constexpr int EyeCommandType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
EyeCommandType_descriptor();
template <typename T>
const std::string& EyeCommandType_Name(T value) {
  static_assert(std::is_same<T, EyeCommandType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EyeCommandType_Name().");
  return EyeCommandType_Name(static_cast<EyeCommandType>(value));
}
template <>
inline const std::string& EyeCommandType_Name(EyeCommandType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EyeCommandType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool EyeCommandType_Parse(absl::string_view name, EyeCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EyeCommandType>(
      EyeCommandType_descriptor(), name, value);
}
enum DIConfigFunc : int {
  DI_RUN_INDEX_PROGRAM = 0,
  DI_STOP_PROGRAM = 1,
  DI_PAUSE_PROGRAM = 2,
  DI_RESUME_PROGRAM = 3,
  DI_RECOVER = 4,
  DI_STOP_SLOW = 5,
  DI_STOP_IMMADIATE = 6,
  DI_MOVE_TO_HOME = 7,
  DI_MOVE_TO_ZERO = 8,
  DI_DIRECT_TEACHING_MODE_ON = 9,
  DI_DIRECT_TEACHING_MODE_OFF = 10,
  DI_REDUCED_SPEED_MODE_ON = 11,
  DI_REDUCED_SPEED_MODE_OFF = 12,
  DIConfigFunc_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DIConfigFunc_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DIConfigFunc_IsValid(int value);
constexpr DIConfigFunc DIConfigFunc_MIN = static_cast<DIConfigFunc>(0);
constexpr DIConfigFunc DIConfigFunc_MAX = static_cast<DIConfigFunc>(12);
constexpr int DIConfigFunc_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
DIConfigFunc_descriptor();
template <typename T>
const std::string& DIConfigFunc_Name(T value) {
  static_assert(std::is_same<T, DIConfigFunc>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DIConfigFunc_Name().");
  return DIConfigFunc_Name(static_cast<DIConfigFunc>(value));
}
template <>
inline const std::string& DIConfigFunc_Name(DIConfigFunc value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DIConfigFunc_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool DIConfigFunc_Parse(absl::string_view name, DIConfigFunc* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DIConfigFunc>(
      DIConfigFunc_descriptor(), name, value);
}
enum DOConfigState : int {
  DO_IS_IDLE = 0,
  DO_IS_MOVING = 1,
  DO_IS_VIOLATE = 2,
  DO_IS_RECOVER = 3,
  DO_IS_TEACHING = 4,
  DO_IS_COLLISION = 5,
  DO_IS_PROGRAM_RUNNING = 6,
  DO_IS_PROGRAM_PAUSED = 7,
  DOConfigState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DOConfigState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DOConfigState_IsValid(int value);
constexpr DOConfigState DOConfigState_MIN = static_cast<DOConfigState>(0);
constexpr DOConfigState DOConfigState_MAX = static_cast<DOConfigState>(7);
constexpr int DOConfigState_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
DOConfigState_descriptor();
template <typename T>
const std::string& DOConfigState_Name(T value) {
  static_assert(std::is_same<T, DOConfigState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DOConfigState_Name().");
  return DOConfigState_Name(static_cast<DOConfigState>(value));
}
template <>
inline const std::string& DOConfigState_Name(DOConfigState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DOConfigState_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool DOConfigState_Parse(absl::string_view name, DOConfigState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DOConfigState>(
      DOConfigState_descriptor(), name, value);
}
enum OpState : int {
  OP_SYSTEM_OFF = 0,
  OP_SYSTEM_ON = 1,
  OP_VIOLATE = 2,
  OP_RECOVER_HARD = 3,
  OP_RECOVER_SOFT = 4,
  OP_IDLE = 5,
  OP_MOVING = 6,
  OP_TEACHING = 7,
  OP_COLLISION = 8,
  OP_STOP_AND_OFF = 9,
  COMPLIANCE = 10,
  BRAKE_CONTROL = 11,
  SYSTEM_RESET = 12,
  SYSTEM_SWITCH = 13,
  OpState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OpState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OpState_IsValid(int value);
constexpr OpState OpState_MIN = static_cast<OpState>(0);
constexpr OpState OpState_MAX = static_cast<OpState>(13);
constexpr int OpState_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor*
OpState_descriptor();
template <typename T>
const std::string& OpState_Name(T value) {
  static_assert(std::is_same<T, OpState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OpState_Name().");
  return OpState_Name(static_cast<OpState>(value));
}
template <>
inline const std::string& OpState_Name(OpState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OpState_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool OpState_Parse(absl::string_view name, OpState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpState>(
      OpState_descriptor(), name, value);
}
enum LogLevel : int {
  LOG_LEVEL_INFO = 0,
  LOG_LEVEL_ERROR = 1,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = static_cast<LogLevel>(0);
constexpr LogLevel LogLevel_MAX = static_cast<LogLevel>(1);
constexpr int LogLevel_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
LogLevel_descriptor();
template <typename T>
const std::string& LogLevel_Name(T value) {
  static_assert(std::is_same<T, LogLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LogLevel_Name().");
  return LogLevel_Name(static_cast<LogLevel>(value));
}
template <>
inline const std::string& LogLevel_Name(LogLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogLevel_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool LogLevel_Parse(absl::string_view name, LogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogLevel>(
      LogLevel_descriptor(), name, value);
}
enum JogFrameType : int {
  JOG_FRAME_TYPE_REF = 0,
  JOG_FRAME_TYPE_TOOL = 1,
  JogFrameType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  JogFrameType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool JogFrameType_IsValid(int value);
constexpr JogFrameType JogFrameType_MIN = static_cast<JogFrameType>(0);
constexpr JogFrameType JogFrameType_MAX = static_cast<JogFrameType>(1);
constexpr int JogFrameType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
JogFrameType_descriptor();
template <typename T>
const std::string& JogFrameType_Name(T value) {
  static_assert(std::is_same<T, JogFrameType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JogFrameType_Name().");
  return JogFrameType_Name(static_cast<JogFrameType>(value));
}
template <>
inline const std::string& JogFrameType_Name(JogFrameType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<JogFrameType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool JogFrameType_Parse(absl::string_view name, JogFrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JogFrameType>(
      JogFrameType_descriptor(), name, value);
}
enum Axis : int {
  AXIS_X = 0,
  AXIS_Y = 1,
  AXIS_Z = 2,
  AXIS_U = 3,
  AXIS_V = 4,
  AXIS_W = 5,
  Axis_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Axis_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Axis_IsValid(int value);
constexpr Axis Axis_MIN = static_cast<Axis>(0);
constexpr Axis Axis_MAX = static_cast<Axis>(5);
constexpr int Axis_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Axis_descriptor();
template <typename T>
const std::string& Axis_Name(T value) {
  static_assert(std::is_same<T, Axis>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Axis_Name().");
  return Axis_Name(static_cast<Axis>(value));
}
template <>
inline const std::string& Axis_Name(Axis value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Axis_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Axis_Parse(absl::string_view name, Axis* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Axis>(
      Axis_descriptor(), name, value);
}
enum VisionFrameType : int {
  OBJECT = 0,
  END_EFFECTOR = 1,
  VisionFrameType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VisionFrameType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VisionFrameType_IsValid(int value);
constexpr VisionFrameType VisionFrameType_MIN = static_cast<VisionFrameType>(0);
constexpr VisionFrameType VisionFrameType_MAX = static_cast<VisionFrameType>(1);
constexpr int VisionFrameType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
VisionFrameType_descriptor();
template <typename T>
const std::string& VisionFrameType_Name(T value) {
  static_assert(std::is_same<T, VisionFrameType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VisionFrameType_Name().");
  return VisionFrameType_Name(static_cast<VisionFrameType>(value));
}
template <>
inline const std::string& VisionFrameType_Name(VisionFrameType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VisionFrameType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool VisionFrameType_Parse(absl::string_view name, VisionFrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisionFrameType>(
      VisionFrameType_descriptor(), name, value);
}
enum WeavingBase : int {
  WEAVE_FRAME_TYPE_TOOL = 0,
  WEAVE_FRAME_TYPE_REF = 1,
  WeavingBase_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WeavingBase_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WeavingBase_IsValid(int value);
constexpr WeavingBase WeavingBase_MIN = static_cast<WeavingBase>(0);
constexpr WeavingBase WeavingBase_MAX = static_cast<WeavingBase>(1);
constexpr int WeavingBase_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
WeavingBase_descriptor();
template <typename T>
const std::string& WeavingBase_Name(T value) {
  static_assert(std::is_same<T, WeavingBase>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WeavingBase_Name().");
  return WeavingBase_Name(static_cast<WeavingBase>(value));
}
template <>
inline const std::string& WeavingBase_Name(WeavingBase value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WeavingBase_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool WeavingBase_Parse(absl::string_view name, WeavingBase* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeavingBase>(
      WeavingBase_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MoveSJPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSJPoint) */ {
 public:
  inline MoveSJPoint() : MoveSJPoint(nullptr) {}
  ~MoveSJPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveSJPoint(::google::protobuf::internal::ConstantInitialized);

  MoveSJPoint(const MoveSJPoint& from);
  MoveSJPoint(MoveSJPoint&& from) noexcept
    : MoveSJPoint() {
    *this = ::std::move(from);
  }

  inline MoveSJPoint& operator=(const MoveSJPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSJPoint& operator=(MoveSJPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveSJPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveSJPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSJPoint*>(
               &_MoveSJPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MoveSJPoint& a, MoveSJPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveSJPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveSJPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveSJPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveSJPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveSJPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveSJPoint& from) {
    MoveSJPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSJPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSJPoint";
  }
  protected:
  explicit MoveSJPoint(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJposFieldNumber = 1,
    kBlendingRadiusFieldNumber = 2,
  };
  // repeated float jpos = 1;
  int jpos_size() const;
  private:
  int _internal_jpos_size() const;

  public:
  void clear_jpos() ;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::google::protobuf::RepeatedField<float>& jpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_jpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_jpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_jpos();

  public:
  // float blending_radius = 2;
  void clear_blending_radius() ;
  float blending_radius() const;
  void set_blending_radius(float value);

  private:
  float _internal_blending_radius() const;
  void _internal_set_blending_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSJPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> jpos_;
    float blending_radius_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class MoveSJTPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSJTPoint) */ {
 public:
  inline MoveSJTPoint() : MoveSJTPoint(nullptr) {}
  ~MoveSJTPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveSJTPoint(::google::protobuf::internal::ConstantInitialized);

  MoveSJTPoint(const MoveSJTPoint& from);
  MoveSJTPoint(MoveSJTPoint&& from) noexcept
    : MoveSJTPoint() {
    *this = ::std::move(from);
  }

  inline MoveSJTPoint& operator=(const MoveSJTPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSJTPoint& operator=(MoveSJTPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveSJTPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveSJTPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSJTPoint*>(
               &_MoveSJTPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MoveSJTPoint& a, MoveSJTPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveSJTPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveSJTPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveSJTPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveSJTPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveSJTPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveSJTPoint& from) {
    MoveSJTPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSJTPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSJTPoint";
  }
  protected:
  explicit MoveSJTPoint(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJposFieldNumber = 1,
    kBlendingRadiusFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // repeated float jpos = 1;
  int jpos_size() const;
  private:
  int _internal_jpos_size() const;

  public:
  void clear_jpos() ;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::google::protobuf::RepeatedField<float>& jpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_jpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_jpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_jpos();

  public:
  // float blending_radius = 2;
  void clear_blending_radius() ;
  float blending_radius() const;
  void set_blending_radius(float value);

  private:
  float _internal_blending_radius() const;
  void _internal_set_blending_radius(float value);

  public:
  // float time = 3;
  void clear_time() ;
  float time() const;
  void set_time(float value);

  private:
  float _internal_time() const;
  void _internal_set_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSJTPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> jpos_;
    float blending_radius_;
    float time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class MoveSLPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSLPoint) */ {
 public:
  inline MoveSLPoint() : MoveSLPoint(nullptr) {}
  ~MoveSLPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveSLPoint(::google::protobuf::internal::ConstantInitialized);

  MoveSLPoint(const MoveSLPoint& from);
  MoveSLPoint(MoveSLPoint&& from) noexcept
    : MoveSLPoint() {
    *this = ::std::move(from);
  }

  inline MoveSLPoint& operator=(const MoveSLPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSLPoint& operator=(MoveSLPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveSLPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveSLPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSLPoint*>(
               &_MoveSLPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MoveSLPoint& a, MoveSLPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveSLPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveSLPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveSLPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveSLPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveSLPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveSLPoint& from) {
    MoveSLPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSLPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSLPoint";
  }
  protected:
  explicit MoveSLPoint(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTposFieldNumber = 1,
    kBlendingRadiusFieldNumber = 2,
  };
  // repeated float tpos = 1;
  int tpos_size() const;
  private:
  int _internal_tpos_size() const;

  public:
  void clear_tpos() ;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::google::protobuf::RepeatedField<float>& tpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos();

  public:
  // float blending_radius = 2;
  void clear_blending_radius() ;
  float blending_radius() const;
  void set_blending_radius(float value);

  private:
  float _internal_blending_radius() const;
  void _internal_set_blending_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSLPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> tpos_;
    float blending_radius_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class MoveSLTPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.MoveSLTPoint) */ {
 public:
  inline MoveSLTPoint() : MoveSLTPoint(nullptr) {}
  ~MoveSLTPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveSLTPoint(::google::protobuf::internal::ConstantInitialized);

  MoveSLTPoint(const MoveSLTPoint& from);
  MoveSLTPoint(MoveSLTPoint&& from) noexcept
    : MoveSLTPoint() {
    *this = ::std::move(from);
  }

  inline MoveSLTPoint& operator=(const MoveSLTPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveSLTPoint& operator=(MoveSLTPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveSLTPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveSLTPoint* internal_default_instance() {
    return reinterpret_cast<const MoveSLTPoint*>(
               &_MoveSLTPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MoveSLTPoint& a, MoveSLTPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveSLTPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveSLTPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveSLTPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveSLTPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveSLTPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveSLTPoint& from) {
    MoveSLTPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveSLTPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.MoveSLTPoint";
  }
  protected:
  explicit MoveSLTPoint(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTposFieldNumber = 1,
    kBlendingRadiusFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // repeated float tpos = 1;
  int tpos_size() const;
  private:
  int _internal_tpos_size() const;

  public:
  void clear_tpos() ;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::google::protobuf::RepeatedField<float>& tpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos();

  public:
  // float blending_radius = 2;
  void clear_blending_radius() ;
  float blending_radius() const;
  void set_blending_radius(float value);

  private:
  float _internal_blending_radius() const;
  void _internal_set_blending_radius(float value);

  public:
  // float time = 3;
  void clear_time() ;
  float time() const;
  void set_time(float value);

  private:
  float _internal_time() const;
  void _internal_set_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.MoveSLTPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> tpos_;
    float blending_radius_;
    float time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class DigitalSignal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.DigitalSignal) */ {
 public:
  inline DigitalSignal() : DigitalSignal(nullptr) {}
  ~DigitalSignal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DigitalSignal(::google::protobuf::internal::ConstantInitialized);

  DigitalSignal(const DigitalSignal& from);
  DigitalSignal(DigitalSignal&& from) noexcept
    : DigitalSignal() {
    *this = ::std::move(from);
  }

  inline DigitalSignal& operator=(const DigitalSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitalSignal& operator=(DigitalSignal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DigitalSignal& default_instance() {
    return *internal_default_instance();
  }
  static inline const DigitalSignal* internal_default_instance() {
    return reinterpret_cast<const DigitalSignal*>(
               &_DigitalSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DigitalSignal& a, DigitalSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(DigitalSignal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigitalSignal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DigitalSignal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DigitalSignal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DigitalSignal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DigitalSignal& from) {
    DigitalSignal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitalSignal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.DigitalSignal";
  }
  protected:
  explicit DigitalSignal(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kOnFieldNumber = 2,
  };
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // bool on = 2;
  void clear_on() ;
  bool on() const;
  void set_on(bool value);

  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.DigitalSignal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t addr_;
    bool on_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class AnalogSignal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.AnalogSignal) */ {
 public:
  inline AnalogSignal() : AnalogSignal(nullptr) {}
  ~AnalogSignal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalogSignal(::google::protobuf::internal::ConstantInitialized);

  AnalogSignal(const AnalogSignal& from);
  AnalogSignal(AnalogSignal&& from) noexcept
    : AnalogSignal() {
    *this = ::std::move(from);
  }

  inline AnalogSignal& operator=(const AnalogSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogSignal& operator=(AnalogSignal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalogSignal& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalogSignal* internal_default_instance() {
    return reinterpret_cast<const AnalogSignal*>(
               &_AnalogSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AnalogSignal& a, AnalogSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalogSignal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalogSignal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalogSignal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalogSignal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalogSignal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalogSignal& from) {
    AnalogSignal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogSignal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.AnalogSignal";
  }
  protected:
  explicit AnalogSignal(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kVoltageFieldNumber = 2,
  };
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // int32 voltage = 2;
  void clear_voltage() ;
  ::int32_t voltage() const;
  void set_voltage(::int32_t value);

  private:
  ::int32_t _internal_voltage() const;
  void _internal_set_voltage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.AnalogSignal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t addr_;
    ::int32_t voltage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class NamedTaskPosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.NamedTaskPosition) */ {
 public:
  inline NamedTaskPosition() : NamedTaskPosition(nullptr) {}
  ~NamedTaskPosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NamedTaskPosition(::google::protobuf::internal::ConstantInitialized);

  NamedTaskPosition(const NamedTaskPosition& from);
  NamedTaskPosition(NamedTaskPosition&& from) noexcept
    : NamedTaskPosition() {
    *this = ::std::move(from);
  }

  inline NamedTaskPosition& operator=(const NamedTaskPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedTaskPosition& operator=(NamedTaskPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedTaskPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedTaskPosition* internal_default_instance() {
    return reinterpret_cast<const NamedTaskPosition*>(
               &_NamedTaskPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NamedTaskPosition& a, NamedTaskPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedTaskPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedTaskPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedTaskPosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedTaskPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NamedTaskPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NamedTaskPosition& from) {
    NamedTaskPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedTaskPosition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.NamedTaskPosition";
  }
  protected:
  explicit NamedTaskPosition(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTposFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated float tpos = 2;
  int tpos_size() const;
  private:
  int _internal_tpos_size() const;

  public:
  void clear_tpos() ;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::google::protobuf::RepeatedField<float>& tpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.NamedTaskPosition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 60, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> tpos_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class NamedJointPosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.NamedJointPosition) */ {
 public:
  inline NamedJointPosition() : NamedJointPosition(nullptr) {}
  ~NamedJointPosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NamedJointPosition(::google::protobuf::internal::ConstantInitialized);

  NamedJointPosition(const NamedJointPosition& from);
  NamedJointPosition(NamedJointPosition&& from) noexcept
    : NamedJointPosition() {
    *this = ::std::move(from);
  }

  inline NamedJointPosition& operator=(const NamedJointPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedJointPosition& operator=(NamedJointPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedJointPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedJointPosition* internal_default_instance() {
    return reinterpret_cast<const NamedJointPosition*>(
               &_NamedJointPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NamedJointPosition& a, NamedJointPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedJointPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedJointPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedJointPosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedJointPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NamedJointPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NamedJointPosition& from) {
    NamedJointPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedJointPosition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.NamedJointPosition";
  }
  protected:
  explicit NamedJointPosition(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJposFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated float jpos = 2;
  int jpos_size() const;
  private:
  int _internal_jpos_size() const;

  public:
  void clear_jpos() ;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::google::protobuf::RepeatedField<float>& jpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_jpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_jpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_jpos();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.NamedJointPosition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 61, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> jpos_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class NamedReferencePosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.NamedReferencePosition) */ {
 public:
  inline NamedReferencePosition() : NamedReferencePosition(nullptr) {}
  ~NamedReferencePosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NamedReferencePosition(::google::protobuf::internal::ConstantInitialized);

  NamedReferencePosition(const NamedReferencePosition& from);
  NamedReferencePosition(NamedReferencePosition&& from) noexcept
    : NamedReferencePosition() {
    *this = ::std::move(from);
  }

  inline NamedReferencePosition& operator=(const NamedReferencePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedReferencePosition& operator=(NamedReferencePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedReferencePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedReferencePosition* internal_default_instance() {
    return reinterpret_cast<const NamedReferencePosition*>(
               &_NamedReferencePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NamedReferencePosition& a, NamedReferencePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedReferencePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedReferencePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedReferencePosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedReferencePosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NamedReferencePosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NamedReferencePosition& from) {
    NamedReferencePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedReferencePosition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.NamedReferencePosition";
  }
  protected:
  explicit NamedReferencePosition(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTposFieldNumber = 2,
    kTpos0FieldNumber = 3,
    kTpos1FieldNumber = 4,
    kTpos2FieldNumber = 5,
    kJpos0FieldNumber = 6,
    kJpos1FieldNumber = 7,
    kJpos2FieldNumber = 8,
    kNameFieldNumber = 1,
  };
  // repeated float tpos = 2;
  int tpos_size() const;
  private:
  int _internal_tpos_size() const;

  public:
  void clear_tpos() ;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::google::protobuf::RepeatedField<float>& tpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos();

  public:
  // repeated float tpos0 = 3;
  int tpos0_size() const;
  private:
  int _internal_tpos0_size() const;

  public:
  void clear_tpos0() ;
  float tpos0(int index) const;
  void set_tpos0(int index, float value);
  void add_tpos0(float value);
  const ::google::protobuf::RepeatedField<float>& tpos0() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos0();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos0() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos0();

  public:
  // repeated float tpos1 = 4;
  int tpos1_size() const;
  private:
  int _internal_tpos1_size() const;

  public:
  void clear_tpos1() ;
  float tpos1(int index) const;
  void set_tpos1(int index, float value);
  void add_tpos1(float value);
  const ::google::protobuf::RepeatedField<float>& tpos1() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos1();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos1() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos1();

  public:
  // repeated float tpos2 = 5;
  int tpos2_size() const;
  private:
  int _internal_tpos2_size() const;

  public:
  void clear_tpos2() ;
  float tpos2(int index) const;
  void set_tpos2(int index, float value);
  void add_tpos2(float value);
  const ::google::protobuf::RepeatedField<float>& tpos2() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos2();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos2() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos2();

  public:
  // repeated float jpos0 = 6;
  int jpos0_size() const;
  private:
  int _internal_jpos0_size() const;

  public:
  void clear_jpos0() ;
  float jpos0(int index) const;
  void set_jpos0(int index, float value);
  void add_jpos0(float value);
  const ::google::protobuf::RepeatedField<float>& jpos0() const;
  ::google::protobuf::RepeatedField<float>* mutable_jpos0();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_jpos0() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_jpos0();

  public:
  // repeated float jpos1 = 7;
  int jpos1_size() const;
  private:
  int _internal_jpos1_size() const;

  public:
  void clear_jpos1() ;
  float jpos1(int index) const;
  void set_jpos1(int index, float value);
  void add_jpos1(float value);
  const ::google::protobuf::RepeatedField<float>& jpos1() const;
  ::google::protobuf::RepeatedField<float>* mutable_jpos1();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_jpos1() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_jpos1();

  public:
  // repeated float jpos2 = 8;
  int jpos2_size() const;
  private:
  int _internal_jpos2_size() const;

  public:
  void clear_jpos2() ;
  float jpos2(int index) const;
  void set_jpos2(int index, float value);
  void add_jpos2(float value);
  const ::google::protobuf::RepeatedField<float>& jpos2() const;
  ::google::protobuf::RepeatedField<float>* mutable_jpos2();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_jpos2() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_jpos2();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.NamedReferencePosition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8, 0, 73, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> tpos_;
    ::google::protobuf::RepeatedField<float> tpos0_;
    ::google::protobuf::RepeatedField<float> tpos1_;
    ::google::protobuf::RepeatedField<float> tpos2_;
    ::google::protobuf::RepeatedField<float> jpos0_;
    ::google::protobuf::RepeatedField<float> jpos1_;
    ::google::protobuf::RepeatedField<float> jpos2_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class IntVariable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.IntVariable) */ {
 public:
  inline IntVariable() : IntVariable(nullptr) {}
  ~IntVariable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IntVariable(::google::protobuf::internal::ConstantInitialized);

  IntVariable(const IntVariable& from);
  IntVariable(IntVariable&& from) noexcept
    : IntVariable() {
    *this = ::std::move(from);
  }

  inline IntVariable& operator=(const IntVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntVariable& operator=(IntVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntVariable* internal_default_instance() {
    return reinterpret_cast<const IntVariable*>(
               &_IntVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IntVariable& a, IntVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(IntVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntVariable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntVariable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntVariable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntVariable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IntVariable& from) {
    IntVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntVariable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.IntVariable";
  }
  protected:
  explicit IntVariable(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // int32 value = 2;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.IntVariable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t addr_;
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class ModbusVariable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.ModbusVariable) */ {
 public:
  inline ModbusVariable() : ModbusVariable(nullptr) {}
  ~ModbusVariable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModbusVariable(::google::protobuf::internal::ConstantInitialized);

  ModbusVariable(const ModbusVariable& from);
  ModbusVariable(ModbusVariable&& from) noexcept
    : ModbusVariable() {
    *this = ::std::move(from);
  }

  inline ModbusVariable& operator=(const ModbusVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusVariable& operator=(ModbusVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusVariable* internal_default_instance() {
    return reinterpret_cast<const ModbusVariable*>(
               &_ModbusVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModbusVariable& a, ModbusVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusVariable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusVariable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusVariable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModbusVariable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ModbusVariable& from) {
    ModbusVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusVariable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.ModbusVariable";
  }
  protected:
  explicit ModbusVariable(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // int32 value = 2;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.ModbusVariable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t addr_;
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class BoolVariable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.BoolVariable) */ {
 public:
  inline BoolVariable() : BoolVariable(nullptr) {}
  ~BoolVariable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoolVariable(::google::protobuf::internal::ConstantInitialized);

  BoolVariable(const BoolVariable& from);
  BoolVariable(BoolVariable&& from) noexcept
    : BoolVariable() {
    *this = ::std::move(from);
  }

  inline BoolVariable& operator=(const BoolVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolVariable& operator=(BoolVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolVariable* internal_default_instance() {
    return reinterpret_cast<const BoolVariable*>(
               &_BoolVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BoolVariable& a, BoolVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolVariable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolVariable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolVariable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolVariable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BoolVariable& from) {
    BoolVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolVariable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.BoolVariable";
  }
  protected:
  explicit BoolVariable(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // bool value = 2;
  void clear_value() ;
  bool value() const;
  void set_value(bool value);

  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.BoolVariable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t addr_;
    bool value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class FloatVariable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.FloatVariable) */ {
 public:
  inline FloatVariable() : FloatVariable(nullptr) {}
  ~FloatVariable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FloatVariable(::google::protobuf::internal::ConstantInitialized);

  FloatVariable(const FloatVariable& from);
  FloatVariable(FloatVariable&& from) noexcept
    : FloatVariable() {
    *this = ::std::move(from);
  }

  inline FloatVariable& operator=(const FloatVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatVariable& operator=(FloatVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatVariable* internal_default_instance() {
    return reinterpret_cast<const FloatVariable*>(
               &_FloatVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FloatVariable& a, FloatVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatVariable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatVariable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatVariable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatVariable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FloatVariable& from) {
    FloatVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatVariable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.FloatVariable";
  }
  protected:
  explicit FloatVariable(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // float value = 2;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.FloatVariable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t addr_;
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class JPosVariable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.JPosVariable) */ {
 public:
  inline JPosVariable() : JPosVariable(nullptr) {}
  ~JPosVariable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JPosVariable(::google::protobuf::internal::ConstantInitialized);

  JPosVariable(const JPosVariable& from);
  JPosVariable(JPosVariable&& from) noexcept
    : JPosVariable() {
    *this = ::std::move(from);
  }

  inline JPosVariable& operator=(const JPosVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline JPosVariable& operator=(JPosVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JPosVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const JPosVariable* internal_default_instance() {
    return reinterpret_cast<const JPosVariable*>(
               &_JPosVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(JPosVariable& a, JPosVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(JPosVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JPosVariable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JPosVariable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JPosVariable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JPosVariable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JPosVariable& from) {
    JPosVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JPosVariable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.JPosVariable";
  }
  protected:
  explicit JPosVariable(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJposFieldNumber = 2,
    kAddrFieldNumber = 1,
  };
  // repeated float jpos = 2;
  int jpos_size() const;
  private:
  int _internal_jpos_size() const;

  public:
  void clear_jpos() ;
  float jpos(int index) const;
  void set_jpos(int index, float value);
  void add_jpos(float value);
  const ::google::protobuf::RepeatedField<float>& jpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_jpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_jpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_jpos();

  public:
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.JPosVariable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> jpos_;
    ::int32_t addr_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class TPosVariable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.TPosVariable) */ {
 public:
  inline TPosVariable() : TPosVariable(nullptr) {}
  ~TPosVariable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TPosVariable(::google::protobuf::internal::ConstantInitialized);

  TPosVariable(const TPosVariable& from);
  TPosVariable(TPosVariable&& from) noexcept
    : TPosVariable() {
    *this = ::std::move(from);
  }

  inline TPosVariable& operator=(const TPosVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline TPosVariable& operator=(TPosVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TPosVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const TPosVariable* internal_default_instance() {
    return reinterpret_cast<const TPosVariable*>(
               &_TPosVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TPosVariable& a, TPosVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(TPosVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TPosVariable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TPosVariable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TPosVariable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TPosVariable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TPosVariable& from) {
    TPosVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TPosVariable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.TPosVariable";
  }
  protected:
  explicit TPosVariable(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTposFieldNumber = 2,
    kAddrFieldNumber = 1,
  };
  // repeated float tpos = 2;
  int tpos_size() const;
  private:
  int _internal_tpos_size() const;

  public:
  void clear_tpos() ;
  float tpos(int index) const;
  void set_tpos(int index, float value);
  void add_tpos(float value);
  const ::google::protobuf::RepeatedField<float>& tpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_tpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tpos();

  public:
  // int32 addr = 1;
  void clear_addr() ;
  ::int32_t addr() const;
  void set_addr(::int32_t value);

  private:
  ::int32_t _internal_addr() const;
  void _internal_set_addr(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.TPosVariable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> tpos_;
    ::int32_t addr_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class Tool final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.Tool) */ {
 public:
  inline Tool() : Tool(nullptr) {}
  ~Tool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tool(::google::protobuf::internal::ConstantInitialized);

  Tool(const Tool& from);
  Tool(Tool&& from) noexcept
    : Tool() {
    *this = ::std::move(from);
  }

  inline Tool& operator=(const Tool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tool& operator=(Tool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tool* internal_default_instance() {
    return reinterpret_cast<const Tool*>(
               &_Tool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Tool& a, Tool& b) {
    a.Swap(&b);
  }
  inline void Swap(Tool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tool* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tool>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tool& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Tool& from) {
    Tool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tool* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.Tool";
  }
  protected:
  explicit Tool(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ToolType = Tool_ToolType;
  static constexpr ToolType DIGITAL_OUTPUT = Tool_ToolType_DIGITAL_OUTPUT;
  static constexpr ToolType MODBUS = Tool_ToolType_MODBUS;
  static inline bool ToolType_IsValid(int value) {
    return Tool_ToolType_IsValid(value);
  }
  static constexpr ToolType ToolType_MIN = Tool_ToolType_ToolType_MIN;
  static constexpr ToolType ToolType_MAX = Tool_ToolType_ToolType_MAX;
  static constexpr int ToolType_ARRAYSIZE = Tool_ToolType_ToolType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ToolType_descriptor() {
    return Tool_ToolType_descriptor();
  }
  template <typename T>
  static inline const std::string& ToolType_Name(T value) {
    return Tool_ToolType_Name(value);
  }
  static inline bool ToolType_Parse(absl::string_view name, ToolType* value) {
    return Tool_ToolType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDoListFieldNumber = 5,
    kMVarsFieldNumber = 6,
    kNameFieldNumber = 1,
    kToolTypeFieldNumber = 2,
    kSleepTimeFieldNumber = 10,
  };
  // repeated .IndyFramework.Protobuf.Shared.DigitalSignal do_list = 5;
  int do_list_size() const;
  private:
  int _internal_do_list_size() const;

  public:
  void clear_do_list() ;
  ::IndyFramework::Protobuf::Shared::DigitalSignal* mutable_do_list(int index);
  ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >*
      mutable_do_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::DigitalSignal>& _internal_do_list() const;
  ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::DigitalSignal>* _internal_mutable_do_list();
  public:
  const ::IndyFramework::Protobuf::Shared::DigitalSignal& do_list(int index) const;
  ::IndyFramework::Protobuf::Shared::DigitalSignal* add_do_list();
  const ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >&
      do_list() const;
  // repeated .IndyFramework.Protobuf.Shared.ModbusVariable m_vars = 6;
  int m_vars_size() const;
  private:
  int _internal_m_vars_size() const;

  public:
  void clear_m_vars() ;
  ::IndyFramework::Protobuf::Shared::ModbusVariable* mutable_m_vars(int index);
  ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >*
      mutable_m_vars();
  private:
  const ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::ModbusVariable>& _internal_m_vars() const;
  ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::ModbusVariable>* _internal_mutable_m_vars();
  public:
  const ::IndyFramework::Protobuf::Shared::ModbusVariable& m_vars(int index) const;
  ::IndyFramework::Protobuf::Shared::ModbusVariable* add_m_vars();
  const ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >&
      m_vars() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .IndyFramework.Protobuf.Shared.Tool.ToolType tool_type = 2;
  void clear_tool_type() ;
  ::IndyFramework::Protobuf::Shared::Tool_ToolType tool_type() const;
  void set_tool_type(::IndyFramework::Protobuf::Shared::Tool_ToolType value);

  private:
  ::IndyFramework::Protobuf::Shared::Tool_ToolType _internal_tool_type() const;
  void _internal_set_tool_type(::IndyFramework::Protobuf::Shared::Tool_ToolType value);

  public:
  // float sleep_time = 10;
  void clear_sleep_time() ;
  float sleep_time() const;
  void set_sleep_time(float value);

  private:
  float _internal_sleep_time() const;
  void _internal_set_sleep_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.Tool)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 2, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal > do_list_;
    ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable > m_vars_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    int tool_type_;
    float sleep_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class PalletPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.PalletPoint) */ {
 public:
  inline PalletPoint() : PalletPoint(nullptr) {}
  ~PalletPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PalletPoint(::google::protobuf::internal::ConstantInitialized);

  PalletPoint(const PalletPoint& from);
  PalletPoint(PalletPoint&& from) noexcept
    : PalletPoint() {
    *this = ::std::move(from);
  }

  inline PalletPoint& operator=(const PalletPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PalletPoint& operator=(PalletPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PalletPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PalletPoint* internal_default_instance() {
    return reinterpret_cast<const PalletPoint*>(
               &_PalletPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PalletPoint& a, PalletPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PalletPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PalletPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PalletPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PalletPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PalletPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PalletPoint& from) {
    PalletPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PalletPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.PalletPoint";
  }
  protected:
  explicit PalletPoint(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTarPosFieldNumber = 1,
    kApproachPosFieldNumber = 2,
    kRetractPosFieldNumber = 3,
    kTarJposFieldNumber = 4,
  };
  // repeated float tar_pos = 1;
  int tar_pos_size() const;
  private:
  int _internal_tar_pos_size() const;

  public:
  void clear_tar_pos() ;
  float tar_pos(int index) const;
  void set_tar_pos(int index, float value);
  void add_tar_pos(float value);
  const ::google::protobuf::RepeatedField<float>& tar_pos() const;
  ::google::protobuf::RepeatedField<float>* mutable_tar_pos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tar_pos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tar_pos();

  public:
  // repeated float approach_pos = 2;
  int approach_pos_size() const;
  private:
  int _internal_approach_pos_size() const;

  public:
  void clear_approach_pos() ;
  float approach_pos(int index) const;
  void set_approach_pos(int index, float value);
  void add_approach_pos(float value);
  const ::google::protobuf::RepeatedField<float>& approach_pos() const;
  ::google::protobuf::RepeatedField<float>* mutable_approach_pos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_approach_pos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_approach_pos();

  public:
  // repeated float retract_pos = 3;
  int retract_pos_size() const;
  private:
  int _internal_retract_pos_size() const;

  public:
  void clear_retract_pos() ;
  float retract_pos(int index) const;
  void set_retract_pos(int index, float value);
  void add_retract_pos(float value);
  const ::google::protobuf::RepeatedField<float>& retract_pos() const;
  ::google::protobuf::RepeatedField<float>* mutable_retract_pos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_retract_pos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_retract_pos();

  public:
  // repeated float tar_jpos = 4;
  int tar_jpos_size() const;
  private:
  int _internal_tar_jpos_size() const;

  public:
  void clear_tar_jpos() ;
  float tar_jpos(int index) const;
  void set_tar_jpos(int index, float value);
  void add_tar_jpos(float value);
  const ::google::protobuf::RepeatedField<float>& tar_jpos() const;
  ::google::protobuf::RepeatedField<float>* mutable_tar_jpos();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_tar_jpos() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_tar_jpos();

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.PalletPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<float> tar_pos_;
    ::google::protobuf::RepeatedField<float> approach_pos_;
    ::google::protobuf::RepeatedField<float> retract_pos_;
    ::google::protobuf::RepeatedField<float> tar_jpos_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class VisionServer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.VisionServer) */ {
 public:
  inline VisionServer() : VisionServer(nullptr) {}
  ~VisionServer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionServer(::google::protobuf::internal::ConstantInitialized);

  VisionServer(const VisionServer& from);
  VisionServer(VisionServer&& from) noexcept
    : VisionServer() {
    *this = ::std::move(from);
  }

  inline VisionServer& operator=(const VisionServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionServer& operator=(VisionServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionServer* internal_default_instance() {
    return reinterpret_cast<const VisionServer*>(
               &_VisionServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VisionServer& a, VisionServer& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionServer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionServer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionServer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionServer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionServer& from) {
    VisionServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionServer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.VisionServer";
  }
  protected:
  explicit VisionServer(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VisionServerType = VisionServer_VisionServerType;
  static constexpr VisionServerType INDYEYE = VisionServer_VisionServerType_INDYEYE;
  static constexpr VisionServerType PICKIT = VisionServer_VisionServerType_PICKIT;
  static constexpr VisionServerType OMRON = VisionServer_VisionServerType_OMRON;
  static inline bool VisionServerType_IsValid(int value) {
    return VisionServer_VisionServerType_IsValid(value);
  }
  static constexpr VisionServerType VisionServerType_MIN = VisionServer_VisionServerType_VisionServerType_MIN;
  static constexpr VisionServerType VisionServerType_MAX = VisionServer_VisionServerType_VisionServerType_MAX;
  static constexpr int VisionServerType_ARRAYSIZE = VisionServer_VisionServerType_VisionServerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VisionServerType_descriptor() {
    return VisionServer_VisionServerType_descriptor();
  }
  template <typename T>
  static inline const std::string& VisionServerType_Name(T value) {
    return VisionServer_VisionServerType_Name(value);
  }
  static inline bool VisionServerType_Parse(absl::string_view name, VisionServerType* value) {
    return VisionServer_VisionServerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIpFieldNumber = 3,
    kVisionServerTypeFieldNumber = 2,
    kPortFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string ip = 3;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // .IndyFramework.Protobuf.Shared.VisionServer.VisionServerType vision_server_type = 2;
  void clear_vision_server_type() ;
  ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType vision_server_type() const;
  void set_vision_server_type(::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType value);

  private:
  ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType _internal_vision_server_type() const;
  void _internal_set_vision_server_type(::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType value);

  public:
  // uint32 port = 4;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.VisionServer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    int vision_server_type_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};// -------------------------------------------------------------------

class ModbusServer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndyFramework.Protobuf.Shared.ModbusServer) */ {
 public:
  inline ModbusServer() : ModbusServer(nullptr) {}
  ~ModbusServer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModbusServer(::google::protobuf::internal::ConstantInitialized);

  ModbusServer(const ModbusServer& from);
  ModbusServer(ModbusServer&& from) noexcept
    : ModbusServer() {
    *this = ::std::move(from);
  }

  inline ModbusServer& operator=(const ModbusServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusServer& operator=(ModbusServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusServer* internal_default_instance() {
    return reinterpret_cast<const ModbusServer*>(
               &_ModbusServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ModbusServer& a, ModbusServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusServer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusServer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusServer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModbusServer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ModbusServer& from) {
    ModbusServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusServer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "IndyFramework.Protobuf.Shared.ModbusServer";
  }
  protected:
  explicit ModbusServer(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIpFieldNumber = 2,
    kPortFieldNumber = 3,
    kUnitIdFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string ip = 2;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // int32 port = 3;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // int32 unit_id = 4;
  void clear_unit_id() ;
  ::int32_t unit_id() const;
  void set_unit_id(::int32_t value);

  private:
  ::int32_t _internal_unit_id() const;
  void _internal_set_unit_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IndyFramework.Protobuf.Shared.ModbusServer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::int32_t port_;
    ::int32_t unit_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shared_5fmsgs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MoveSJPoint

// repeated float jpos = 1;
inline int MoveSJPoint::_internal_jpos_size() const {
  return _internal_jpos().size();
}
inline int MoveSJPoint::jpos_size() const {
  return _internal_jpos_size();
}
inline void MoveSJPoint::clear_jpos() {
  _internal_mutable_jpos()->Clear();
}
inline float MoveSJPoint::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
  return _internal_jpos().Get(index);
}
inline void MoveSJPoint::set_jpos(int index, float value) {
  _internal_mutable_jpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
}
inline void MoveSJPoint::add_jpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
}
inline const ::google::protobuf::RepeatedField<float>& MoveSJPoint::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
  return _internal_jpos();
}
inline ::google::protobuf::RepeatedField<float>* MoveSJPoint::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSJPoint.jpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jpos();
}

inline const ::google::protobuf::RepeatedField<float>& MoveSJPoint::_internal_jpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jpos_;
}
inline ::google::protobuf::RepeatedField<float>* MoveSJPoint::_internal_mutable_jpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jpos_;
}

// float blending_radius = 2;
inline void MoveSJPoint::clear_blending_radius() {
  _impl_.blending_radius_ = 0;
}
inline float MoveSJPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJPoint.blending_radius)
  return _internal_blending_radius();
}
inline void MoveSJPoint::set_blending_radius(float value) {
  _internal_set_blending_radius(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJPoint.blending_radius)
}
inline float MoveSJPoint::_internal_blending_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blending_radius_;
}
inline void MoveSJPoint::_internal_set_blending_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blending_radius_ = value;
}

// -------------------------------------------------------------------

// MoveSJTPoint

// repeated float jpos = 1;
inline int MoveSJTPoint::_internal_jpos_size() const {
  return _internal_jpos().size();
}
inline int MoveSJTPoint::jpos_size() const {
  return _internal_jpos_size();
}
inline void MoveSJTPoint::clear_jpos() {
  _internal_mutable_jpos()->Clear();
}
inline float MoveSJTPoint::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
  return _internal_jpos().Get(index);
}
inline void MoveSJTPoint::set_jpos(int index, float value) {
  _internal_mutable_jpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
}
inline void MoveSJTPoint::add_jpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
}
inline const ::google::protobuf::RepeatedField<float>& MoveSJTPoint::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
  return _internal_jpos();
}
inline ::google::protobuf::RepeatedField<float>* MoveSJTPoint::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSJTPoint.jpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jpos();
}

inline const ::google::protobuf::RepeatedField<float>& MoveSJTPoint::_internal_jpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jpos_;
}
inline ::google::protobuf::RepeatedField<float>* MoveSJTPoint::_internal_mutable_jpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jpos_;
}

// float blending_radius = 2;
inline void MoveSJTPoint::clear_blending_radius() {
  _impl_.blending_radius_ = 0;
}
inline float MoveSJTPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJTPoint.blending_radius)
  return _internal_blending_radius();
}
inline void MoveSJTPoint::set_blending_radius(float value) {
  _internal_set_blending_radius(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJTPoint.blending_radius)
}
inline float MoveSJTPoint::_internal_blending_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blending_radius_;
}
inline void MoveSJTPoint::_internal_set_blending_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blending_radius_ = value;
}

// float time = 3;
inline void MoveSJTPoint::clear_time() {
  _impl_.time_ = 0;
}
inline float MoveSJTPoint::time() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSJTPoint.time)
  return _internal_time();
}
inline void MoveSJTPoint::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSJTPoint.time)
}
inline float MoveSJTPoint::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void MoveSJTPoint::_internal_set_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// MoveSLPoint

// repeated float tpos = 1;
inline int MoveSLPoint::_internal_tpos_size() const {
  return _internal_tpos().size();
}
inline int MoveSLPoint::tpos_size() const {
  return _internal_tpos_size();
}
inline void MoveSLPoint::clear_tpos() {
  _internal_mutable_tpos()->Clear();
}
inline float MoveSLPoint::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
  return _internal_tpos().Get(index);
}
inline void MoveSLPoint::set_tpos(int index, float value) {
  _internal_mutable_tpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
}
inline void MoveSLPoint::add_tpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
}
inline const ::google::protobuf::RepeatedField<float>& MoveSLPoint::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
  return _internal_tpos();
}
inline ::google::protobuf::RepeatedField<float>* MoveSLPoint::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSLPoint.tpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos();
}

inline const ::google::protobuf::RepeatedField<float>& MoveSLPoint::_internal_tpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos_;
}
inline ::google::protobuf::RepeatedField<float>* MoveSLPoint::_internal_mutable_tpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos_;
}

// float blending_radius = 2;
inline void MoveSLPoint::clear_blending_radius() {
  _impl_.blending_radius_ = 0;
}
inline float MoveSLPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLPoint.blending_radius)
  return _internal_blending_radius();
}
inline void MoveSLPoint::set_blending_radius(float value) {
  _internal_set_blending_radius(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLPoint.blending_radius)
}
inline float MoveSLPoint::_internal_blending_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blending_radius_;
}
inline void MoveSLPoint::_internal_set_blending_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blending_radius_ = value;
}

// -------------------------------------------------------------------

// MoveSLTPoint

// repeated float tpos = 1;
inline int MoveSLTPoint::_internal_tpos_size() const {
  return _internal_tpos().size();
}
inline int MoveSLTPoint::tpos_size() const {
  return _internal_tpos_size();
}
inline void MoveSLTPoint::clear_tpos() {
  _internal_mutable_tpos()->Clear();
}
inline float MoveSLTPoint::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
  return _internal_tpos().Get(index);
}
inline void MoveSLTPoint::set_tpos(int index, float value) {
  _internal_mutable_tpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
}
inline void MoveSLTPoint::add_tpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
}
inline const ::google::protobuf::RepeatedField<float>& MoveSLTPoint::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
  return _internal_tpos();
}
inline ::google::protobuf::RepeatedField<float>* MoveSLTPoint::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.MoveSLTPoint.tpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos();
}

inline const ::google::protobuf::RepeatedField<float>& MoveSLTPoint::_internal_tpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos_;
}
inline ::google::protobuf::RepeatedField<float>* MoveSLTPoint::_internal_mutable_tpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos_;
}

// float blending_radius = 2;
inline void MoveSLTPoint::clear_blending_radius() {
  _impl_.blending_radius_ = 0;
}
inline float MoveSLTPoint::blending_radius() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLTPoint.blending_radius)
  return _internal_blending_radius();
}
inline void MoveSLTPoint::set_blending_radius(float value) {
  _internal_set_blending_radius(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLTPoint.blending_radius)
}
inline float MoveSLTPoint::_internal_blending_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blending_radius_;
}
inline void MoveSLTPoint::_internal_set_blending_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blending_radius_ = value;
}

// float time = 3;
inline void MoveSLTPoint::clear_time() {
  _impl_.time_ = 0;
}
inline float MoveSLTPoint::time() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.MoveSLTPoint.time)
  return _internal_time();
}
inline void MoveSLTPoint::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.MoveSLTPoint.time)
}
inline float MoveSLTPoint::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void MoveSLTPoint::_internal_set_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// DigitalSignal

// int32 addr = 1;
inline void DigitalSignal::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t DigitalSignal::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.DigitalSignal.addr)
  return _internal_addr();
}
inline void DigitalSignal::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.DigitalSignal.addr)
}
inline ::int32_t DigitalSignal::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void DigitalSignal::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// bool on = 2;
inline void DigitalSignal::clear_on() {
  _impl_.on_ = false;
}
inline bool DigitalSignal::on() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.DigitalSignal.on)
  return _internal_on();
}
inline void DigitalSignal::set_on(bool value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.DigitalSignal.on)
}
inline bool DigitalSignal::_internal_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.on_;
}
inline void DigitalSignal::_internal_set_on(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_ = value;
}

// -------------------------------------------------------------------

// AnalogSignal

// int32 addr = 1;
inline void AnalogSignal::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t AnalogSignal::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.AnalogSignal.addr)
  return _internal_addr();
}
inline void AnalogSignal::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.AnalogSignal.addr)
}
inline ::int32_t AnalogSignal::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void AnalogSignal::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// int32 voltage = 2;
inline void AnalogSignal::clear_voltage() {
  _impl_.voltage_ = 0;
}
inline ::int32_t AnalogSignal::voltage() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.AnalogSignal.voltage)
  return _internal_voltage();
}
inline void AnalogSignal::set_voltage(::int32_t value) {
  _internal_set_voltage(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.AnalogSignal.voltage)
}
inline ::int32_t AnalogSignal::_internal_voltage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voltage_;
}
inline void AnalogSignal::_internal_set_voltage(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.voltage_ = value;
}

// -------------------------------------------------------------------

// NamedTaskPosition

// string name = 1;
inline void NamedTaskPosition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedTaskPosition::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NamedTaskPosition::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
}
inline std::string* NamedTaskPosition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
  return _s;
}
inline const std::string& NamedTaskPosition::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void NamedTaskPosition::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedTaskPosition::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* NamedTaskPosition::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
  return _impl_.name_.Release();
}
inline void NamedTaskPosition::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.NamedTaskPosition.name)
}

// repeated float tpos = 2;
inline int NamedTaskPosition::_internal_tpos_size() const {
  return _internal_tpos().size();
}
inline int NamedTaskPosition::tpos_size() const {
  return _internal_tpos_size();
}
inline void NamedTaskPosition::clear_tpos() {
  _internal_mutable_tpos()->Clear();
}
inline float NamedTaskPosition::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
  return _internal_tpos().Get(index);
}
inline void NamedTaskPosition::set_tpos(int index, float value) {
  _internal_mutable_tpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
}
inline void NamedTaskPosition::add_tpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
}
inline const ::google::protobuf::RepeatedField<float>& NamedTaskPosition::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
  return _internal_tpos();
}
inline ::google::protobuf::RepeatedField<float>* NamedTaskPosition::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedTaskPosition.tpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos();
}

inline const ::google::protobuf::RepeatedField<float>& NamedTaskPosition::_internal_tpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos_;
}
inline ::google::protobuf::RepeatedField<float>* NamedTaskPosition::_internal_mutable_tpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos_;
}

// -------------------------------------------------------------------

// NamedJointPosition

// string name = 1;
inline void NamedJointPosition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedJointPosition::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NamedJointPosition::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
}
inline std::string* NamedJointPosition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
  return _s;
}
inline const std::string& NamedJointPosition::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void NamedJointPosition::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedJointPosition::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* NamedJointPosition::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
  return _impl_.name_.Release();
}
inline void NamedJointPosition::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.NamedJointPosition.name)
}

// repeated float jpos = 2;
inline int NamedJointPosition::_internal_jpos_size() const {
  return _internal_jpos().size();
}
inline int NamedJointPosition::jpos_size() const {
  return _internal_jpos_size();
}
inline void NamedJointPosition::clear_jpos() {
  _internal_mutable_jpos()->Clear();
}
inline float NamedJointPosition::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
  return _internal_jpos().Get(index);
}
inline void NamedJointPosition::set_jpos(int index, float value) {
  _internal_mutable_jpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
}
inline void NamedJointPosition::add_jpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
}
inline const ::google::protobuf::RepeatedField<float>& NamedJointPosition::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
  return _internal_jpos();
}
inline ::google::protobuf::RepeatedField<float>* NamedJointPosition::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedJointPosition.jpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jpos();
}

inline const ::google::protobuf::RepeatedField<float>& NamedJointPosition::_internal_jpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jpos_;
}
inline ::google::protobuf::RepeatedField<float>* NamedJointPosition::_internal_mutable_jpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jpos_;
}

// -------------------------------------------------------------------

// NamedReferencePosition

// string name = 1;
inline void NamedReferencePosition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedReferencePosition::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NamedReferencePosition::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
}
inline std::string* NamedReferencePosition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
  return _s;
}
inline const std::string& NamedReferencePosition::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void NamedReferencePosition::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedReferencePosition::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* NamedReferencePosition::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
  return _impl_.name_.Release();
}
inline void NamedReferencePosition::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.NamedReferencePosition.name)
}

// repeated float tpos = 2;
inline int NamedReferencePosition::_internal_tpos_size() const {
  return _internal_tpos().size();
}
inline int NamedReferencePosition::tpos_size() const {
  return _internal_tpos_size();
}
inline void NamedReferencePosition::clear_tpos() {
  _internal_mutable_tpos()->Clear();
}
inline float NamedReferencePosition::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
  return _internal_tpos().Get(index);
}
inline void NamedReferencePosition::set_tpos(int index, float value) {
  _internal_mutable_tpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
}
inline void NamedReferencePosition::add_tpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
}
inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
  return _internal_tpos();
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos();
}

inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::_internal_tpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos_;
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::_internal_mutable_tpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos_;
}

// repeated float tpos0 = 3;
inline int NamedReferencePosition::_internal_tpos0_size() const {
  return _internal_tpos0().size();
}
inline int NamedReferencePosition::tpos0_size() const {
  return _internal_tpos0_size();
}
inline void NamedReferencePosition::clear_tpos0() {
  _internal_mutable_tpos0()->Clear();
}
inline float NamedReferencePosition::tpos0(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
  return _internal_tpos0().Get(index);
}
inline void NamedReferencePosition::set_tpos0(int index, float value) {
  _internal_mutable_tpos0()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
}
inline void NamedReferencePosition::add_tpos0(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos0()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
}
inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::tpos0() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
  return _internal_tpos0();
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::mutable_tpos0() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos0)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos0();
}

inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::_internal_tpos0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos0_;
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::_internal_mutable_tpos0() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos0_;
}

// repeated float tpos1 = 4;
inline int NamedReferencePosition::_internal_tpos1_size() const {
  return _internal_tpos1().size();
}
inline int NamedReferencePosition::tpos1_size() const {
  return _internal_tpos1_size();
}
inline void NamedReferencePosition::clear_tpos1() {
  _internal_mutable_tpos1()->Clear();
}
inline float NamedReferencePosition::tpos1(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
  return _internal_tpos1().Get(index);
}
inline void NamedReferencePosition::set_tpos1(int index, float value) {
  _internal_mutable_tpos1()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
}
inline void NamedReferencePosition::add_tpos1(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos1()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
}
inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::tpos1() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
  return _internal_tpos1();
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::mutable_tpos1() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos1();
}

inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::_internal_tpos1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos1_;
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::_internal_mutable_tpos1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos1_;
}

// repeated float tpos2 = 5;
inline int NamedReferencePosition::_internal_tpos2_size() const {
  return _internal_tpos2().size();
}
inline int NamedReferencePosition::tpos2_size() const {
  return _internal_tpos2_size();
}
inline void NamedReferencePosition::clear_tpos2() {
  _internal_mutable_tpos2()->Clear();
}
inline float NamedReferencePosition::tpos2(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
  return _internal_tpos2().Get(index);
}
inline void NamedReferencePosition::set_tpos2(int index, float value) {
  _internal_mutable_tpos2()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
}
inline void NamedReferencePosition::add_tpos2(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos2()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
}
inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::tpos2() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
  return _internal_tpos2();
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::mutable_tpos2() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.tpos2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos2();
}

inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::_internal_tpos2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos2_;
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::_internal_mutable_tpos2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos2_;
}

// repeated float jpos0 = 6;
inline int NamedReferencePosition::_internal_jpos0_size() const {
  return _internal_jpos0().size();
}
inline int NamedReferencePosition::jpos0_size() const {
  return _internal_jpos0_size();
}
inline void NamedReferencePosition::clear_jpos0() {
  _internal_mutable_jpos0()->Clear();
}
inline float NamedReferencePosition::jpos0(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos0)
  return _internal_jpos0().Get(index);
}
inline void NamedReferencePosition::set_jpos0(int index, float value) {
  _internal_mutable_jpos0()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos0)
}
inline void NamedReferencePosition::add_jpos0(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jpos0()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos0)
}
inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::jpos0() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos0)
  return _internal_jpos0();
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::mutable_jpos0() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos0)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jpos0();
}

inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::_internal_jpos0() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jpos0_;
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::_internal_mutable_jpos0() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jpos0_;
}

// repeated float jpos1 = 7;
inline int NamedReferencePosition::_internal_jpos1_size() const {
  return _internal_jpos1().size();
}
inline int NamedReferencePosition::jpos1_size() const {
  return _internal_jpos1_size();
}
inline void NamedReferencePosition::clear_jpos1() {
  _internal_mutable_jpos1()->Clear();
}
inline float NamedReferencePosition::jpos1(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos1)
  return _internal_jpos1().Get(index);
}
inline void NamedReferencePosition::set_jpos1(int index, float value) {
  _internal_mutable_jpos1()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos1)
}
inline void NamedReferencePosition::add_jpos1(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jpos1()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos1)
}
inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::jpos1() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos1)
  return _internal_jpos1();
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::mutable_jpos1() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jpos1();
}

inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::_internal_jpos1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jpos1_;
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::_internal_mutable_jpos1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jpos1_;
}

// repeated float jpos2 = 8;
inline int NamedReferencePosition::_internal_jpos2_size() const {
  return _internal_jpos2().size();
}
inline int NamedReferencePosition::jpos2_size() const {
  return _internal_jpos2_size();
}
inline void NamedReferencePosition::clear_jpos2() {
  _internal_mutable_jpos2()->Clear();
}
inline float NamedReferencePosition::jpos2(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos2)
  return _internal_jpos2().Get(index);
}
inline void NamedReferencePosition::set_jpos2(int index, float value) {
  _internal_mutable_jpos2()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos2)
}
inline void NamedReferencePosition::add_jpos2(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jpos2()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos2)
}
inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::jpos2() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos2)
  return _internal_jpos2();
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::mutable_jpos2() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.NamedReferencePosition.jpos2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jpos2();
}

inline const ::google::protobuf::RepeatedField<float>& NamedReferencePosition::_internal_jpos2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jpos2_;
}
inline ::google::protobuf::RepeatedField<float>* NamedReferencePosition::_internal_mutable_jpos2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jpos2_;
}

// -------------------------------------------------------------------

// IntVariable

// int32 addr = 1;
inline void IntVariable::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t IntVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.IntVariable.addr)
  return _internal_addr();
}
inline void IntVariable::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.IntVariable.addr)
}
inline ::int32_t IntVariable::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void IntVariable::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// int32 value = 2;
inline void IntVariable::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t IntVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.IntVariable.value)
  return _internal_value();
}
inline void IntVariable::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.IntVariable.value)
}
inline ::int32_t IntVariable::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void IntVariable::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ModbusVariable

// int32 addr = 1;
inline void ModbusVariable::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t ModbusVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusVariable.addr)
  return _internal_addr();
}
inline void ModbusVariable::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusVariable.addr)
}
inline ::int32_t ModbusVariable::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void ModbusVariable::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// int32 value = 2;
inline void ModbusVariable::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t ModbusVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusVariable.value)
  return _internal_value();
}
inline void ModbusVariable::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusVariable.value)
}
inline ::int32_t ModbusVariable::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void ModbusVariable::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// BoolVariable

// int32 addr = 1;
inline void BoolVariable::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t BoolVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.BoolVariable.addr)
  return _internal_addr();
}
inline void BoolVariable::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.BoolVariable.addr)
}
inline ::int32_t BoolVariable::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void BoolVariable::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// bool value = 2;
inline void BoolVariable::clear_value() {
  _impl_.value_ = false;
}
inline bool BoolVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.BoolVariable.value)
  return _internal_value();
}
inline void BoolVariable::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.BoolVariable.value)
}
inline bool BoolVariable::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void BoolVariable::_internal_set_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// FloatVariable

// int32 addr = 1;
inline void FloatVariable::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t FloatVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.FloatVariable.addr)
  return _internal_addr();
}
inline void FloatVariable::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.FloatVariable.addr)
}
inline ::int32_t FloatVariable::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void FloatVariable::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// float value = 2;
inline void FloatVariable::clear_value() {
  _impl_.value_ = 0;
}
inline float FloatVariable::value() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.FloatVariable.value)
  return _internal_value();
}
inline void FloatVariable::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.FloatVariable.value)
}
inline float FloatVariable::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void FloatVariable::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// JPosVariable

// int32 addr = 1;
inline void JPosVariable::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t JPosVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.JPosVariable.addr)
  return _internal_addr();
}
inline void JPosVariable::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.JPosVariable.addr)
}
inline ::int32_t JPosVariable::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void JPosVariable::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// repeated float jpos = 2;
inline int JPosVariable::_internal_jpos_size() const {
  return _internal_jpos().size();
}
inline int JPosVariable::jpos_size() const {
  return _internal_jpos_size();
}
inline void JPosVariable::clear_jpos() {
  _internal_mutable_jpos()->Clear();
}
inline float JPosVariable::jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
  return _internal_jpos().Get(index);
}
inline void JPosVariable::set_jpos(int index, float value) {
  _internal_mutable_jpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
}
inline void JPosVariable::add_jpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
}
inline const ::google::protobuf::RepeatedField<float>& JPosVariable::jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
  return _internal_jpos();
}
inline ::google::protobuf::RepeatedField<float>* JPosVariable::mutable_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.JPosVariable.jpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jpos();
}

inline const ::google::protobuf::RepeatedField<float>& JPosVariable::_internal_jpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jpos_;
}
inline ::google::protobuf::RepeatedField<float>* JPosVariable::_internal_mutable_jpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jpos_;
}

// -------------------------------------------------------------------

// TPosVariable

// int32 addr = 1;
inline void TPosVariable::clear_addr() {
  _impl_.addr_ = 0;
}
inline ::int32_t TPosVariable::addr() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.TPosVariable.addr)
  return _internal_addr();
}
inline void TPosVariable::set_addr(::int32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.TPosVariable.addr)
}
inline ::int32_t TPosVariable::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_;
}
inline void TPosVariable::_internal_set_addr(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_ = value;
}

// repeated float tpos = 2;
inline int TPosVariable::_internal_tpos_size() const {
  return _internal_tpos().size();
}
inline int TPosVariable::tpos_size() const {
  return _internal_tpos_size();
}
inline void TPosVariable::clear_tpos() {
  _internal_mutable_tpos()->Clear();
}
inline float TPosVariable::tpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
  return _internal_tpos().Get(index);
}
inline void TPosVariable::set_tpos(int index, float value) {
  _internal_mutable_tpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
}
inline void TPosVariable::add_tpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
}
inline const ::google::protobuf::RepeatedField<float>& TPosVariable::tpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
  return _internal_tpos();
}
inline ::google::protobuf::RepeatedField<float>* TPosVariable::mutable_tpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.TPosVariable.tpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tpos();
}

inline const ::google::protobuf::RepeatedField<float>& TPosVariable::_internal_tpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tpos_;
}
inline ::google::protobuf::RepeatedField<float>* TPosVariable::_internal_mutable_tpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tpos_;
}

// -------------------------------------------------------------------

// Tool

// string name = 1;
inline void Tool::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Tool::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tool::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.Tool.name)
}
inline std::string* Tool::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.Tool.name)
  return _s;
}
inline const std::string& Tool::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Tool::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Tool::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Tool::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.Tool.name)
  return _impl_.name_.Release();
}
inline void Tool::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.Tool.name)
}

// .IndyFramework.Protobuf.Shared.Tool.ToolType tool_type = 2;
inline void Tool::clear_tool_type() {
  _impl_.tool_type_ = 0;
}
inline ::IndyFramework::Protobuf::Shared::Tool_ToolType Tool::tool_type() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.tool_type)
  return _internal_tool_type();
}
inline void Tool::set_tool_type(::IndyFramework::Protobuf::Shared::Tool_ToolType value) {
  _internal_set_tool_type(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.Tool.tool_type)
}
inline ::IndyFramework::Protobuf::Shared::Tool_ToolType Tool::_internal_tool_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::IndyFramework::Protobuf::Shared::Tool_ToolType>(_impl_.tool_type_);
}
inline void Tool::_internal_set_tool_type(::IndyFramework::Protobuf::Shared::Tool_ToolType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tool_type_ = value;
}

// repeated .IndyFramework.Protobuf.Shared.DigitalSignal do_list = 5;
inline int Tool::_internal_do_list_size() const {
  return _internal_do_list().size();
}
inline int Tool::do_list_size() const {
  return _internal_do_list_size();
}
inline void Tool::clear_do_list() {
  _internal_mutable_do_list()->Clear();
}
inline ::IndyFramework::Protobuf::Shared::DigitalSignal* Tool::mutable_do_list(int index) {
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.Tool.do_list)
  return _internal_mutable_do_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >*
Tool::mutable_do_list() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.Tool.do_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_do_list();
}
inline const ::IndyFramework::Protobuf::Shared::DigitalSignal& Tool::do_list(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.do_list)
    return _internal_do_list().Get(index);
}
inline ::IndyFramework::Protobuf::Shared::DigitalSignal* Tool::add_do_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IndyFramework::Protobuf::Shared::DigitalSignal* _add = _internal_mutable_do_list()->Add();
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.Tool.do_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::DigitalSignal >&
Tool::do_list() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.Tool.do_list)
  return _internal_do_list();
}
inline const ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::DigitalSignal>&
Tool::_internal_do_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.do_list_;
}
inline ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::DigitalSignal>*
Tool::_internal_mutable_do_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.do_list_;
}

// repeated .IndyFramework.Protobuf.Shared.ModbusVariable m_vars = 6;
inline int Tool::_internal_m_vars_size() const {
  return _internal_m_vars().size();
}
inline int Tool::m_vars_size() const {
  return _internal_m_vars_size();
}
inline void Tool::clear_m_vars() {
  _internal_mutable_m_vars()->Clear();
}
inline ::IndyFramework::Protobuf::Shared::ModbusVariable* Tool::mutable_m_vars(int index) {
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return _internal_mutable_m_vars()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >*
Tool::mutable_m_vars() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.Tool.m_vars)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_m_vars();
}
inline const ::IndyFramework::Protobuf::Shared::ModbusVariable& Tool::m_vars(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.m_vars)
    return _internal_m_vars().Get(index);
}
inline ::IndyFramework::Protobuf::Shared::ModbusVariable* Tool::add_m_vars() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::IndyFramework::Protobuf::Shared::ModbusVariable* _add = _internal_mutable_m_vars()->Add();
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::IndyFramework::Protobuf::Shared::ModbusVariable >&
Tool::m_vars() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.Tool.m_vars)
  return _internal_m_vars();
}
inline const ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::ModbusVariable>&
Tool::_internal_m_vars() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.m_vars_;
}
inline ::google::protobuf::RepeatedPtrField<::IndyFramework::Protobuf::Shared::ModbusVariable>*
Tool::_internal_mutable_m_vars() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.m_vars_;
}

// float sleep_time = 10;
inline void Tool::clear_sleep_time() {
  _impl_.sleep_time_ = 0;
}
inline float Tool::sleep_time() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.Tool.sleep_time)
  return _internal_sleep_time();
}
inline void Tool::set_sleep_time(float value) {
  _internal_set_sleep_time(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.Tool.sleep_time)
}
inline float Tool::_internal_sleep_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sleep_time_;
}
inline void Tool::_internal_set_sleep_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sleep_time_ = value;
}

// -------------------------------------------------------------------

// PalletPoint

// repeated float tar_pos = 1;
inline int PalletPoint::_internal_tar_pos_size() const {
  return _internal_tar_pos().size();
}
inline int PalletPoint::tar_pos_size() const {
  return _internal_tar_pos_size();
}
inline void PalletPoint::clear_tar_pos() {
  _internal_mutable_tar_pos()->Clear();
}
inline float PalletPoint::tar_pos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
  return _internal_tar_pos().Get(index);
}
inline void PalletPoint::set_tar_pos(int index, float value) {
  _internal_mutable_tar_pos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
}
inline void PalletPoint::add_tar_pos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tar_pos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
}
inline const ::google::protobuf::RepeatedField<float>& PalletPoint::tar_pos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
  return _internal_tar_pos();
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::mutable_tar_pos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_pos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tar_pos();
}

inline const ::google::protobuf::RepeatedField<float>& PalletPoint::_internal_tar_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tar_pos_;
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::_internal_mutable_tar_pos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tar_pos_;
}

// repeated float approach_pos = 2;
inline int PalletPoint::_internal_approach_pos_size() const {
  return _internal_approach_pos().size();
}
inline int PalletPoint::approach_pos_size() const {
  return _internal_approach_pos_size();
}
inline void PalletPoint::clear_approach_pos() {
  _internal_mutable_approach_pos()->Clear();
}
inline float PalletPoint::approach_pos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
  return _internal_approach_pos().Get(index);
}
inline void PalletPoint::set_approach_pos(int index, float value) {
  _internal_mutable_approach_pos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
}
inline void PalletPoint::add_approach_pos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_approach_pos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
}
inline const ::google::protobuf::RepeatedField<float>& PalletPoint::approach_pos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
  return _internal_approach_pos();
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::mutable_approach_pos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.approach_pos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_approach_pos();
}

inline const ::google::protobuf::RepeatedField<float>& PalletPoint::_internal_approach_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.approach_pos_;
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::_internal_mutable_approach_pos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.approach_pos_;
}

// repeated float retract_pos = 3;
inline int PalletPoint::_internal_retract_pos_size() const {
  return _internal_retract_pos().size();
}
inline int PalletPoint::retract_pos_size() const {
  return _internal_retract_pos_size();
}
inline void PalletPoint::clear_retract_pos() {
  _internal_mutable_retract_pos()->Clear();
}
inline float PalletPoint::retract_pos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
  return _internal_retract_pos().Get(index);
}
inline void PalletPoint::set_retract_pos(int index, float value) {
  _internal_mutable_retract_pos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
}
inline void PalletPoint::add_retract_pos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_retract_pos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
}
inline const ::google::protobuf::RepeatedField<float>& PalletPoint::retract_pos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
  return _internal_retract_pos();
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::mutable_retract_pos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.retract_pos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_retract_pos();
}

inline const ::google::protobuf::RepeatedField<float>& PalletPoint::_internal_retract_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.retract_pos_;
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::_internal_mutable_retract_pos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.retract_pos_;
}

// repeated float tar_jpos = 4;
inline int PalletPoint::_internal_tar_jpos_size() const {
  return _internal_tar_jpos().size();
}
inline int PalletPoint::tar_jpos_size() const {
  return _internal_tar_jpos_size();
}
inline void PalletPoint::clear_tar_jpos() {
  _internal_mutable_tar_jpos()->Clear();
}
inline float PalletPoint::tar_jpos(int index) const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
  return _internal_tar_jpos().Get(index);
}
inline void PalletPoint::set_tar_jpos(int index, float value) {
  _internal_mutable_tar_jpos()->Set(index, value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
}
inline void PalletPoint::add_tar_jpos(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tar_jpos()->Add(value);
  // @@protoc_insertion_point(field_add:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
}
inline const ::google::protobuf::RepeatedField<float>& PalletPoint::tar_jpos() const {
  // @@protoc_insertion_point(field_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
  return _internal_tar_jpos();
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::mutable_tar_jpos() {
  // @@protoc_insertion_point(field_mutable_list:IndyFramework.Protobuf.Shared.PalletPoint.tar_jpos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tar_jpos();
}

inline const ::google::protobuf::RepeatedField<float>& PalletPoint::_internal_tar_jpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tar_jpos_;
}
inline ::google::protobuf::RepeatedField<float>* PalletPoint::_internal_mutable_tar_jpos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tar_jpos_;
}

// -------------------------------------------------------------------

// VisionServer

// string name = 1;
inline void VisionServer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& VisionServer::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionServer::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.name)
}
inline std::string* VisionServer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.VisionServer.name)
  return _s;
}
inline const std::string& VisionServer::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void VisionServer::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionServer::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* VisionServer::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.VisionServer.name)
  return _impl_.name_.Release();
}
inline void VisionServer::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.VisionServer.name)
}

// .IndyFramework.Protobuf.Shared.VisionServer.VisionServerType vision_server_type = 2;
inline void VisionServer::clear_vision_server_type() {
  _impl_.vision_server_type_ = 0;
}
inline ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType VisionServer::vision_server_type() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.vision_server_type)
  return _internal_vision_server_type();
}
inline void VisionServer::set_vision_server_type(::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType value) {
  _internal_set_vision_server_type(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.vision_server_type)
}
inline ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType VisionServer::_internal_vision_server_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType>(_impl_.vision_server_type_);
}
inline void VisionServer::_internal_set_vision_server_type(::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vision_server_type_ = value;
}

// string ip = 3;
inline void VisionServer::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& VisionServer::ip() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionServer::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.ip)
}
inline std::string* VisionServer::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.VisionServer.ip)
  return _s;
}
inline const std::string& VisionServer::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void VisionServer::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionServer::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* VisionServer::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.VisionServer.ip)
  return _impl_.ip_.Release();
}
inline void VisionServer::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.VisionServer.ip)
}

// uint32 port = 4;
inline void VisionServer::clear_port() {
  _impl_.port_ = 0u;
}
inline ::uint32_t VisionServer::port() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.VisionServer.port)
  return _internal_port();
}
inline void VisionServer::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.VisionServer.port)
}
inline ::uint32_t VisionServer::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void VisionServer::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// ModbusServer

// string name = 1;
inline void ModbusServer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModbusServer::name() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusServer.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModbusServer::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusServer.name)
}
inline std::string* ModbusServer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.ModbusServer.name)
  return _s;
}
inline const std::string& ModbusServer::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ModbusServer::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModbusServer::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* ModbusServer::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.ModbusServer.name)
  return _impl_.name_.Release();
}
inline void ModbusServer::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.ModbusServer.name)
}

// string ip = 2;
inline void ModbusServer::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& ModbusServer::ip() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusServer.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModbusServer::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusServer.ip)
}
inline std::string* ModbusServer::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:IndyFramework.Protobuf.Shared.ModbusServer.ip)
  return _s;
}
inline const std::string& ModbusServer::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void ModbusServer::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* ModbusServer::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* ModbusServer::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:IndyFramework.Protobuf.Shared.ModbusServer.ip)
  return _impl_.ip_.Release();
}
inline void ModbusServer::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndyFramework.Protobuf.Shared.ModbusServer.ip)
}

// int32 port = 3;
inline void ModbusServer::clear_port() {
  _impl_.port_ = 0;
}
inline ::int32_t ModbusServer::port() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusServer.port)
  return _internal_port();
}
inline void ModbusServer::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusServer.port)
}
inline ::int32_t ModbusServer::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void ModbusServer::_internal_set_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// int32 unit_id = 4;
inline void ModbusServer::clear_unit_id() {
  _impl_.unit_id_ = 0;
}
inline ::int32_t ModbusServer::unit_id() const {
  // @@protoc_insertion_point(field_get:IndyFramework.Protobuf.Shared.ModbusServer.unit_id)
  return _internal_unit_id();
}
inline void ModbusServer::set_unit_id(::int32_t value) {
  _internal_set_unit_id(value);
  // @@protoc_insertion_point(field_set:IndyFramework.Protobuf.Shared.ModbusServer.unit_id)
}
inline ::int32_t ModbusServer::_internal_unit_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unit_id_;
}
inline void ModbusServer::_internal_set_unit_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unit_id_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Shared
}  // namespace Protobuf
}  // namespace IndyFramework


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::Tool_ToolType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::Tool_ToolType>() {
  return ::IndyFramework::Protobuf::Shared::Tool_ToolType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType>() {
  return ::IndyFramework::Protobuf::Shared::VisionServer_VisionServerType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::MotionState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::MotionState>() {
  return ::IndyFramework::Protobuf::Shared::MotionState_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::EndToolPortType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::EndToolPortType>() {
  return ::IndyFramework::Protobuf::Shared::EndToolPortType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::ControlBoxType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::ControlBoxType>() {
  return ::IndyFramework::Protobuf::Shared::ControlBoxType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::VariableType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::VariableType>() {
  return ::IndyFramework::Protobuf::Shared::VariableType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::ProgramState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::ProgramState>() {
  return ::IndyFramework::Protobuf::Shared::ProgramState_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::ProgramControl> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::ProgramControl>() {
  return ::IndyFramework::Protobuf::Shared::ProgramControl_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::ProgramCategory> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::ProgramCategory>() {
  return ::IndyFramework::Protobuf::Shared::ProgramCategory_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::JointBaseType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::JointBaseType>() {
  return ::IndyFramework::Protobuf::Shared::JointBaseType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::TaskBaseType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::TaskBaseType>() {
  return ::IndyFramework::Protobuf::Shared::TaskBaseType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::BlendingType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::BlendingType>() {
  return ::IndyFramework::Protobuf::Shared::BlendingType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::CircularSettingType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::CircularSettingType>() {
  return ::IndyFramework::Protobuf::Shared::CircularSettingType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::CircularMovingType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::CircularMovingType>() {
  return ::IndyFramework::Protobuf::Shared::CircularMovingType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::TrajState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::TrajState>() {
  return ::IndyFramework::Protobuf::Shared::TrajState_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::TrajCondition> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::TrajCondition>() {
  return ::IndyFramework::Protobuf::Shared::TrajCondition_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::CollisionPolicy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::CollisionPolicy>() {
  return ::IndyFramework::Protobuf::Shared::CollisionPolicy_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::StopCategory> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::StopCategory>() {
  return ::IndyFramework::Protobuf::Shared::StopCategory_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::PauseCategory> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::PauseCategory>() {
  return ::IndyFramework::Protobuf::Shared::PauseCategory_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::EyeCommandType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::EyeCommandType>() {
  return ::IndyFramework::Protobuf::Shared::EyeCommandType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::DIConfigFunc> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::DIConfigFunc>() {
  return ::IndyFramework::Protobuf::Shared::DIConfigFunc_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::DOConfigState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::DOConfigState>() {
  return ::IndyFramework::Protobuf::Shared::DOConfigState_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::OpState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::OpState>() {
  return ::IndyFramework::Protobuf::Shared::OpState_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::LogLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::LogLevel>() {
  return ::IndyFramework::Protobuf::Shared::LogLevel_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::JogFrameType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::JogFrameType>() {
  return ::IndyFramework::Protobuf::Shared::JogFrameType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::Axis> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::Axis>() {
  return ::IndyFramework::Protobuf::Shared::Axis_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::VisionFrameType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::VisionFrameType>() {
  return ::IndyFramework::Protobuf::Shared::VisionFrameType_descriptor();
}
template <>
struct is_proto_enum<::IndyFramework::Protobuf::Shared::WeavingBase> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::IndyFramework::Protobuf::Shared::WeavingBase>() {
  return ::IndyFramework::Protobuf::Shared::WeavingBase_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_shared_5fmsgs_2eproto_2epb_2eh
