// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_msgs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_device_5fmsgs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_device_5fmsgs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common_msgs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_device_5fmsgs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_device_5fmsgs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_device_5fmsgs_2eproto;
namespace Nrmk {
namespace IndyFramework {
class AnalogList;
class AnalogListDefaultTypeInternal;
extern AnalogListDefaultTypeInternal _AnalogList_default_instance_;
class AnalogSignal;
class AnalogSignalDefaultTypeInternal;
extern AnalogSignalDefaultTypeInternal _AnalogSignal_default_instance_;
class BrakeControlStyle;
class BrakeControlStyleDefaultTypeInternal;
extern BrakeControlStyleDefaultTypeInternal _BrakeControlStyle_default_instance_;
class CheckAutoModeRes;
class CheckAutoModeResDefaultTypeInternal;
extern CheckAutoModeResDefaultTypeInternal _CheckAutoModeRes_default_instance_;
class CheckReducedModeRes;
class CheckReducedModeResDefaultTypeInternal;
extern CheckReducedModeResDefaultTypeInternal _CheckReducedModeRes_default_instance_;
class Conveyor;
class ConveyorDefaultTypeInternal;
extern ConveyorDefaultTypeInternal _Conveyor_default_instance_;
class ConveyorState;
class ConveyorStateDefaultTypeInternal;
extern ConveyorStateDefaultTypeInternal _ConveyorState_default_instance_;
class DeviceInfo;
class DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class DigitalList;
class DigitalListDefaultTypeInternal;
extern DigitalListDefaultTypeInternal _DigitalList_default_instance_;
class DigitalSignal;
class DigitalSignalDefaultTypeInternal;
extern DigitalSignalDefaultTypeInternal _DigitalSignal_default_instance_;
class Encoder;
class EncoderDefaultTypeInternal;
extern EncoderDefaultTypeInternal _Encoder_default_instance_;
class EndLedDim;
class EndLedDimDefaultTypeInternal;
extern EndLedDimDefaultTypeInternal _EndLedDim_default_instance_;
class EndtoolSignal;
class EndtoolSignalDefaultTypeInternal;
extern EndtoolSignalDefaultTypeInternal _EndtoolSignal_default_instance_;
class EndtoolSignalList;
class EndtoolSignalListDefaultTypeInternal;
extern EndtoolSignalListDefaultTypeInternal _EndtoolSignalList_default_instance_;
class FTSensorData;
class FTSensorDataDefaultTypeInternal;
extern FTSensorDataDefaultTypeInternal _FTSensorData_default_instance_;
class GetEL5001Data;
class GetEL5001DataDefaultTypeInternal;
extern GetEL5001DataDefaultTypeInternal _GetEL5001Data_default_instance_;
class GetEL5101Data;
class GetEL5101DataDefaultTypeInternal;
extern GetEL5101DataDefaultTypeInternal _GetEL5101Data_default_instance_;
class GetLoadFactorsRes;
class GetLoadFactorsResDefaultTypeInternal;
extern GetLoadFactorsResDefaultTypeInternal _GetLoadFactorsRes_default_instance_;
class GripperCommand;
class GripperCommandDefaultTypeInternal;
extern GripperCommandDefaultTypeInternal _GripperCommand_default_instance_;
class GripperData;
class GripperDataDefaultTypeInternal;
extern GripperDataDefaultTypeInternal _GripperData_default_instance_;
class Motor;
class MotorDefaultTypeInternal;
extern MotorDefaultTypeInternal _Motor_default_instance_;
class MotorList;
class MotorListDefaultTypeInternal;
extern MotorListDefaultTypeInternal _MotorList_default_instance_;
class SafetyControlData;
class SafetyControlDataDefaultTypeInternal;
extern SafetyControlDataDefaultTypeInternal _SafetyControlData_default_instance_;
class SafetyFunctionState;
class SafetyFunctionStateDefaultTypeInternal;
extern SafetyFunctionStateDefaultTypeInternal _SafetyFunctionState_default_instance_;
class SanderCommand;
class SanderCommandDefaultTypeInternal;
extern SanderCommandDefaultTypeInternal _SanderCommand_default_instance_;
class Servo;
class ServoDefaultTypeInternal;
extern ServoDefaultTypeInternal _Servo_default_instance_;
class SetAutoModeReq;
class SetAutoModeReqDefaultTypeInternal;
extern SetAutoModeReqDefaultTypeInternal _SetAutoModeReq_default_instance_;
class SetAutoModeRes;
class SetAutoModeResDefaultTypeInternal;
extern SetAutoModeResDefaultTypeInternal _SetAutoModeRes_default_instance_;
class Trigger;
class TriggerDefaultTypeInternal;
extern TriggerDefaultTypeInternal _Trigger_default_instance_;
}  // namespace IndyFramework
}  // namespace Nrmk
PROTOBUF_NAMESPACE_OPEN
template<> ::Nrmk::IndyFramework::AnalogList* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::AnalogList>(Arena*);
template<> ::Nrmk::IndyFramework::AnalogSignal* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::AnalogSignal>(Arena*);
template<> ::Nrmk::IndyFramework::BrakeControlStyle* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::BrakeControlStyle>(Arena*);
template<> ::Nrmk::IndyFramework::CheckAutoModeRes* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::CheckAutoModeRes>(Arena*);
template<> ::Nrmk::IndyFramework::CheckReducedModeRes* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::CheckReducedModeRes>(Arena*);
template<> ::Nrmk::IndyFramework::Conveyor* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::Conveyor>(Arena*);
template<> ::Nrmk::IndyFramework::ConveyorState* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::ConveyorState>(Arena*);
template<> ::Nrmk::IndyFramework::DeviceInfo* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::DeviceInfo>(Arena*);
template<> ::Nrmk::IndyFramework::DigitalList* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::DigitalList>(Arena*);
template<> ::Nrmk::IndyFramework::DigitalSignal* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::DigitalSignal>(Arena*);
template<> ::Nrmk::IndyFramework::Encoder* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::Encoder>(Arena*);
template<> ::Nrmk::IndyFramework::EndLedDim* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::EndLedDim>(Arena*);
template<> ::Nrmk::IndyFramework::EndtoolSignal* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::EndtoolSignal>(Arena*);
template<> ::Nrmk::IndyFramework::EndtoolSignalList* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::EndtoolSignalList>(Arena*);
template<> ::Nrmk::IndyFramework::FTSensorData* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::FTSensorData>(Arena*);
template<> ::Nrmk::IndyFramework::GetEL5001Data* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::GetEL5001Data>(Arena*);
template<> ::Nrmk::IndyFramework::GetEL5101Data* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::GetEL5101Data>(Arena*);
template<> ::Nrmk::IndyFramework::GetLoadFactorsRes* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::GetLoadFactorsRes>(Arena*);
template<> ::Nrmk::IndyFramework::GripperCommand* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::GripperCommand>(Arena*);
template<> ::Nrmk::IndyFramework::GripperData* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::GripperData>(Arena*);
template<> ::Nrmk::IndyFramework::Motor* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::Motor>(Arena*);
template<> ::Nrmk::IndyFramework::MotorList* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::MotorList>(Arena*);
template<> ::Nrmk::IndyFramework::SafetyControlData* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::SafetyControlData>(Arena*);
template<> ::Nrmk::IndyFramework::SafetyFunctionState* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::SafetyFunctionState>(Arena*);
template<> ::Nrmk::IndyFramework::SanderCommand* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::SanderCommand>(Arena*);
template<> ::Nrmk::IndyFramework::Servo* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::Servo>(Arena*);
template<> ::Nrmk::IndyFramework::SetAutoModeReq* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::SetAutoModeReq>(Arena*);
template<> ::Nrmk::IndyFramework::SetAutoModeRes* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::SetAutoModeRes>(Arena*);
template<> ::Nrmk::IndyFramework::Trigger* Arena::CreateMaybeMessage<::Nrmk::IndyFramework::Trigger>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Nrmk {
namespace IndyFramework {

enum GripperCommand_GripperCommandType : int {
  GripperCommand_GripperCommandType_AUTO_DETECT = 0,
  GripperCommand_GripperCommandType_ACTIVATE = 1,
  GripperCommand_GripperCommandType_RE_ACTIVATE = 2,
  GripperCommand_GripperCommandType_SET_PVT = 3,
  GripperCommand_GripperCommandType_GripperCommand_GripperCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GripperCommand_GripperCommandType_GripperCommand_GripperCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GripperCommand_GripperCommandType_IsValid(int value);
constexpr GripperCommand_GripperCommandType GripperCommand_GripperCommandType_GripperCommandType_MIN = GripperCommand_GripperCommandType_AUTO_DETECT;
constexpr GripperCommand_GripperCommandType GripperCommand_GripperCommandType_GripperCommandType_MAX = GripperCommand_GripperCommandType_SET_PVT;
constexpr int GripperCommand_GripperCommandType_GripperCommandType_ARRAYSIZE = GripperCommand_GripperCommandType_GripperCommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GripperCommand_GripperCommandType_descriptor();
template<typename T>
inline const std::string& GripperCommand_GripperCommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GripperCommand_GripperCommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GripperCommand_GripperCommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GripperCommand_GripperCommandType_descriptor(), enum_t_value);
}
inline bool GripperCommand_GripperCommandType_Parse(
    const std::string& name, GripperCommand_GripperCommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GripperCommand_GripperCommandType>(
    GripperCommand_GripperCommandType_descriptor(), name, value);
}
enum BrakeControlStyle_ControlStyle : int {
  BrakeControlStyle_ControlStyle_UNAVAILABLE = 0,
  BrakeControlStyle_ControlStyle_CONCURRENT = 1,
  BrakeControlStyle_ControlStyle_INDIVIDUAL = 2,
  BrakeControlStyle_ControlStyle_BrakeControlStyle_ControlStyle_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BrakeControlStyle_ControlStyle_BrakeControlStyle_ControlStyle_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BrakeControlStyle_ControlStyle_IsValid(int value);
constexpr BrakeControlStyle_ControlStyle BrakeControlStyle_ControlStyle_ControlStyle_MIN = BrakeControlStyle_ControlStyle_UNAVAILABLE;
constexpr BrakeControlStyle_ControlStyle BrakeControlStyle_ControlStyle_ControlStyle_MAX = BrakeControlStyle_ControlStyle_INDIVIDUAL;
constexpr int BrakeControlStyle_ControlStyle_ControlStyle_ARRAYSIZE = BrakeControlStyle_ControlStyle_ControlStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeControlStyle_ControlStyle_descriptor();
template<typename T>
inline const std::string& BrakeControlStyle_ControlStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeControlStyle_ControlStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeControlStyle_ControlStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeControlStyle_ControlStyle_descriptor(), enum_t_value);
}
inline bool BrakeControlStyle_ControlStyle_Parse(
    const std::string& name, BrakeControlStyle_ControlStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeControlStyle_ControlStyle>(
    BrakeControlStyle_ControlStyle_descriptor(), name, value);
}
enum SanderCommand_SanderType : int {
  SanderCommand_SanderType_SANDER_ONROBOT = 0,
  SanderCommand_SanderType_SanderCommand_SanderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SanderCommand_SanderType_SanderCommand_SanderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SanderCommand_SanderType_IsValid(int value);
constexpr SanderCommand_SanderType SanderCommand_SanderType_SanderType_MIN = SanderCommand_SanderType_SANDER_ONROBOT;
constexpr SanderCommand_SanderType SanderCommand_SanderType_SanderType_MAX = SanderCommand_SanderType_SANDER_ONROBOT;
constexpr int SanderCommand_SanderType_SanderType_ARRAYSIZE = SanderCommand_SanderType_SanderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SanderCommand_SanderType_descriptor();
template<typename T>
inline const std::string& SanderCommand_SanderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SanderCommand_SanderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SanderCommand_SanderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SanderCommand_SanderType_descriptor(), enum_t_value);
}
inline bool SanderCommand_SanderType_Parse(
    const std::string& name, SanderCommand_SanderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SanderCommand_SanderType>(
    SanderCommand_SanderType_descriptor(), name, value);
}
enum Encoder_EncoderType : int {
  Encoder_EncoderType_CONSTANT = 0,
  Encoder_EncoderType_QUADRATURE = 1,
  Encoder_EncoderType_RISING = 2,
  Encoder_EncoderType_FALLING = 3,
  Encoder_EncoderType_MODBUS = 4,
  Encoder_EncoderType_Encoder_EncoderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Encoder_EncoderType_Encoder_EncoderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Encoder_EncoderType_IsValid(int value);
constexpr Encoder_EncoderType Encoder_EncoderType_EncoderType_MIN = Encoder_EncoderType_CONSTANT;
constexpr Encoder_EncoderType Encoder_EncoderType_EncoderType_MAX = Encoder_EncoderType_MODBUS;
constexpr int Encoder_EncoderType_EncoderType_ARRAYSIZE = Encoder_EncoderType_EncoderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Encoder_EncoderType_descriptor();
template<typename T>
inline const std::string& Encoder_EncoderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Encoder_EncoderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Encoder_EncoderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Encoder_EncoderType_descriptor(), enum_t_value);
}
inline bool Encoder_EncoderType_Parse(
    const std::string& name, Encoder_EncoderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Encoder_EncoderType>(
    Encoder_EncoderType_descriptor(), name, value);
}
enum Trigger_TriggerType : int {
  Trigger_TriggerType_DIGITAL = 0,
  Trigger_TriggerType_MODBUS = 1,
  Trigger_TriggerType_Trigger_TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Trigger_TriggerType_Trigger_TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Trigger_TriggerType_IsValid(int value);
constexpr Trigger_TriggerType Trigger_TriggerType_TriggerType_MIN = Trigger_TriggerType_DIGITAL;
constexpr Trigger_TriggerType Trigger_TriggerType_TriggerType_MAX = Trigger_TriggerType_MODBUS;
constexpr int Trigger_TriggerType_TriggerType_ARRAYSIZE = Trigger_TriggerType_TriggerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Trigger_TriggerType_descriptor();
template<typename T>
inline const std::string& Trigger_TriggerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Trigger_TriggerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Trigger_TriggerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Trigger_TriggerType_descriptor(), enum_t_value);
}
inline bool Trigger_TriggerType_Parse(
    const std::string& name, Trigger_TriggerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Trigger_TriggerType>(
    Trigger_TriggerType_descriptor(), name, value);
}
enum GripperType : int {
  NONE = 0,
  ROBOTIQ_GRIPPER = 1,
  DH_GRIPPER = 2,
  GripperType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GripperType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GripperType_IsValid(int value);
constexpr GripperType GripperType_MIN = NONE;
constexpr GripperType GripperType_MAX = DH_GRIPPER;
constexpr int GripperType_ARRAYSIZE = GripperType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GripperType_descriptor();
template<typename T>
inline const std::string& GripperType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GripperType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GripperType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GripperType_descriptor(), enum_t_value);
}
inline bool GripperType_Parse(
    const std::string& name, GripperType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GripperType>(
    GripperType_descriptor(), name, value);
}
enum DigitalState : int {
  OFF_STATE = 0,
  ON_STATE = 1,
  UNUSED_STATE = 2,
  DigitalState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DigitalState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DigitalState_IsValid(int value);
constexpr DigitalState DigitalState_MIN = OFF_STATE;
constexpr DigitalState DigitalState_MAX = UNUSED_STATE;
constexpr int DigitalState_ARRAYSIZE = DigitalState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DigitalState_descriptor();
template<typename T>
inline const std::string& DigitalState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DigitalState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DigitalState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DigitalState_descriptor(), enum_t_value);
}
inline bool DigitalState_Parse(
    const std::string& name, DigitalState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DigitalState>(
    DigitalState_descriptor(), name, value);
}
enum EndtoolState : int {
  UNUSED = 0,
  HIGH_PNP = 2,
  HIGH_NPN = 1,
  LOW_NPN = -1,
  LOW_PNP = -2,
  EndtoolState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EndtoolState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EndtoolState_IsValid(int value);
constexpr EndtoolState EndtoolState_MIN = LOW_PNP;
constexpr EndtoolState EndtoolState_MAX = HIGH_PNP;
constexpr int EndtoolState_ARRAYSIZE = EndtoolState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EndtoolState_descriptor();
template<typename T>
inline const std::string& EndtoolState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EndtoolState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EndtoolState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EndtoolState_descriptor(), enum_t_value);
}
inline bool EndtoolState_Parse(
    const std::string& name, EndtoolState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EndtoolState>(
    EndtoolState_descriptor(), name, value);
}
// ===================================================================

class Motor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Motor) */ {
 public:
  Motor();
  virtual ~Motor();

  Motor(const Motor& from);
  Motor(Motor&& from) noexcept
    : Motor() {
    *this = ::std::move(from);
  }

  inline Motor& operator=(const Motor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Motor& operator=(Motor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Motor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Motor* internal_default_instance() {
    return reinterpret_cast<const Motor*>(
               &_Motor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Motor* other);
  friend void swap(Motor& a, Motor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Motor* New() const final {
    return CreateMaybeMessage<Motor>(nullptr);
  }

  Motor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Motor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Motor& from);
  void MergeFrom(const Motor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Motor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.Motor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool enable = 2;
  void clear_enable();
  static const int kEnableFieldNumber = 2;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Motor)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  bool enable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Servo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Servo) */ {
 public:
  Servo();
  virtual ~Servo();

  Servo(const Servo& from);
  Servo(Servo&& from) noexcept
    : Servo() {
    *this = ::std::move(from);
  }

  inline Servo& operator=(const Servo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Servo& operator=(Servo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Servo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Servo* internal_default_instance() {
    return reinterpret_cast<const Servo*>(
               &_Servo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Servo* other);
  friend void swap(Servo& a, Servo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Servo* New() const final {
    return CreateMaybeMessage<Servo>(nullptr);
  }

  Servo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Servo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Servo& from);
  void MergeFrom(const Servo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Servo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.Servo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool enable = 2;
  void clear_enable();
  static const int kEnableFieldNumber = 2;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Servo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  bool enable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class GripperData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GripperData) */ {
 public:
  GripperData();
  virtual ~GripperData();

  GripperData(const GripperData& from);
  GripperData(GripperData&& from) noexcept
    : GripperData() {
    *this = ::std::move(from);
  }

  inline GripperData& operator=(const GripperData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GripperData& operator=(GripperData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GripperData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GripperData* internal_default_instance() {
    return reinterpret_cast<const GripperData*>(
               &_GripperData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GripperData* other);
  friend void swap(GripperData& a, GripperData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GripperData* New() const final {
    return CreateMaybeMessage<GripperData>(nullptr);
  }

  GripperData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GripperData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GripperData& from);
  void MergeFrom(const GripperData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GripperData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.GripperData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Nrmk.IndyFramework.GripperType gripper_type = 1;
  void clear_gripper_type();
  static const int kGripperTypeFieldNumber = 1;
  ::Nrmk::IndyFramework::GripperType gripper_type() const;
  void set_gripper_type(::Nrmk::IndyFramework::GripperType value);

  // int32 gripper_position = 2;
  void clear_gripper_position();
  static const int kGripperPositionFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 gripper_position() const;
  void set_gripper_position(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 gripper_state = 3;
  void clear_gripper_state();
  static const int kGripperStateFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 gripper_state() const;
  void set_gripper_state(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GripperData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int gripper_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 gripper_position_;
  ::PROTOBUF_NAMESPACE_ID::int32 gripper_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class GripperCommand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GripperCommand) */ {
 public:
  GripperCommand();
  virtual ~GripperCommand();

  GripperCommand(const GripperCommand& from);
  GripperCommand(GripperCommand&& from) noexcept
    : GripperCommand() {
    *this = ::std::move(from);
  }

  inline GripperCommand& operator=(const GripperCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GripperCommand& operator=(GripperCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GripperCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GripperCommand* internal_default_instance() {
    return reinterpret_cast<const GripperCommand*>(
               &_GripperCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GripperCommand* other);
  friend void swap(GripperCommand& a, GripperCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GripperCommand* New() const final {
    return CreateMaybeMessage<GripperCommand>(nullptr);
  }

  GripperCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GripperCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GripperCommand& from);
  void MergeFrom(const GripperCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GripperCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.GripperCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GripperCommand_GripperCommandType GripperCommandType;
  static constexpr GripperCommandType AUTO_DETECT =
    GripperCommand_GripperCommandType_AUTO_DETECT;
  static constexpr GripperCommandType ACTIVATE =
    GripperCommand_GripperCommandType_ACTIVATE;
  static constexpr GripperCommandType RE_ACTIVATE =
    GripperCommand_GripperCommandType_RE_ACTIVATE;
  static constexpr GripperCommandType SET_PVT =
    GripperCommand_GripperCommandType_SET_PVT;
  static inline bool GripperCommandType_IsValid(int value) {
    return GripperCommand_GripperCommandType_IsValid(value);
  }
  static constexpr GripperCommandType GripperCommandType_MIN =
    GripperCommand_GripperCommandType_GripperCommandType_MIN;
  static constexpr GripperCommandType GripperCommandType_MAX =
    GripperCommand_GripperCommandType_GripperCommandType_MAX;
  static constexpr int GripperCommandType_ARRAYSIZE =
    GripperCommand_GripperCommandType_GripperCommandType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GripperCommandType_descriptor() {
    return GripperCommand_GripperCommandType_descriptor();
  }
  template<typename T>
  static inline const std::string& GripperCommandType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GripperCommandType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GripperCommandType_Name.");
    return GripperCommand_GripperCommandType_Name(enum_t_value);
  }
  static inline bool GripperCommandType_Parse(const std::string& name,
      GripperCommandType* value) {
    return GripperCommand_GripperCommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 gripper_pvt_data = 3;
  int gripper_pvt_data_size() const;
  void clear_gripper_pvt_data();
  static const int kGripperPvtDataFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 gripper_pvt_data(int index) const;
  void set_gripper_pvt_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_gripper_pvt_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      gripper_pvt_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_gripper_pvt_data();

  // .Nrmk.IndyFramework.GripperCommand.GripperCommandType gripper_command = 1;
  void clear_gripper_command();
  static const int kGripperCommandFieldNumber = 1;
  ::Nrmk::IndyFramework::GripperCommand_GripperCommandType gripper_command() const;
  void set_gripper_command(::Nrmk::IndyFramework::GripperCommand_GripperCommandType value);

  // .Nrmk.IndyFramework.GripperType gripper_type = 2;
  void clear_gripper_type();
  static const int kGripperTypeFieldNumber = 2;
  ::Nrmk::IndyFramework::GripperType gripper_type() const;
  void set_gripper_type(::Nrmk::IndyFramework::GripperType value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GripperCommand)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > gripper_pvt_data_;
  mutable std::atomic<int> _gripper_pvt_data_cached_byte_size_;
  int gripper_command_;
  int gripper_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class DigitalSignal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.DigitalSignal) */ {
 public:
  DigitalSignal();
  virtual ~DigitalSignal();

  DigitalSignal(const DigitalSignal& from);
  DigitalSignal(DigitalSignal&& from) noexcept
    : DigitalSignal() {
    *this = ::std::move(from);
  }

  inline DigitalSignal& operator=(const DigitalSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitalSignal& operator=(DigitalSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DigitalSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DigitalSignal* internal_default_instance() {
    return reinterpret_cast<const DigitalSignal*>(
               &_DigitalSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DigitalSignal* other);
  friend void swap(DigitalSignal& a, DigitalSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DigitalSignal* New() const final {
    return CreateMaybeMessage<DigitalSignal>(nullptr);
  }

  DigitalSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigitalSignal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DigitalSignal& from);
  void MergeFrom(const DigitalSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitalSignal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.DigitalSignal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 address() const;
  void set_address(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .Nrmk.IndyFramework.DigitalState state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::Nrmk::IndyFramework::DigitalState state() const;
  void set_state(::Nrmk::IndyFramework::DigitalState value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.DigitalSignal)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 address_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class EndLedDim :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.EndLedDim) */ {
 public:
  EndLedDim();
  virtual ~EndLedDim();

  EndLedDim(const EndLedDim& from);
  EndLedDim(EndLedDim&& from) noexcept
    : EndLedDim() {
    *this = ::std::move(from);
  }

  inline EndLedDim& operator=(const EndLedDim& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndLedDim& operator=(EndLedDim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EndLedDim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndLedDim* internal_default_instance() {
    return reinterpret_cast<const EndLedDim*>(
               &_EndLedDim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(EndLedDim* other);
  friend void swap(EndLedDim& a, EndLedDim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndLedDim* New() const final {
    return CreateMaybeMessage<EndLedDim>(nullptr);
  }

  EndLedDim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EndLedDim>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EndLedDim& from);
  void MergeFrom(const EndLedDim& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndLedDim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.EndLedDim";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 led_dim = 1;
  void clear_led_dim();
  static const int kLedDimFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 led_dim() const;
  void set_led_dim(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.EndLedDim)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 led_dim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class EndtoolSignal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.EndtoolSignal) */ {
 public:
  EndtoolSignal();
  virtual ~EndtoolSignal();

  EndtoolSignal(const EndtoolSignal& from);
  EndtoolSignal(EndtoolSignal&& from) noexcept
    : EndtoolSignal() {
    *this = ::std::move(from);
  }

  inline EndtoolSignal& operator=(const EndtoolSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndtoolSignal& operator=(EndtoolSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EndtoolSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndtoolSignal* internal_default_instance() {
    return reinterpret_cast<const EndtoolSignal*>(
               &_EndtoolSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(EndtoolSignal* other);
  friend void swap(EndtoolSignal& a, EndtoolSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndtoolSignal* New() const final {
    return CreateMaybeMessage<EndtoolSignal>(nullptr);
  }

  EndtoolSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EndtoolSignal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EndtoolSignal& from);
  void MergeFrom(const EndtoolSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndtoolSignal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.EndtoolSignal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Nrmk.IndyFramework.EndtoolState states = 2;
  int states_size() const;
  void clear_states();
  static const int kStatesFieldNumber = 2;
  ::Nrmk::IndyFramework::EndtoolState states(int index) const;
  void set_states(int index, ::Nrmk::IndyFramework::EndtoolState value);
  void add_states(::Nrmk::IndyFramework::EndtoolState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_states();

  // string port = 1;
  void clear_port();
  static const int kPortFieldNumber = 1;
  const std::string& port() const;
  void set_port(const std::string& value);
  void set_port(std::string&& value);
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  std::string* mutable_port();
  std::string* release_port();
  void set_allocated_port(std::string* port);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.EndtoolSignal)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> states_;
  mutable std::atomic<int> _states_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class AnalogSignal :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.AnalogSignal) */ {
 public:
  AnalogSignal();
  virtual ~AnalogSignal();

  AnalogSignal(const AnalogSignal& from);
  AnalogSignal(AnalogSignal&& from) noexcept
    : AnalogSignal() {
    *this = ::std::move(from);
  }

  inline AnalogSignal& operator=(const AnalogSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogSignal& operator=(AnalogSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnalogSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalogSignal* internal_default_instance() {
    return reinterpret_cast<const AnalogSignal*>(
               &_AnalogSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AnalogSignal* other);
  friend void swap(AnalogSignal& a, AnalogSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalogSignal* New() const final {
    return CreateMaybeMessage<AnalogSignal>(nullptr);
  }

  AnalogSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnalogSignal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnalogSignal& from);
  void MergeFrom(const AnalogSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogSignal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.AnalogSignal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 address() const;
  void set_address(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // int32 voltage = 2;
  void clear_voltage();
  static const int kVoltageFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 voltage() const;
  void set_voltage(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.AnalogSignal)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 address_;
  ::PROTOBUF_NAMESPACE_ID::int32 voltage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class MotorList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.MotorList) */ {
 public:
  MotorList();
  virtual ~MotorList();

  MotorList(const MotorList& from);
  MotorList(MotorList&& from) noexcept
    : MotorList() {
    *this = ::std::move(from);
  }

  inline MotorList& operator=(const MotorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorList& operator=(MotorList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MotorList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorList* internal_default_instance() {
    return reinterpret_cast<const MotorList*>(
               &_MotorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MotorList* other);
  friend void swap(MotorList& a, MotorList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorList* New() const final {
    return CreateMaybeMessage<MotorList>(nullptr);
  }

  MotorList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotorList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotorList& from);
  void MergeFrom(const MotorList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.MotorList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Nrmk.IndyFramework.Motor motors = 1;
  int motors_size() const;
  void clear_motors();
  static const int kMotorsFieldNumber = 1;
  ::Nrmk::IndyFramework::Motor* mutable_motors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >*
      mutable_motors();
  const ::Nrmk::IndyFramework::Motor& motors(int index) const;
  ::Nrmk::IndyFramework::Motor* add_motors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >&
      motors() const;

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.MotorList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::Motor > motors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class DigitalList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.DigitalList) */ {
 public:
  DigitalList();
  virtual ~DigitalList();

  DigitalList(const DigitalList& from);
  DigitalList(DigitalList&& from) noexcept
    : DigitalList() {
    *this = ::std::move(from);
  }

  inline DigitalList& operator=(const DigitalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitalList& operator=(DigitalList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DigitalList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DigitalList* internal_default_instance() {
    return reinterpret_cast<const DigitalList*>(
               &_DigitalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(DigitalList* other);
  friend void swap(DigitalList& a, DigitalList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DigitalList* New() const final {
    return CreateMaybeMessage<DigitalList>(nullptr);
  }

  DigitalList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigitalList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DigitalList& from);
  void MergeFrom(const DigitalList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitalList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.DigitalList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Nrmk.IndyFramework.DigitalSignal signals = 1;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 1;
  ::Nrmk::IndyFramework::DigitalSignal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >*
      mutable_signals();
  const ::Nrmk::IndyFramework::DigitalSignal& signals(int index) const;
  ::Nrmk::IndyFramework::DigitalSignal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >&
      signals() const;

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.DigitalList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal > signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class EndtoolSignalList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.EndtoolSignalList) */ {
 public:
  EndtoolSignalList();
  virtual ~EndtoolSignalList();

  EndtoolSignalList(const EndtoolSignalList& from);
  EndtoolSignalList(EndtoolSignalList&& from) noexcept
    : EndtoolSignalList() {
    *this = ::std::move(from);
  }

  inline EndtoolSignalList& operator=(const EndtoolSignalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndtoolSignalList& operator=(EndtoolSignalList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EndtoolSignalList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndtoolSignalList* internal_default_instance() {
    return reinterpret_cast<const EndtoolSignalList*>(
               &_EndtoolSignalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(EndtoolSignalList* other);
  friend void swap(EndtoolSignalList& a, EndtoolSignalList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndtoolSignalList* New() const final {
    return CreateMaybeMessage<EndtoolSignalList>(nullptr);
  }

  EndtoolSignalList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EndtoolSignalList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EndtoolSignalList& from);
  void MergeFrom(const EndtoolSignalList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndtoolSignalList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.EndtoolSignalList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Nrmk.IndyFramework.EndtoolSignal signals = 1;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 1;
  ::Nrmk::IndyFramework::EndtoolSignal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >*
      mutable_signals();
  const ::Nrmk::IndyFramework::EndtoolSignal& signals(int index) const;
  ::Nrmk::IndyFramework::EndtoolSignal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >&
      signals() const;

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.EndtoolSignalList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal > signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class AnalogList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.AnalogList) */ {
 public:
  AnalogList();
  virtual ~AnalogList();

  AnalogList(const AnalogList& from);
  AnalogList(AnalogList&& from) noexcept
    : AnalogList() {
    *this = ::std::move(from);
  }

  inline AnalogList& operator=(const AnalogList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogList& operator=(AnalogList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnalogList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalogList* internal_default_instance() {
    return reinterpret_cast<const AnalogList*>(
               &_AnalogList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AnalogList* other);
  friend void swap(AnalogList& a, AnalogList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalogList* New() const final {
    return CreateMaybeMessage<AnalogList>(nullptr);
  }

  AnalogList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnalogList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnalogList& from);
  void MergeFrom(const AnalogList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.AnalogList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Nrmk.IndyFramework.AnalogSignal signals = 1;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 1;
  ::Nrmk::IndyFramework::AnalogSignal* mutable_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >*
      mutable_signals();
  const ::Nrmk::IndyFramework::AnalogSignal& signals(int index) const;
  ::Nrmk::IndyFramework::AnalogSignal* add_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >&
      signals() const;

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.AnalogList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal > signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.DeviceInfo) */ {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DeviceInfo* other);
  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return CreateMaybeMessage<DeviceInfo>(nullptr);
  }

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.DeviceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string core_board_fw_vers = 11;
  int core_board_fw_vers_size() const;
  void clear_core_board_fw_vers();
  static const int kCoreBoardFwVersFieldNumber = 11;
  const std::string& core_board_fw_vers(int index) const;
  std::string* mutable_core_board_fw_vers(int index);
  void set_core_board_fw_vers(int index, const std::string& value);
  void set_core_board_fw_vers(int index, std::string&& value);
  void set_core_board_fw_vers(int index, const char* value);
  void set_core_board_fw_vers(int index, const char* value, size_t size);
  std::string* add_core_board_fw_vers();
  void add_core_board_fw_vers(const std::string& value);
  void add_core_board_fw_vers(std::string&& value);
  void add_core_board_fw_vers(const char* value);
  void add_core_board_fw_vers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& core_board_fw_vers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_core_board_fw_vers();

  // string robot_serial = 2;
  void clear_robot_serial();
  static const int kRobotSerialFieldNumber = 2;
  const std::string& robot_serial() const;
  void set_robot_serial(const std::string& value);
  void set_robot_serial(std::string&& value);
  void set_robot_serial(const char* value);
  void set_robot_serial(const char* value, size_t size);
  std::string* mutable_robot_serial();
  std::string* release_robot_serial();
  void set_allocated_robot_serial(std::string* robot_serial);

  // string io_board_fw_ver = 10;
  void clear_io_board_fw_ver();
  static const int kIoBoardFwVerFieldNumber = 10;
  const std::string& io_board_fw_ver() const;
  void set_io_board_fw_ver(const std::string& value);
  void set_io_board_fw_ver(std::string&& value);
  void set_io_board_fw_ver(const char* value);
  void set_io_board_fw_ver(const char* value, size_t size);
  std::string* mutable_io_board_fw_ver();
  std::string* release_io_board_fw_ver();
  void set_allocated_io_board_fw_ver(std::string* io_board_fw_ver);

  // string endtool_board_fw_ver = 12;
  void clear_endtool_board_fw_ver();
  static const int kEndtoolBoardFwVerFieldNumber = 12;
  const std::string& endtool_board_fw_ver() const;
  void set_endtool_board_fw_ver(const std::string& value);
  void set_endtool_board_fw_ver(std::string&& value);
  void set_endtool_board_fw_ver(const char* value);
  void set_endtool_board_fw_ver(const char* value, size_t size);
  std::string* mutable_endtool_board_fw_ver();
  std::string* release_endtool_board_fw_ver();
  void set_allocated_endtool_board_fw_ver(std::string* endtool_board_fw_ver);

  // string controller_ver = 20;
  void clear_controller_ver();
  static const int kControllerVerFieldNumber = 20;
  const std::string& controller_ver() const;
  void set_controller_ver(const std::string& value);
  void set_controller_ver(std::string&& value);
  void set_controller_ver(const char* value);
  void set_controller_ver(const char* value, size_t size);
  std::string* mutable_controller_ver();
  std::string* release_controller_ver();
  void set_allocated_controller_ver(std::string* controller_ver);

  // string controller_detail = 21;
  void clear_controller_detail();
  static const int kControllerDetailFieldNumber = 21;
  const std::string& controller_detail() const;
  void set_controller_detail(const std::string& value);
  void set_controller_detail(std::string&& value);
  void set_controller_detail(const char* value);
  void set_controller_detail(const char* value, size_t size);
  std::string* mutable_controller_detail();
  std::string* release_controller_detail();
  void set_allocated_controller_detail(std::string* controller_detail);

  // string controller_date = 22;
  void clear_controller_date();
  static const int kControllerDateFieldNumber = 22;
  const std::string& controller_date() const;
  void set_controller_date(const std::string& value);
  void set_controller_date(std::string&& value);
  void set_controller_date(const char* value);
  void set_controller_date(const char* value, size_t size);
  std::string* mutable_controller_date();
  std::string* release_controller_date();
  void set_allocated_controller_date(std::string* controller_date);

  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 100;
  const ::Nrmk::IndyFramework::Response& response() const;
  ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* response);

  // uint32 num_joints = 1;
  void clear_num_joints();
  static const int kNumJointsFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_joints() const;
  void set_num_joints(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // float payload = 3;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  float payload() const;
  void set_payload(float value);

  // bool teleop_loaded = 30;
  void clear_teleop_loaded();
  static const int kTeleopLoadedFieldNumber = 30;
  bool teleop_loaded() const;
  void set_teleop_loaded(bool value);

  // bool calibrated = 31;
  void clear_calibrated();
  static const int kCalibratedFieldNumber = 31;
  bool calibrated() const;
  void set_calibrated(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.DeviceInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> core_board_fw_vers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robot_serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr io_board_fw_ver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endtool_board_fw_ver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_ver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_detail_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_date_;
  ::Nrmk::IndyFramework::Response* response_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_joints_;
  float payload_;
  bool teleop_loaded_;
  bool calibrated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class BrakeControlStyle :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.BrakeControlStyle) */ {
 public:
  BrakeControlStyle();
  virtual ~BrakeControlStyle();

  BrakeControlStyle(const BrakeControlStyle& from);
  BrakeControlStyle(BrakeControlStyle&& from) noexcept
    : BrakeControlStyle() {
    *this = ::std::move(from);
  }

  inline BrakeControlStyle& operator=(const BrakeControlStyle& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrakeControlStyle& operator=(BrakeControlStyle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BrakeControlStyle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BrakeControlStyle* internal_default_instance() {
    return reinterpret_cast<const BrakeControlStyle*>(
               &_BrakeControlStyle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(BrakeControlStyle* other);
  friend void swap(BrakeControlStyle& a, BrakeControlStyle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BrakeControlStyle* New() const final {
    return CreateMaybeMessage<BrakeControlStyle>(nullptr);
  }

  BrakeControlStyle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BrakeControlStyle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BrakeControlStyle& from);
  void MergeFrom(const BrakeControlStyle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrakeControlStyle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.BrakeControlStyle";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BrakeControlStyle_ControlStyle ControlStyle;
  static constexpr ControlStyle UNAVAILABLE =
    BrakeControlStyle_ControlStyle_UNAVAILABLE;
  static constexpr ControlStyle CONCURRENT =
    BrakeControlStyle_ControlStyle_CONCURRENT;
  static constexpr ControlStyle INDIVIDUAL =
    BrakeControlStyle_ControlStyle_INDIVIDUAL;
  static inline bool ControlStyle_IsValid(int value) {
    return BrakeControlStyle_ControlStyle_IsValid(value);
  }
  static constexpr ControlStyle ControlStyle_MIN =
    BrakeControlStyle_ControlStyle_ControlStyle_MIN;
  static constexpr ControlStyle ControlStyle_MAX =
    BrakeControlStyle_ControlStyle_ControlStyle_MAX;
  static constexpr int ControlStyle_ARRAYSIZE =
    BrakeControlStyle_ControlStyle_ControlStyle_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ControlStyle_descriptor() {
    return BrakeControlStyle_ControlStyle_descriptor();
  }
  template<typename T>
  static inline const std::string& ControlStyle_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ControlStyle>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ControlStyle_Name.");
    return BrakeControlStyle_ControlStyle_Name(enum_t_value);
  }
  static inline bool ControlStyle_Parse(const std::string& name,
      ControlStyle* value) {
    return BrakeControlStyle_ControlStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 100;
  const ::Nrmk::IndyFramework::Response& response() const;
  ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* response);

  // .Nrmk.IndyFramework.BrakeControlStyle.ControlStyle style = 1;
  void clear_style();
  static const int kStyleFieldNumber = 1;
  ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle style() const;
  void set_style(::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.BrakeControlStyle)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Nrmk::IndyFramework::Response* response_;
  int style_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class GetEL5001Data :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GetEL5001Data) */ {
 public:
  GetEL5001Data();
  virtual ~GetEL5001Data();

  GetEL5001Data(const GetEL5001Data& from);
  GetEL5001Data(GetEL5001Data&& from) noexcept
    : GetEL5001Data() {
    *this = ::std::move(from);
  }

  inline GetEL5001Data& operator=(const GetEL5001Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEL5001Data& operator=(GetEL5001Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetEL5001Data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEL5001Data* internal_default_instance() {
    return reinterpret_cast<const GetEL5001Data*>(
               &_GetEL5001Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GetEL5001Data* other);
  friend void swap(GetEL5001Data& a, GetEL5001Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEL5001Data* New() const final {
    return CreateMaybeMessage<GetEL5001Data>(nullptr);
  }

  GetEL5001Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEL5001Data>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetEL5001Data& from);
  void MergeFrom(const GetEL5001Data& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEL5001Data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.GetEL5001Data";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 100;
  const ::Nrmk::IndyFramework::Response& response() const;
  ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* response);

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 delta = 3;
  void clear_delta();
  static const int kDeltaFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 delta() const;
  void set_delta(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float average = 4;
  void clear_average();
  static const int kAverageFieldNumber = 4;
  float average() const;
  void set_average(float value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GetEL5001Data)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Nrmk::IndyFramework::Response* response_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  ::PROTOBUF_NAMESPACE_ID::int32 delta_;
  float average_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class GetEL5101Data :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GetEL5101Data) */ {
 public:
  GetEL5101Data();
  virtual ~GetEL5101Data();

  GetEL5101Data(const GetEL5101Data& from);
  GetEL5101Data(GetEL5101Data&& from) noexcept
    : GetEL5101Data() {
    *this = ::std::move(from);
  }

  inline GetEL5101Data& operator=(const GetEL5101Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEL5101Data& operator=(GetEL5101Data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetEL5101Data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEL5101Data* internal_default_instance() {
    return reinterpret_cast<const GetEL5101Data*>(
               &_GetEL5101Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GetEL5101Data* other);
  friend void swap(GetEL5101Data& a, GetEL5101Data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetEL5101Data* New() const final {
    return CreateMaybeMessage<GetEL5101Data>(nullptr);
  }

  GetEL5101Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEL5101Data>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetEL5101Data& from);
  void MergeFrom(const GetEL5101Data& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEL5101Data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.GetEL5101Data";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 100;
  const ::Nrmk::IndyFramework::Response& response() const;
  ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* response);

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 latch = 3;
  void clear_latch();
  static const int kLatchFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 latch() const;
  void set_latch(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 delta = 4;
  void clear_delta();
  static const int kDeltaFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 delta() const;
  void set_delta(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float average = 5;
  void clear_average();
  static const int kAverageFieldNumber = 5;
  float average() const;
  void set_average(float value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GetEL5101Data)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Nrmk::IndyFramework::Response* response_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  ::PROTOBUF_NAMESPACE_ID::int32 latch_;
  ::PROTOBUF_NAMESPACE_ID::int32 delta_;
  float average_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class FTSensorData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.FTSensorData) */ {
 public:
  FTSensorData();
  virtual ~FTSensorData();

  FTSensorData(const FTSensorData& from);
  FTSensorData(FTSensorData&& from) noexcept
    : FTSensorData() {
    *this = ::std::move(from);
  }

  inline FTSensorData& operator=(const FTSensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FTSensorData& operator=(FTSensorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FTSensorData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FTSensorData* internal_default_instance() {
    return reinterpret_cast<const FTSensorData*>(
               &_FTSensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(FTSensorData* other);
  friend void swap(FTSensorData& a, FTSensorData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FTSensorData* New() const final {
    return CreateMaybeMessage<FTSensorData>(nullptr);
  }

  FTSensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FTSensorData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FTSensorData& from);
  void MergeFrom(const FTSensorData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FTSensorData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.FTSensorData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 100;
  const ::Nrmk::IndyFramework::Response& response() const;
  ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* response);

  // float ft_Fx = 1;
  void clear_ft_fx();
  static const int kFtFxFieldNumber = 1;
  float ft_fx() const;
  void set_ft_fx(float value);

  // float ft_Fy = 2;
  void clear_ft_fy();
  static const int kFtFyFieldNumber = 2;
  float ft_fy() const;
  void set_ft_fy(float value);

  // float ft_Fz = 3;
  void clear_ft_fz();
  static const int kFtFzFieldNumber = 3;
  float ft_fz() const;
  void set_ft_fz(float value);

  // float ft_Tx = 4;
  void clear_ft_tx();
  static const int kFtTxFieldNumber = 4;
  float ft_tx() const;
  void set_ft_tx(float value);

  // float ft_Ty = 5;
  void clear_ft_ty();
  static const int kFtTyFieldNumber = 5;
  float ft_ty() const;
  void set_ft_ty(float value);

  // float ft_Tz = 6;
  void clear_ft_tz();
  static const int kFtTzFieldNumber = 6;
  float ft_tz() const;
  void set_ft_tz(float value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.FTSensorData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Nrmk::IndyFramework::Response* response_;
  float ft_fx_;
  float ft_fy_;
  float ft_fz_;
  float ft_tx_;
  float ft_ty_;
  float ft_tz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class GetLoadFactorsRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.GetLoadFactorsRes) */ {
 public:
  GetLoadFactorsRes();
  virtual ~GetLoadFactorsRes();

  GetLoadFactorsRes(const GetLoadFactorsRes& from);
  GetLoadFactorsRes(GetLoadFactorsRes&& from) noexcept
    : GetLoadFactorsRes() {
    *this = ::std::move(from);
  }

  inline GetLoadFactorsRes& operator=(const GetLoadFactorsRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLoadFactorsRes& operator=(GetLoadFactorsRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetLoadFactorsRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLoadFactorsRes* internal_default_instance() {
    return reinterpret_cast<const GetLoadFactorsRes*>(
               &_GetLoadFactorsRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetLoadFactorsRes* other);
  friend void swap(GetLoadFactorsRes& a, GetLoadFactorsRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLoadFactorsRes* New() const final {
    return CreateMaybeMessage<GetLoadFactorsRes>(nullptr);
  }

  GetLoadFactorsRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLoadFactorsRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetLoadFactorsRes& from);
  void MergeFrom(const GetLoadFactorsRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLoadFactorsRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.GetLoadFactorsRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 percents = 1;
  int percents_size() const;
  void clear_percents();
  static const int kPercentsFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 percents(int index) const;
  void set_percents(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_percents(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      percents() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_percents();

  // repeated float torques = 2;
  int torques_size() const;
  void clear_torques();
  static const int kTorquesFieldNumber = 2;
  float torques(int index) const;
  void set_torques(int index, float value);
  void add_torques(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      torques() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_torques();

  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 100;
  const ::Nrmk::IndyFramework::Response& response() const;
  ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* response);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.GetLoadFactorsRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > percents_;
  mutable std::atomic<int> _percents_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > torques_;
  mutable std::atomic<int> _torques_cached_byte_size_;
  ::Nrmk::IndyFramework::Response* response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class SetAutoModeReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SetAutoModeReq) */ {
 public:
  SetAutoModeReq();
  virtual ~SetAutoModeReq();

  SetAutoModeReq(const SetAutoModeReq& from);
  SetAutoModeReq(SetAutoModeReq&& from) noexcept
    : SetAutoModeReq() {
    *this = ::std::move(from);
  }

  inline SetAutoModeReq& operator=(const SetAutoModeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAutoModeReq& operator=(SetAutoModeReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetAutoModeReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetAutoModeReq* internal_default_instance() {
    return reinterpret_cast<const SetAutoModeReq*>(
               &_SetAutoModeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(SetAutoModeReq* other);
  friend void swap(SetAutoModeReq& a, SetAutoModeReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetAutoModeReq* New() const final {
    return CreateMaybeMessage<SetAutoModeReq>(nullptr);
  }

  SetAutoModeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetAutoModeReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetAutoModeReq& from);
  void MergeFrom(const SetAutoModeReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAutoModeReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.SetAutoModeReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool on = 1;
  void clear_on();
  static const int kOnFieldNumber = 1;
  bool on() const;
  void set_on(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SetAutoModeReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class SetAutoModeRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SetAutoModeRes) */ {
 public:
  SetAutoModeRes();
  virtual ~SetAutoModeRes();

  SetAutoModeRes(const SetAutoModeRes& from);
  SetAutoModeRes(SetAutoModeRes&& from) noexcept
    : SetAutoModeRes() {
    *this = ::std::move(from);
  }

  inline SetAutoModeRes& operator=(const SetAutoModeRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAutoModeRes& operator=(SetAutoModeRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetAutoModeRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetAutoModeRes* internal_default_instance() {
    return reinterpret_cast<const SetAutoModeRes*>(
               &_SetAutoModeRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(SetAutoModeRes* other);
  friend void swap(SetAutoModeRes& a, SetAutoModeRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetAutoModeRes* New() const final {
    return CreateMaybeMessage<SetAutoModeRes>(nullptr);
  }

  SetAutoModeRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetAutoModeRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetAutoModeRes& from);
  void MergeFrom(const SetAutoModeRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAutoModeRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.SetAutoModeRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 100;
  void clear_msg();
  static const int kMsgFieldNumber = 100;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SetAutoModeRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class CheckAutoModeRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.CheckAutoModeRes) */ {
 public:
  CheckAutoModeRes();
  virtual ~CheckAutoModeRes();

  CheckAutoModeRes(const CheckAutoModeRes& from);
  CheckAutoModeRes(CheckAutoModeRes&& from) noexcept
    : CheckAutoModeRes() {
    *this = ::std::move(from);
  }

  inline CheckAutoModeRes& operator=(const CheckAutoModeRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckAutoModeRes& operator=(CheckAutoModeRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckAutoModeRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckAutoModeRes* internal_default_instance() {
    return reinterpret_cast<const CheckAutoModeRes*>(
               &_CheckAutoModeRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CheckAutoModeRes* other);
  friend void swap(CheckAutoModeRes& a, CheckAutoModeRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckAutoModeRes* New() const final {
    return CreateMaybeMessage<CheckAutoModeRes>(nullptr);
  }

  CheckAutoModeRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckAutoModeRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckAutoModeRes& from);
  void MergeFrom(const CheckAutoModeRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckAutoModeRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.CheckAutoModeRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 100;
  void clear_msg();
  static const int kMsgFieldNumber = 100;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // bool on = 1;
  void clear_on();
  static const int kOnFieldNumber = 1;
  bool on() const;
  void set_on(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.CheckAutoModeRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class CheckReducedModeRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.CheckReducedModeRes) */ {
 public:
  CheckReducedModeRes();
  virtual ~CheckReducedModeRes();

  CheckReducedModeRes(const CheckReducedModeRes& from);
  CheckReducedModeRes(CheckReducedModeRes&& from) noexcept
    : CheckReducedModeRes() {
    *this = ::std::move(from);
  }

  inline CheckReducedModeRes& operator=(const CheckReducedModeRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckReducedModeRes& operator=(CheckReducedModeRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckReducedModeRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckReducedModeRes* internal_default_instance() {
    return reinterpret_cast<const CheckReducedModeRes*>(
               &_CheckReducedModeRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CheckReducedModeRes* other);
  friend void swap(CheckReducedModeRes& a, CheckReducedModeRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckReducedModeRes* New() const final {
    return CreateMaybeMessage<CheckReducedModeRes>(nullptr);
  }

  CheckReducedModeRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckReducedModeRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckReducedModeRes& from);
  void MergeFrom(const CheckReducedModeRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckReducedModeRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.CheckReducedModeRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 100;
  void clear_msg();
  static const int kMsgFieldNumber = 100;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // bool on = 1;
  void clear_on();
  static const int kOnFieldNumber = 1;
  bool on() const;
  void set_on(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.CheckReducedModeRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  bool on_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class SafetyFunctionState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SafetyFunctionState) */ {
 public:
  SafetyFunctionState();
  virtual ~SafetyFunctionState();

  SafetyFunctionState(const SafetyFunctionState& from);
  SafetyFunctionState(SafetyFunctionState&& from) noexcept
    : SafetyFunctionState() {
    *this = ::std::move(from);
  }

  inline SafetyFunctionState& operator=(const SafetyFunctionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafetyFunctionState& operator=(SafetyFunctionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SafetyFunctionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyFunctionState* internal_default_instance() {
    return reinterpret_cast<const SafetyFunctionState*>(
               &_SafetyFunctionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(SafetyFunctionState* other);
  friend void swap(SafetyFunctionState& a, SafetyFunctionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyFunctionState* New() const final {
    return CreateMaybeMessage<SafetyFunctionState>(nullptr);
  }

  SafetyFunctionState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SafetyFunctionState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SafetyFunctionState& from);
  void MergeFrom(const SafetyFunctionState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafetyFunctionState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.SafetyFunctionState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Nrmk.IndyFramework.Response response = 100;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 100;
  const ::Nrmk::IndyFramework::Response& response() const;
  ::Nrmk::IndyFramework::Response* release_response();
  ::Nrmk::IndyFramework::Response* mutable_response();
  void set_allocated_response(::Nrmk::IndyFramework::Response* response);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SafetyFunctionState)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Nrmk::IndyFramework::Response* response_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class SafetyControlData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SafetyControlData) */ {
 public:
  SafetyControlData();
  virtual ~SafetyControlData();

  SafetyControlData(const SafetyControlData& from);
  SafetyControlData(SafetyControlData&& from) noexcept
    : SafetyControlData() {
    *this = ::std::move(from);
  }

  inline SafetyControlData& operator=(const SafetyControlData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafetyControlData& operator=(SafetyControlData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SafetyControlData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SafetyControlData* internal_default_instance() {
    return reinterpret_cast<const SafetyControlData*>(
               &_SafetyControlData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(SafetyControlData* other);
  friend void swap(SafetyControlData& a, SafetyControlData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SafetyControlData* New() const final {
    return CreateMaybeMessage<SafetyControlData>(nullptr);
  }

  SafetyControlData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SafetyControlData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SafetyControlData& from);
  void MergeFrom(const SafetyControlData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafetyControlData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.SafetyControlData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Nrmk.IndyFramework.SafetyFunctionState safety_state = 5;
  bool has_safety_state() const;
  void clear_safety_state();
  static const int kSafetyStateFieldNumber = 5;
  const ::Nrmk::IndyFramework::SafetyFunctionState& safety_state() const;
  ::Nrmk::IndyFramework::SafetyFunctionState* release_safety_state();
  ::Nrmk::IndyFramework::SafetyFunctionState* mutable_safety_state();
  void set_allocated_safety_state(::Nrmk::IndyFramework::SafetyFunctionState* safety_state);

  // bool auto_mode = 1;
  void clear_auto_mode();
  static const int kAutoModeFieldNumber = 1;
  bool auto_mode() const;
  void set_auto_mode(bool value);

  // bool reduced_mode = 2;
  void clear_reduced_mode();
  static const int kReducedModeFieldNumber = 2;
  bool reduced_mode() const;
  void set_reduced_mode(bool value);

  // bool enabler_pressed = 3;
  void clear_enabler_pressed();
  static const int kEnablerPressedFieldNumber = 3;
  bool enabler_pressed() const;
  void set_enabler_pressed(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SafetyControlData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Nrmk::IndyFramework::SafetyFunctionState* safety_state_;
  bool auto_mode_;
  bool reduced_mode_;
  bool enabler_pressed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class SanderCommand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.SanderCommand) */ {
 public:
  SanderCommand();
  virtual ~SanderCommand();

  SanderCommand(const SanderCommand& from);
  SanderCommand(SanderCommand&& from) noexcept
    : SanderCommand() {
    *this = ::std::move(from);
  }

  inline SanderCommand& operator=(const SanderCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SanderCommand& operator=(SanderCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SanderCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SanderCommand* internal_default_instance() {
    return reinterpret_cast<const SanderCommand*>(
               &_SanderCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(SanderCommand* other);
  friend void swap(SanderCommand& a, SanderCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SanderCommand* New() const final {
    return CreateMaybeMessage<SanderCommand>(nullptr);
  }

  SanderCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SanderCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SanderCommand& from);
  void MergeFrom(const SanderCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SanderCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.SanderCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SanderCommand_SanderType SanderType;
  static constexpr SanderType SANDER_ONROBOT =
    SanderCommand_SanderType_SANDER_ONROBOT;
  static inline bool SanderType_IsValid(int value) {
    return SanderCommand_SanderType_IsValid(value);
  }
  static constexpr SanderType SanderType_MIN =
    SanderCommand_SanderType_SanderType_MIN;
  static constexpr SanderType SanderType_MAX =
    SanderCommand_SanderType_SanderType_MAX;
  static constexpr int SanderType_ARRAYSIZE =
    SanderCommand_SanderType_SanderType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SanderType_descriptor() {
    return SanderCommand_SanderType_descriptor();
  }
  template<typename T>
  static inline const std::string& SanderType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SanderType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SanderType_Name.");
    return SanderCommand_SanderType_Name(enum_t_value);
  }
  static inline bool SanderType_Parse(const std::string& name,
      SanderType* value) {
    return SanderCommand_SanderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string ip = 2;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);

  // .Nrmk.IndyFramework.SanderCommand.SanderType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Nrmk::IndyFramework::SanderCommand_SanderType type() const;
  void set_type(::Nrmk::IndyFramework::SanderCommand_SanderType value);

  // float speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // bool state = 10;
  void clear_state();
  static const int kStateFieldNumber = 10;
  bool state() const;
  void set_state(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.SanderCommand)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  int type_;
  float speed_;
  bool state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Encoder :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Encoder) */ {
 public:
  Encoder();
  virtual ~Encoder();

  Encoder(const Encoder& from);
  Encoder(Encoder&& from) noexcept
    : Encoder() {
    *this = ::std::move(from);
  }

  inline Encoder& operator=(const Encoder& from) {
    CopyFrom(from);
    return *this;
  }
  inline Encoder& operator=(Encoder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Encoder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Encoder* internal_default_instance() {
    return reinterpret_cast<const Encoder*>(
               &_Encoder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(Encoder* other);
  friend void swap(Encoder& a, Encoder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Encoder* New() const final {
    return CreateMaybeMessage<Encoder>(nullptr);
  }

  Encoder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Encoder>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Encoder& from);
  void MergeFrom(const Encoder& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Encoder* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.Encoder";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Encoder_EncoderType EncoderType;
  static constexpr EncoderType CONSTANT =
    Encoder_EncoderType_CONSTANT;
  static constexpr EncoderType QUADRATURE =
    Encoder_EncoderType_QUADRATURE;
  static constexpr EncoderType RISING =
    Encoder_EncoderType_RISING;
  static constexpr EncoderType FALLING =
    Encoder_EncoderType_FALLING;
  static constexpr EncoderType MODBUS =
    Encoder_EncoderType_MODBUS;
  static inline bool EncoderType_IsValid(int value) {
    return Encoder_EncoderType_IsValid(value);
  }
  static constexpr EncoderType EncoderType_MIN =
    Encoder_EncoderType_EncoderType_MIN;
  static constexpr EncoderType EncoderType_MAX =
    Encoder_EncoderType_EncoderType_MAX;
  static constexpr int EncoderType_ARRAYSIZE =
    Encoder_EncoderType_EncoderType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EncoderType_descriptor() {
    return Encoder_EncoderType_descriptor();
  }
  template<typename T>
  static inline const std::string& EncoderType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EncoderType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EncoderType_Name.");
    return Encoder_EncoderType_Name(enum_t_value);
  }
  static inline bool EncoderType_Parse(const std::string& name,
      EncoderType* value) {
    return Encoder_EncoderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int64 channel1 = 2;
  void clear_channel1();
  static const int kChannel1FieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int64 channel1() const;
  void set_channel1(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 channel2 = 3;
  void clear_channel2();
  static const int kChannel2FieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int64 channel2() const;
  void set_channel2(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .Nrmk.IndyFramework.Encoder.EncoderType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Nrmk::IndyFramework::Encoder_EncoderType type() const;
  void set_type(::Nrmk::IndyFramework::Encoder_EncoderType value);

  // float mm_per_tick = 5;
  void clear_mm_per_tick();
  static const int kMmPerTickFieldNumber = 5;
  float mm_per_tick() const;
  void set_mm_per_tick(float value);

  // int64 sample_num = 4;
  void clear_sample_num();
  static const int kSampleNumFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int64 sample_num() const;
  void set_sample_num(::PROTOBUF_NAMESPACE_ID::int64 value);

  // float vel_const_mmps = 6;
  void clear_vel_const_mmps();
  static const int kVelConstMmpsFieldNumber = 6;
  float vel_const_mmps() const;
  void set_vel_const_mmps(float value);

  // bool reversed = 7;
  void clear_reversed();
  static const int kReversedFieldNumber = 7;
  bool reversed() const;
  void set_reversed(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Encoder)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 channel1_;
  ::PROTOBUF_NAMESPACE_ID::int64 channel2_;
  int type_;
  float mm_per_tick_;
  ::PROTOBUF_NAMESPACE_ID::int64 sample_num_;
  float vel_const_mmps_;
  bool reversed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Trigger :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Trigger) */ {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);
  Trigger(Trigger&& from) noexcept
    : Trigger() {
    *this = ::std::move(from);
  }

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trigger& operator=(Trigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trigger* internal_default_instance() {
    return reinterpret_cast<const Trigger*>(
               &_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(Trigger* other);
  friend void swap(Trigger& a, Trigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trigger* New() const final {
    return CreateMaybeMessage<Trigger>(nullptr);
  }

  Trigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trigger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trigger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.Trigger";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Trigger_TriggerType TriggerType;
  static constexpr TriggerType DIGITAL =
    Trigger_TriggerType_DIGITAL;
  static constexpr TriggerType MODBUS =
    Trigger_TriggerType_MODBUS;
  static inline bool TriggerType_IsValid(int value) {
    return Trigger_TriggerType_IsValid(value);
  }
  static constexpr TriggerType TriggerType_MIN =
    Trigger_TriggerType_TriggerType_MIN;
  static constexpr TriggerType TriggerType_MAX =
    Trigger_TriggerType_TriggerType_MAX;
  static constexpr int TriggerType_ARRAYSIZE =
    Trigger_TriggerType_TriggerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TriggerType_descriptor() {
    return Trigger_TriggerType_descriptor();
  }
  template<typename T>
  static inline const std::string& TriggerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TriggerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TriggerType_Name.");
    return Trigger_TriggerType_Name(enum_t_value);
  }
  static inline bool TriggerType_Parse(const std::string& name,
      TriggerType* value) {
    return Trigger_TriggerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int64 channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int64 channel() const;
  void set_channel(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .Nrmk.IndyFramework.Trigger.TriggerType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Nrmk::IndyFramework::Trigger_TriggerType type() const;
  void set_type(::Nrmk::IndyFramework::Trigger_TriggerType value);

  // bool detect_rise = 3;
  void clear_detect_rise();
  static const int kDetectRiseFieldNumber = 3;
  bool detect_rise() const;
  void set_detect_rise(bool value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Trigger)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 channel_;
  int type_;
  bool detect_rise_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Conveyor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.Conveyor) */ {
 public:
  Conveyor();
  virtual ~Conveyor();

  Conveyor(const Conveyor& from);
  Conveyor(Conveyor&& from) noexcept
    : Conveyor() {
    *this = ::std::move(from);
  }

  inline Conveyor& operator=(const Conveyor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Conveyor& operator=(Conveyor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Conveyor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Conveyor* internal_default_instance() {
    return reinterpret_cast<const Conveyor*>(
               &_Conveyor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Conveyor* other);
  friend void swap(Conveyor& a, Conveyor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Conveyor* New() const final {
    return CreateMaybeMessage<Conveyor>(nullptr);
  }

  Conveyor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Conveyor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Conveyor& from);
  void MergeFrom(const Conveyor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Conveyor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.Conveyor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .Nrmk.IndyFramework.Encoder encoder = 2;
  bool has_encoder() const;
  void clear_encoder();
  static const int kEncoderFieldNumber = 2;
  const ::Nrmk::IndyFramework::Encoder& encoder() const;
  ::Nrmk::IndyFramework::Encoder* release_encoder();
  ::Nrmk::IndyFramework::Encoder* mutable_encoder();
  void set_allocated_encoder(::Nrmk::IndyFramework::Encoder* encoder);

  // .Nrmk.IndyFramework.Trigger trigger = 3;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 3;
  const ::Nrmk::IndyFramework::Trigger& trigger() const;
  ::Nrmk::IndyFramework::Trigger* release_trigger();
  ::Nrmk::IndyFramework::Trigger* mutable_trigger();
  void set_allocated_trigger(::Nrmk::IndyFramework::Trigger* trigger);

  // .Nrmk.IndyFramework.Vector direction = 6;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 6;
  const ::Nrmk::IndyFramework::Vector& direction() const;
  ::Nrmk::IndyFramework::Vector* release_direction();
  ::Nrmk::IndyFramework::Vector* mutable_direction();
  void set_allocated_direction(::Nrmk::IndyFramework::Vector* direction);

  // .Nrmk.IndyFramework.PosePair starting_pose = 10;
  bool has_starting_pose() const;
  void clear_starting_pose();
  static const int kStartingPoseFieldNumber = 10;
  const ::Nrmk::IndyFramework::PosePair& starting_pose() const;
  ::Nrmk::IndyFramework::PosePair* release_starting_pose();
  ::Nrmk::IndyFramework::PosePair* mutable_starting_pose();
  void set_allocated_starting_pose(::Nrmk::IndyFramework::PosePair* starting_pose);

  // .Nrmk.IndyFramework.PosePair terminal_pose = 11;
  bool has_terminal_pose() const;
  void clear_terminal_pose();
  static const int kTerminalPoseFieldNumber = 11;
  const ::Nrmk::IndyFramework::PosePair& terminal_pose() const;
  ::Nrmk::IndyFramework::PosePair* release_terminal_pose();
  ::Nrmk::IndyFramework::PosePair* mutable_terminal_pose();
  void set_allocated_terminal_pose(::Nrmk::IndyFramework::PosePair* terminal_pose);

  // float offset_dist = 4;
  void clear_offset_dist();
  static const int kOffsetDistFieldNumber = 4;
  float offset_dist() const;
  void set_offset_dist(float value);

  // float working_dist = 5;
  void clear_working_dist();
  static const int kWorkingDistFieldNumber = 5;
  float working_dist() const;
  void set_working_dist(float value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.Conveyor)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Nrmk::IndyFramework::Encoder* encoder_;
  ::Nrmk::IndyFramework::Trigger* trigger_;
  ::Nrmk::IndyFramework::Vector* direction_;
  ::Nrmk::IndyFramework::PosePair* starting_pose_;
  ::Nrmk::IndyFramework::PosePair* terminal_pose_;
  float offset_dist_;
  float working_dist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class ConveyorState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Nrmk.IndyFramework.ConveyorState) */ {
 public:
  ConveyorState();
  virtual ~ConveyorState();

  ConveyorState(const ConveyorState& from);
  ConveyorState(ConveyorState&& from) noexcept
    : ConveyorState() {
    *this = ::std::move(from);
  }

  inline ConveyorState& operator=(const ConveyorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConveyorState& operator=(ConveyorState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConveyorState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConveyorState* internal_default_instance() {
    return reinterpret_cast<const ConveyorState*>(
               &_ConveyorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ConveyorState* other);
  friend void swap(ConveyorState& a, ConveyorState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConveyorState* New() const final {
    return CreateMaybeMessage<ConveyorState>(nullptr);
  }

  ConveyorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConveyorState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConveyorState& from);
  void MergeFrom(const ConveyorState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConveyorState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Nrmk.IndyFramework.ConveyorState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_device_5fmsgs_2eproto);
    return ::descriptor_table_device_5fmsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float velocity = 1;
  void clear_velocity();
  static const int kVelocityFieldNumber = 1;
  float velocity() const;
  void set_velocity(float value);

  // float triggered = 2;
  void clear_triggered();
  static const int kTriggeredFieldNumber = 2;
  float triggered() const;
  void set_triggered(float value);

  // @@protoc_insertion_point(class_scope:Nrmk.IndyFramework.ConveyorState)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float velocity_;
  float triggered_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_device_5fmsgs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Motor

// uint32 index = 1;
inline void Motor::clear_index() {
  index_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Motor::index() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Motor.index)
  return index_;
}
inline void Motor::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Motor.index)
}

// bool enable = 2;
inline void Motor::clear_enable() {
  enable_ = false;
}
inline bool Motor::enable() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Motor.enable)
  return enable_;
}
inline void Motor::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Motor.enable)
}

// -------------------------------------------------------------------

// Servo

// uint32 index = 1;
inline void Servo::clear_index() {
  index_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Servo::index() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Servo.index)
  return index_;
}
inline void Servo::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Servo.index)
}

// bool enable = 2;
inline void Servo::clear_enable() {
  enable_ = false;
}
inline bool Servo::enable() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Servo.enable)
  return enable_;
}
inline void Servo::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Servo.enable)
}

// -------------------------------------------------------------------

// GripperData

// .Nrmk.IndyFramework.GripperType gripper_type = 1;
inline void GripperData::clear_gripper_type() {
  gripper_type_ = 0;
}
inline ::Nrmk::IndyFramework::GripperType GripperData::gripper_type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperData.gripper_type)
  return static_cast< ::Nrmk::IndyFramework::GripperType >(gripper_type_);
}
inline void GripperData::set_gripper_type(::Nrmk::IndyFramework::GripperType value) {
  
  gripper_type_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperData.gripper_type)
}

// int32 gripper_position = 2;
inline void GripperData::clear_gripper_position() {
  gripper_position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GripperData::gripper_position() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperData.gripper_position)
  return gripper_position_;
}
inline void GripperData::set_gripper_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gripper_position_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperData.gripper_position)
}

// int32 gripper_state = 3;
inline void GripperData::clear_gripper_state() {
  gripper_state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GripperData::gripper_state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperData.gripper_state)
  return gripper_state_;
}
inline void GripperData::set_gripper_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gripper_state_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperData.gripper_state)
}

// -------------------------------------------------------------------

// GripperCommand

// .Nrmk.IndyFramework.GripperCommand.GripperCommandType gripper_command = 1;
inline void GripperCommand::clear_gripper_command() {
  gripper_command_ = 0;
}
inline ::Nrmk::IndyFramework::GripperCommand_GripperCommandType GripperCommand::gripper_command() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperCommand.gripper_command)
  return static_cast< ::Nrmk::IndyFramework::GripperCommand_GripperCommandType >(gripper_command_);
}
inline void GripperCommand::set_gripper_command(::Nrmk::IndyFramework::GripperCommand_GripperCommandType value) {
  
  gripper_command_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperCommand.gripper_command)
}

// .Nrmk.IndyFramework.GripperType gripper_type = 2;
inline void GripperCommand::clear_gripper_type() {
  gripper_type_ = 0;
}
inline ::Nrmk::IndyFramework::GripperType GripperCommand::gripper_type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperCommand.gripper_type)
  return static_cast< ::Nrmk::IndyFramework::GripperType >(gripper_type_);
}
inline void GripperCommand::set_gripper_type(::Nrmk::IndyFramework::GripperType value) {
  
  gripper_type_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperCommand.gripper_type)
}

// repeated int32 gripper_pvt_data = 3;
inline int GripperCommand::gripper_pvt_data_size() const {
  return gripper_pvt_data_.size();
}
inline void GripperCommand::clear_gripper_pvt_data() {
  gripper_pvt_data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GripperCommand::gripper_pvt_data(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
  return gripper_pvt_data_.Get(index);
}
inline void GripperCommand::set_gripper_pvt_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  gripper_pvt_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
}
inline void GripperCommand::add_gripper_pvt_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  gripper_pvt_data_.Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
GripperCommand::gripper_pvt_data() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
  return gripper_pvt_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
GripperCommand::mutable_gripper_pvt_data() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.GripperCommand.gripper_pvt_data)
  return &gripper_pvt_data_;
}

// -------------------------------------------------------------------

// DigitalSignal

// uint32 address = 1;
inline void DigitalSignal::clear_address() {
  address_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigitalSignal::address() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DigitalSignal.address)
  return address_;
}
inline void DigitalSignal::set_address(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DigitalSignal.address)
}

// .Nrmk.IndyFramework.DigitalState state = 2;
inline void DigitalSignal::clear_state() {
  state_ = 0;
}
inline ::Nrmk::IndyFramework::DigitalState DigitalSignal::state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DigitalSignal.state)
  return static_cast< ::Nrmk::IndyFramework::DigitalState >(state_);
}
inline void DigitalSignal::set_state(::Nrmk::IndyFramework::DigitalState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DigitalSignal.state)
}

// -------------------------------------------------------------------

// EndLedDim

// uint32 led_dim = 1;
inline void EndLedDim::clear_led_dim() {
  led_dim_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EndLedDim::led_dim() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndLedDim.led_dim)
  return led_dim_;
}
inline void EndLedDim::set_led_dim(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  led_dim_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.EndLedDim.led_dim)
}

// -------------------------------------------------------------------

// EndtoolSignal

// string port = 1;
inline void EndtoolSignal::clear_port() {
  port_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EndtoolSignal::port() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndtoolSignal.port)
  return port_.GetNoArena();
}
inline void EndtoolSignal::set_port(const std::string& value) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.EndtoolSignal.port)
}
inline void EndtoolSignal::set_port(std::string&& value) {
  
  port_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.EndtoolSignal.port)
}
inline void EndtoolSignal::set_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.EndtoolSignal.port)
}
inline void EndtoolSignal::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.EndtoolSignal.port)
}
inline std::string* EndtoolSignal::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.EndtoolSignal.port)
  return port_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EndtoolSignal::release_port() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.EndtoolSignal.port)
  
  return port_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EndtoolSignal::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.EndtoolSignal.port)
}

// repeated .Nrmk.IndyFramework.EndtoolState states = 2;
inline int EndtoolSignal::states_size() const {
  return states_.size();
}
inline void EndtoolSignal::clear_states() {
  states_.Clear();
}
inline ::Nrmk::IndyFramework::EndtoolState EndtoolSignal::states(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndtoolSignal.states)
  return static_cast< ::Nrmk::IndyFramework::EndtoolState >(states_.Get(index));
}
inline void EndtoolSignal::set_states(int index, ::Nrmk::IndyFramework::EndtoolState value) {
  states_.Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.EndtoolSignal.states)
}
inline void EndtoolSignal::add_states(::Nrmk::IndyFramework::EndtoolState value) {
  states_.Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.EndtoolSignal.states)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
EndtoolSignal::states() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.EndtoolSignal.states)
  return states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
EndtoolSignal::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.EndtoolSignal.states)
  return &states_;
}

// -------------------------------------------------------------------

// AnalogSignal

// uint32 address = 1;
inline void AnalogSignal::clear_address() {
  address_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnalogSignal::address() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AnalogSignal.address)
  return address_;
}
inline void AnalogSignal::set_address(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AnalogSignal.address)
}

// int32 voltage = 2;
inline void AnalogSignal::clear_voltage() {
  voltage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalogSignal::voltage() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AnalogSignal.voltage)
  return voltage_;
}
inline void AnalogSignal::set_voltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.AnalogSignal.voltage)
}

// -------------------------------------------------------------------

// MotorList

// repeated .Nrmk.IndyFramework.Motor motors = 1;
inline int MotorList::motors_size() const {
  return motors_.size();
}
inline void MotorList::clear_motors() {
  motors_.Clear();
}
inline ::Nrmk::IndyFramework::Motor* MotorList::mutable_motors(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.MotorList.motors)
  return motors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >*
MotorList::mutable_motors() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.MotorList.motors)
  return &motors_;
}
inline const ::Nrmk::IndyFramework::Motor& MotorList::motors(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.MotorList.motors)
  return motors_.Get(index);
}
inline ::Nrmk::IndyFramework::Motor* MotorList::add_motors() {
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.MotorList.motors)
  return motors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::Motor >&
MotorList::motors() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.MotorList.motors)
  return motors_;
}

// -------------------------------------------------------------------

// DigitalList

// repeated .Nrmk.IndyFramework.DigitalSignal signals = 1;
inline int DigitalList::signals_size() const {
  return signals_.size();
}
inline void DigitalList::clear_signals() {
  signals_.Clear();
}
inline ::Nrmk::IndyFramework::DigitalSignal* DigitalList::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DigitalList.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >*
DigitalList::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.DigitalList.signals)
  return &signals_;
}
inline const ::Nrmk::IndyFramework::DigitalSignal& DigitalList::signals(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DigitalList.signals)
  return signals_.Get(index);
}
inline ::Nrmk::IndyFramework::DigitalSignal* DigitalList::add_signals() {
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.DigitalList.signals)
  return signals_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::DigitalSignal >&
DigitalList::signals() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.DigitalList.signals)
  return signals_;
}

// -------------------------------------------------------------------

// EndtoolSignalList

// repeated .Nrmk.IndyFramework.EndtoolSignal signals = 1;
inline int EndtoolSignalList::signals_size() const {
  return signals_.size();
}
inline void EndtoolSignalList::clear_signals() {
  signals_.Clear();
}
inline ::Nrmk::IndyFramework::EndtoolSignal* EndtoolSignalList::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >*
EndtoolSignalList::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return &signals_;
}
inline const ::Nrmk::IndyFramework::EndtoolSignal& EndtoolSignalList::signals(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return signals_.Get(index);
}
inline ::Nrmk::IndyFramework::EndtoolSignal* EndtoolSignalList::add_signals() {
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return signals_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::EndtoolSignal >&
EndtoolSignalList::signals() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.EndtoolSignalList.signals)
  return signals_;
}

// -------------------------------------------------------------------

// AnalogList

// repeated .Nrmk.IndyFramework.AnalogSignal signals = 1;
inline int AnalogList::signals_size() const {
  return signals_.size();
}
inline void AnalogList::clear_signals() {
  signals_.Clear();
}
inline ::Nrmk::IndyFramework::AnalogSignal* AnalogList::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.AnalogList.signals)
  return signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >*
AnalogList::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.AnalogList.signals)
  return &signals_;
}
inline const ::Nrmk::IndyFramework::AnalogSignal& AnalogList::signals(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.AnalogList.signals)
  return signals_.Get(index);
}
inline ::Nrmk::IndyFramework::AnalogSignal* AnalogList::add_signals() {
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.AnalogList.signals)
  return signals_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Nrmk::IndyFramework::AnalogSignal >&
AnalogList::signals() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.AnalogList.signals)
  return signals_;
}

// -------------------------------------------------------------------

// DeviceInfo

// uint32 num_joints = 1;
inline void DeviceInfo::clear_num_joints() {
  num_joints_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceInfo::num_joints() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.num_joints)
  return num_joints_;
}
inline void DeviceInfo::set_num_joints(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  num_joints_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.num_joints)
}

// string robot_serial = 2;
inline void DeviceInfo::clear_robot_serial() {
  robot_serial_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::robot_serial() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.robot_serial)
  return robot_serial_.GetNoArena();
}
inline void DeviceInfo::set_robot_serial(const std::string& value) {
  
  robot_serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.robot_serial)
}
inline void DeviceInfo::set_robot_serial(std::string&& value) {
  
  robot_serial_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.DeviceInfo.robot_serial)
}
inline void DeviceInfo::set_robot_serial(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  robot_serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.robot_serial)
}
inline void DeviceInfo::set_robot_serial(const char* value, size_t size) {
  
  robot_serial_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.robot_serial)
}
inline std::string* DeviceInfo::mutable_robot_serial() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.robot_serial)
  return robot_serial_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_robot_serial() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.robot_serial)
  
  return robot_serial_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_robot_serial(std::string* robot_serial) {
  if (robot_serial != nullptr) {
    
  } else {
    
  }
  robot_serial_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), robot_serial);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.robot_serial)
}

// float payload = 3;
inline void DeviceInfo::clear_payload() {
  payload_ = 0;
}
inline float DeviceInfo::payload() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.payload)
  return payload_;
}
inline void DeviceInfo::set_payload(float value) {
  
  payload_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.payload)
}

// string io_board_fw_ver = 10;
inline void DeviceInfo::clear_io_board_fw_ver() {
  io_board_fw_ver_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::io_board_fw_ver() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
  return io_board_fw_ver_.GetNoArena();
}
inline void DeviceInfo::set_io_board_fw_ver(const std::string& value) {
  
  io_board_fw_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
}
inline void DeviceInfo::set_io_board_fw_ver(std::string&& value) {
  
  io_board_fw_ver_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
}
inline void DeviceInfo::set_io_board_fw_ver(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  io_board_fw_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
}
inline void DeviceInfo::set_io_board_fw_ver(const char* value, size_t size) {
  
  io_board_fw_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
}
inline std::string* DeviceInfo::mutable_io_board_fw_ver() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
  return io_board_fw_ver_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_io_board_fw_ver() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
  
  return io_board_fw_ver_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_io_board_fw_ver(std::string* io_board_fw_ver) {
  if (io_board_fw_ver != nullptr) {
    
  } else {
    
  }
  io_board_fw_ver_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), io_board_fw_ver);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.io_board_fw_ver)
}

// repeated string core_board_fw_vers = 11;
inline int DeviceInfo::core_board_fw_vers_size() const {
  return core_board_fw_vers_.size();
}
inline void DeviceInfo::clear_core_board_fw_vers() {
  core_board_fw_vers_.Clear();
}
inline const std::string& DeviceInfo::core_board_fw_vers(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return core_board_fw_vers_.Get(index);
}
inline std::string* DeviceInfo::mutable_core_board_fw_vers(int index) {
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return core_board_fw_vers_.Mutable(index);
}
inline void DeviceInfo::set_core_board_fw_vers(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  core_board_fw_vers_.Mutable(index)->assign(value);
}
inline void DeviceInfo::set_core_board_fw_vers(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  core_board_fw_vers_.Mutable(index)->assign(std::move(value));
}
inline void DeviceInfo::set_core_board_fw_vers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  core_board_fw_vers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::set_core_board_fw_vers(int index, const char* value, size_t size) {
  core_board_fw_vers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline std::string* DeviceInfo::add_core_board_fw_vers() {
  // @@protoc_insertion_point(field_add_mutable:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return core_board_fw_vers_.Add();
}
inline void DeviceInfo::add_core_board_fw_vers(const std::string& value) {
  core_board_fw_vers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(std::string&& value) {
  core_board_fw_vers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  core_board_fw_vers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline void DeviceInfo::add_core_board_fw_vers(const char* value, size_t size) {
  core_board_fw_vers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceInfo::core_board_fw_vers() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return core_board_fw_vers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceInfo::mutable_core_board_fw_vers() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.DeviceInfo.core_board_fw_vers)
  return &core_board_fw_vers_;
}

// string endtool_board_fw_ver = 12;
inline void DeviceInfo::clear_endtool_board_fw_ver() {
  endtool_board_fw_ver_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::endtool_board_fw_ver() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
  return endtool_board_fw_ver_.GetNoArena();
}
inline void DeviceInfo::set_endtool_board_fw_ver(const std::string& value) {
  
  endtool_board_fw_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
}
inline void DeviceInfo::set_endtool_board_fw_ver(std::string&& value) {
  
  endtool_board_fw_ver_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
}
inline void DeviceInfo::set_endtool_board_fw_ver(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  endtool_board_fw_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
}
inline void DeviceInfo::set_endtool_board_fw_ver(const char* value, size_t size) {
  
  endtool_board_fw_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
}
inline std::string* DeviceInfo::mutable_endtool_board_fw_ver() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
  return endtool_board_fw_ver_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_endtool_board_fw_ver() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
  
  return endtool_board_fw_ver_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_endtool_board_fw_ver(std::string* endtool_board_fw_ver) {
  if (endtool_board_fw_ver != nullptr) {
    
  } else {
    
  }
  endtool_board_fw_ver_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endtool_board_fw_ver);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.endtool_board_fw_ver)
}

// string controller_ver = 20;
inline void DeviceInfo::clear_controller_ver() {
  controller_ver_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::controller_ver() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.controller_ver)
  return controller_ver_.GetNoArena();
}
inline void DeviceInfo::set_controller_ver(const std::string& value) {
  
  controller_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.controller_ver)
}
inline void DeviceInfo::set_controller_ver(std::string&& value) {
  
  controller_ver_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.DeviceInfo.controller_ver)
}
inline void DeviceInfo::set_controller_ver(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  controller_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.controller_ver)
}
inline void DeviceInfo::set_controller_ver(const char* value, size_t size) {
  
  controller_ver_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.controller_ver)
}
inline std::string* DeviceInfo::mutable_controller_ver() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.controller_ver)
  return controller_ver_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_controller_ver() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.controller_ver)
  
  return controller_ver_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_controller_ver(std::string* controller_ver) {
  if (controller_ver != nullptr) {
    
  } else {
    
  }
  controller_ver_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_ver);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.controller_ver)
}

// string controller_detail = 21;
inline void DeviceInfo::clear_controller_detail() {
  controller_detail_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::controller_detail() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.controller_detail)
  return controller_detail_.GetNoArena();
}
inline void DeviceInfo::set_controller_detail(const std::string& value) {
  
  controller_detail_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.controller_detail)
}
inline void DeviceInfo::set_controller_detail(std::string&& value) {
  
  controller_detail_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.DeviceInfo.controller_detail)
}
inline void DeviceInfo::set_controller_detail(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  controller_detail_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.controller_detail)
}
inline void DeviceInfo::set_controller_detail(const char* value, size_t size) {
  
  controller_detail_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.controller_detail)
}
inline std::string* DeviceInfo::mutable_controller_detail() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.controller_detail)
  return controller_detail_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_controller_detail() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.controller_detail)
  
  return controller_detail_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_controller_detail(std::string* controller_detail) {
  if (controller_detail != nullptr) {
    
  } else {
    
  }
  controller_detail_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_detail);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.controller_detail)
}

// string controller_date = 22;
inline void DeviceInfo::clear_controller_date() {
  controller_date_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeviceInfo::controller_date() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.controller_date)
  return controller_date_.GetNoArena();
}
inline void DeviceInfo::set_controller_date(const std::string& value) {
  
  controller_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.controller_date)
}
inline void DeviceInfo::set_controller_date(std::string&& value) {
  
  controller_date_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.DeviceInfo.controller_date)
}
inline void DeviceInfo::set_controller_date(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  controller_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.DeviceInfo.controller_date)
}
inline void DeviceInfo::set_controller_date(const char* value, size_t size) {
  
  controller_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.DeviceInfo.controller_date)
}
inline std::string* DeviceInfo::mutable_controller_date() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.controller_date)
  return controller_date_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeviceInfo::release_controller_date() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.controller_date)
  
  return controller_date_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_controller_date(std::string* controller_date) {
  if (controller_date != nullptr) {
    
  } else {
    
  }
  controller_date_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_date);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.controller_date)
}

// bool teleop_loaded = 30;
inline void DeviceInfo::clear_teleop_loaded() {
  teleop_loaded_ = false;
}
inline bool DeviceInfo::teleop_loaded() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.teleop_loaded)
  return teleop_loaded_;
}
inline void DeviceInfo::set_teleop_loaded(bool value) {
  
  teleop_loaded_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.teleop_loaded)
}

// bool calibrated = 31;
inline void DeviceInfo::clear_calibrated() {
  calibrated_ = false;
}
inline bool DeviceInfo::calibrated() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.calibrated)
  return calibrated_;
}
inline void DeviceInfo::set_calibrated(bool value) {
  
  calibrated_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.DeviceInfo.calibrated)
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool DeviceInfo::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Response& DeviceInfo::response() const {
  const ::Nrmk::IndyFramework::Response* p = response_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.DeviceInfo.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Response*>(
      &::Nrmk::IndyFramework::_Response_default_instance_);
}
inline ::Nrmk::IndyFramework::Response* DeviceInfo::release_response() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.DeviceInfo.response)
  
  ::Nrmk::IndyFramework::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* DeviceInfo::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.DeviceInfo.response)
  return response_;
}
inline void DeviceInfo::set_allocated_response(::Nrmk::IndyFramework::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.DeviceInfo.response)
}

// -------------------------------------------------------------------

// BrakeControlStyle

// .Nrmk.IndyFramework.BrakeControlStyle.ControlStyle style = 1;
inline void BrakeControlStyle::clear_style() {
  style_ = 0;
}
inline ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle BrakeControlStyle::style() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.BrakeControlStyle.style)
  return static_cast< ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle >(style_);
}
inline void BrakeControlStyle::set_style(::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle value) {
  
  style_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.BrakeControlStyle.style)
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool BrakeControlStyle::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Response& BrakeControlStyle::response() const {
  const ::Nrmk::IndyFramework::Response* p = response_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.BrakeControlStyle.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Response*>(
      &::Nrmk::IndyFramework::_Response_default_instance_);
}
inline ::Nrmk::IndyFramework::Response* BrakeControlStyle::release_response() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.BrakeControlStyle.response)
  
  ::Nrmk::IndyFramework::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* BrakeControlStyle::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.BrakeControlStyle.response)
  return response_;
}
inline void BrakeControlStyle::set_allocated_response(::Nrmk::IndyFramework::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.BrakeControlStyle.response)
}

// -------------------------------------------------------------------

// GetEL5001Data

// int32 status = 1;
inline void GetEL5001Data::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEL5001Data::status() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.status)
  return status_;
}
inline void GetEL5001Data::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.status)
}

// int32 value = 2;
inline void GetEL5001Data::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEL5001Data::value() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.value)
  return value_;
}
inline void GetEL5001Data::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.value)
}

// int32 delta = 3;
inline void GetEL5001Data::clear_delta() {
  delta_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEL5001Data::delta() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.delta)
  return delta_;
}
inline void GetEL5001Data::set_delta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  delta_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.delta)
}

// float average = 4;
inline void GetEL5001Data::clear_average() {
  average_ = 0;
}
inline float GetEL5001Data::average() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.average)
  return average_;
}
inline void GetEL5001Data::set_average(float value) {
  
  average_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5001Data.average)
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool GetEL5001Data::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Response& GetEL5001Data::response() const {
  const ::Nrmk::IndyFramework::Response* p = response_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5001Data.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Response*>(
      &::Nrmk::IndyFramework::_Response_default_instance_);
}
inline ::Nrmk::IndyFramework::Response* GetEL5001Data::release_response() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.GetEL5001Data.response)
  
  ::Nrmk::IndyFramework::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* GetEL5001Data::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.GetEL5001Data.response)
  return response_;
}
inline void GetEL5001Data::set_allocated_response(::Nrmk::IndyFramework::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.GetEL5001Data.response)
}

// -------------------------------------------------------------------

// GetEL5101Data

// int32 status = 1;
inline void GetEL5101Data::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEL5101Data::status() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.status)
  return status_;
}
inline void GetEL5101Data::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.status)
}

// int32 value = 2;
inline void GetEL5101Data::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEL5101Data::value() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.value)
  return value_;
}
inline void GetEL5101Data::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.value)
}

// int32 latch = 3;
inline void GetEL5101Data::clear_latch() {
  latch_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEL5101Data::latch() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.latch)
  return latch_;
}
inline void GetEL5101Data::set_latch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  latch_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.latch)
}

// int32 delta = 4;
inline void GetEL5101Data::clear_delta() {
  delta_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEL5101Data::delta() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.delta)
  return delta_;
}
inline void GetEL5101Data::set_delta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  delta_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.delta)
}

// float average = 5;
inline void GetEL5101Data::clear_average() {
  average_ = 0;
}
inline float GetEL5101Data::average() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.average)
  return average_;
}
inline void GetEL5101Data::set_average(float value) {
  
  average_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetEL5101Data.average)
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool GetEL5101Data::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Response& GetEL5101Data::response() const {
  const ::Nrmk::IndyFramework::Response* p = response_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetEL5101Data.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Response*>(
      &::Nrmk::IndyFramework::_Response_default_instance_);
}
inline ::Nrmk::IndyFramework::Response* GetEL5101Data::release_response() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.GetEL5101Data.response)
  
  ::Nrmk::IndyFramework::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* GetEL5101Data::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.GetEL5101Data.response)
  return response_;
}
inline void GetEL5101Data::set_allocated_response(::Nrmk::IndyFramework::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.GetEL5101Data.response)
}

// -------------------------------------------------------------------

// FTSensorData

// float ft_Fx = 1;
inline void FTSensorData::clear_ft_fx() {
  ft_fx_ = 0;
}
inline float FTSensorData::ft_fx() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Fx)
  return ft_fx_;
}
inline void FTSensorData::set_ft_fx(float value) {
  
  ft_fx_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Fx)
}

// float ft_Fy = 2;
inline void FTSensorData::clear_ft_fy() {
  ft_fy_ = 0;
}
inline float FTSensorData::ft_fy() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Fy)
  return ft_fy_;
}
inline void FTSensorData::set_ft_fy(float value) {
  
  ft_fy_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Fy)
}

// float ft_Fz = 3;
inline void FTSensorData::clear_ft_fz() {
  ft_fz_ = 0;
}
inline float FTSensorData::ft_fz() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Fz)
  return ft_fz_;
}
inline void FTSensorData::set_ft_fz(float value) {
  
  ft_fz_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Fz)
}

// float ft_Tx = 4;
inline void FTSensorData::clear_ft_tx() {
  ft_tx_ = 0;
}
inline float FTSensorData::ft_tx() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Tx)
  return ft_tx_;
}
inline void FTSensorData::set_ft_tx(float value) {
  
  ft_tx_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Tx)
}

// float ft_Ty = 5;
inline void FTSensorData::clear_ft_ty() {
  ft_ty_ = 0;
}
inline float FTSensorData::ft_ty() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Ty)
  return ft_ty_;
}
inline void FTSensorData::set_ft_ty(float value) {
  
  ft_ty_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Ty)
}

// float ft_Tz = 6;
inline void FTSensorData::clear_ft_tz() {
  ft_tz_ = 0;
}
inline float FTSensorData::ft_tz() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.ft_Tz)
  return ft_tz_;
}
inline void FTSensorData::set_ft_tz(float value) {
  
  ft_tz_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.FTSensorData.ft_Tz)
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool FTSensorData::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Response& FTSensorData::response() const {
  const ::Nrmk::IndyFramework::Response* p = response_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.FTSensorData.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Response*>(
      &::Nrmk::IndyFramework::_Response_default_instance_);
}
inline ::Nrmk::IndyFramework::Response* FTSensorData::release_response() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.FTSensorData.response)
  
  ::Nrmk::IndyFramework::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* FTSensorData::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.FTSensorData.response)
  return response_;
}
inline void FTSensorData::set_allocated_response(::Nrmk::IndyFramework::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.FTSensorData.response)
}

// -------------------------------------------------------------------

// GetLoadFactorsRes

// repeated int32 percents = 1;
inline int GetLoadFactorsRes::percents_size() const {
  return percents_.size();
}
inline void GetLoadFactorsRes::clear_percents() {
  percents_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetLoadFactorsRes::percents(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
  return percents_.Get(index);
}
inline void GetLoadFactorsRes::set_percents(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  percents_.Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
}
inline void GetLoadFactorsRes::add_percents(::PROTOBUF_NAMESPACE_ID::int32 value) {
  percents_.Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
GetLoadFactorsRes::percents() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
  return percents_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
GetLoadFactorsRes::mutable_percents() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.GetLoadFactorsRes.percents)
  return &percents_;
}

// repeated float torques = 2;
inline int GetLoadFactorsRes::torques_size() const {
  return torques_.size();
}
inline void GetLoadFactorsRes::clear_torques() {
  torques_.Clear();
}
inline float GetLoadFactorsRes::torques(int index) const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
  return torques_.Get(index);
}
inline void GetLoadFactorsRes::set_torques(int index, float value) {
  torques_.Set(index, value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
}
inline void GetLoadFactorsRes::add_torques(float value) {
  torques_.Add(value);
  // @@protoc_insertion_point(field_add:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
GetLoadFactorsRes::torques() const {
  // @@protoc_insertion_point(field_list:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
  return torques_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
GetLoadFactorsRes::mutable_torques() {
  // @@protoc_insertion_point(field_mutable_list:Nrmk.IndyFramework.GetLoadFactorsRes.torques)
  return &torques_;
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool GetLoadFactorsRes::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Response& GetLoadFactorsRes::response() const {
  const ::Nrmk::IndyFramework::Response* p = response_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.GetLoadFactorsRes.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Response*>(
      &::Nrmk::IndyFramework::_Response_default_instance_);
}
inline ::Nrmk::IndyFramework::Response* GetLoadFactorsRes::release_response() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.GetLoadFactorsRes.response)
  
  ::Nrmk::IndyFramework::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* GetLoadFactorsRes::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.GetLoadFactorsRes.response)
  return response_;
}
inline void GetLoadFactorsRes::set_allocated_response(::Nrmk::IndyFramework::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.GetLoadFactorsRes.response)
}

// -------------------------------------------------------------------

// SetAutoModeReq

// bool on = 1;
inline void SetAutoModeReq::clear_on() {
  on_ = false;
}
inline bool SetAutoModeReq::on() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SetAutoModeReq.on)
  return on_;
}
inline void SetAutoModeReq::set_on(bool value) {
  
  on_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SetAutoModeReq.on)
}

// -------------------------------------------------------------------

// SetAutoModeRes

// string msg = 100;
inline void SetAutoModeRes::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SetAutoModeRes::msg() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SetAutoModeRes.msg)
  return msg_.GetNoArena();
}
inline void SetAutoModeRes::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SetAutoModeRes.msg)
}
inline void SetAutoModeRes::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.SetAutoModeRes.msg)
}
inline void SetAutoModeRes::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.SetAutoModeRes.msg)
}
inline void SetAutoModeRes::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.SetAutoModeRes.msg)
}
inline std::string* SetAutoModeRes::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SetAutoModeRes.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SetAutoModeRes::release_msg() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SetAutoModeRes.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SetAutoModeRes::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SetAutoModeRes.msg)
}

// -------------------------------------------------------------------

// CheckAutoModeRes

// bool on = 1;
inline void CheckAutoModeRes::clear_on() {
  on_ = false;
}
inline bool CheckAutoModeRes::on() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckAutoModeRes.on)
  return on_;
}
inline void CheckAutoModeRes::set_on(bool value) {
  
  on_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckAutoModeRes.on)
}

// string msg = 100;
inline void CheckAutoModeRes::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CheckAutoModeRes::msg() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckAutoModeRes.msg)
  return msg_.GetNoArena();
}
inline void CheckAutoModeRes::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckAutoModeRes.msg)
}
inline void CheckAutoModeRes::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.CheckAutoModeRes.msg)
}
inline void CheckAutoModeRes::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.CheckAutoModeRes.msg)
}
inline void CheckAutoModeRes::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.CheckAutoModeRes.msg)
}
inline std::string* CheckAutoModeRes::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.CheckAutoModeRes.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckAutoModeRes::release_msg() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.CheckAutoModeRes.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckAutoModeRes::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.CheckAutoModeRes.msg)
}

// -------------------------------------------------------------------

// CheckReducedModeRes

// bool on = 1;
inline void CheckReducedModeRes::clear_on() {
  on_ = false;
}
inline bool CheckReducedModeRes::on() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckReducedModeRes.on)
  return on_;
}
inline void CheckReducedModeRes::set_on(bool value) {
  
  on_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckReducedModeRes.on)
}

// string msg = 100;
inline void CheckReducedModeRes::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CheckReducedModeRes::msg() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.CheckReducedModeRes.msg)
  return msg_.GetNoArena();
}
inline void CheckReducedModeRes::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.CheckReducedModeRes.msg)
}
inline void CheckReducedModeRes::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.CheckReducedModeRes.msg)
}
inline void CheckReducedModeRes::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.CheckReducedModeRes.msg)
}
inline void CheckReducedModeRes::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.CheckReducedModeRes.msg)
}
inline std::string* CheckReducedModeRes::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.CheckReducedModeRes.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckReducedModeRes::release_msg() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.CheckReducedModeRes.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckReducedModeRes::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.CheckReducedModeRes.msg)
}

// -------------------------------------------------------------------

// SafetyFunctionState

// uint32 id = 1;
inline void SafetyFunctionState::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SafetyFunctionState::id() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyFunctionState.id)
  return id_;
}
inline void SafetyFunctionState::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyFunctionState.id)
}

// uint32 state = 2;
inline void SafetyFunctionState::clear_state() {
  state_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SafetyFunctionState::state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyFunctionState.state)
  return state_;
}
inline void SafetyFunctionState::set_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyFunctionState.state)
}

// .Nrmk.IndyFramework.Response response = 100;
inline bool SafetyFunctionState::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Response& SafetyFunctionState::response() const {
  const ::Nrmk::IndyFramework::Response* p = response_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyFunctionState.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Response*>(
      &::Nrmk::IndyFramework::_Response_default_instance_);
}
inline ::Nrmk::IndyFramework::Response* SafetyFunctionState::release_response() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SafetyFunctionState.response)
  
  ::Nrmk::IndyFramework::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Response* SafetyFunctionState::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SafetyFunctionState.response)
  return response_;
}
inline void SafetyFunctionState::set_allocated_response(::Nrmk::IndyFramework::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SafetyFunctionState.response)
}

// -------------------------------------------------------------------

// SafetyControlData

// bool auto_mode = 1;
inline void SafetyControlData::clear_auto_mode() {
  auto_mode_ = false;
}
inline bool SafetyControlData::auto_mode() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.auto_mode)
  return auto_mode_;
}
inline void SafetyControlData::set_auto_mode(bool value) {
  
  auto_mode_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyControlData.auto_mode)
}

// bool reduced_mode = 2;
inline void SafetyControlData::clear_reduced_mode() {
  reduced_mode_ = false;
}
inline bool SafetyControlData::reduced_mode() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.reduced_mode)
  return reduced_mode_;
}
inline void SafetyControlData::set_reduced_mode(bool value) {
  
  reduced_mode_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyControlData.reduced_mode)
}

// bool enabler_pressed = 3;
inline void SafetyControlData::clear_enabler_pressed() {
  enabler_pressed_ = false;
}
inline bool SafetyControlData::enabler_pressed() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.enabler_pressed)
  return enabler_pressed_;
}
inline void SafetyControlData::set_enabler_pressed(bool value) {
  
  enabler_pressed_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SafetyControlData.enabler_pressed)
}

// .Nrmk.IndyFramework.SafetyFunctionState safety_state = 5;
inline bool SafetyControlData::has_safety_state() const {
  return this != internal_default_instance() && safety_state_ != nullptr;
}
inline void SafetyControlData::clear_safety_state() {
  if (GetArenaNoVirtual() == nullptr && safety_state_ != nullptr) {
    delete safety_state_;
  }
  safety_state_ = nullptr;
}
inline const ::Nrmk::IndyFramework::SafetyFunctionState& SafetyControlData::safety_state() const {
  const ::Nrmk::IndyFramework::SafetyFunctionState* p = safety_state_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SafetyControlData.safety_state)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::SafetyFunctionState*>(
      &::Nrmk::IndyFramework::_SafetyFunctionState_default_instance_);
}
inline ::Nrmk::IndyFramework::SafetyFunctionState* SafetyControlData::release_safety_state() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SafetyControlData.safety_state)
  
  ::Nrmk::IndyFramework::SafetyFunctionState* temp = safety_state_;
  safety_state_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::SafetyFunctionState* SafetyControlData::mutable_safety_state() {
  
  if (safety_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::SafetyFunctionState>(GetArenaNoVirtual());
    safety_state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SafetyControlData.safety_state)
  return safety_state_;
}
inline void SafetyControlData::set_allocated_safety_state(::Nrmk::IndyFramework::SafetyFunctionState* safety_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete safety_state_;
  }
  if (safety_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      safety_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, safety_state, submessage_arena);
    }
    
  } else {
    
  }
  safety_state_ = safety_state;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SafetyControlData.safety_state)
}

// -------------------------------------------------------------------

// SanderCommand

// .Nrmk.IndyFramework.SanderCommand.SanderType type = 1;
inline void SanderCommand::clear_type() {
  type_ = 0;
}
inline ::Nrmk::IndyFramework::SanderCommand_SanderType SanderCommand::type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.type)
  return static_cast< ::Nrmk::IndyFramework::SanderCommand_SanderType >(type_);
}
inline void SanderCommand::set_type(::Nrmk::IndyFramework::SanderCommand_SanderType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.type)
}

// string ip = 2;
inline void SanderCommand::clear_ip() {
  ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SanderCommand::ip() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.ip)
  return ip_.GetNoArena();
}
inline void SanderCommand::set_ip(const std::string& value) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.ip)
}
inline void SanderCommand::set_ip(std::string&& value) {
  
  ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.SanderCommand.ip)
}
inline void SanderCommand::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.SanderCommand.ip)
}
inline void SanderCommand::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.SanderCommand.ip)
}
inline std::string* SanderCommand::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.SanderCommand.ip)
  return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SanderCommand::release_ip() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.SanderCommand.ip)
  
  return ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SanderCommand::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.SanderCommand.ip)
}

// float speed = 3;
inline void SanderCommand::clear_speed() {
  speed_ = 0;
}
inline float SanderCommand::speed() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.speed)
  return speed_;
}
inline void SanderCommand::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.speed)
}

// bool state = 10;
inline void SanderCommand::clear_state() {
  state_ = false;
}
inline bool SanderCommand::state() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.SanderCommand.state)
  return state_;
}
inline void SanderCommand::set_state(bool value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.SanderCommand.state)
}

// -------------------------------------------------------------------

// Encoder

// .Nrmk.IndyFramework.Encoder.EncoderType type = 1;
inline void Encoder::clear_type() {
  type_ = 0;
}
inline ::Nrmk::IndyFramework::Encoder_EncoderType Encoder::type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.type)
  return static_cast< ::Nrmk::IndyFramework::Encoder_EncoderType >(type_);
}
inline void Encoder::set_type(::Nrmk::IndyFramework::Encoder_EncoderType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.type)
}

// int64 channel1 = 2;
inline void Encoder::clear_channel1() {
  channel1_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Encoder::channel1() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.channel1)
  return channel1_;
}
inline void Encoder::set_channel1(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  channel1_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.channel1)
}

// int64 channel2 = 3;
inline void Encoder::clear_channel2() {
  channel2_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Encoder::channel2() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.channel2)
  return channel2_;
}
inline void Encoder::set_channel2(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  channel2_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.channel2)
}

// int64 sample_num = 4;
inline void Encoder::clear_sample_num() {
  sample_num_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Encoder::sample_num() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.sample_num)
  return sample_num_;
}
inline void Encoder::set_sample_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sample_num_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.sample_num)
}

// float mm_per_tick = 5;
inline void Encoder::clear_mm_per_tick() {
  mm_per_tick_ = 0;
}
inline float Encoder::mm_per_tick() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.mm_per_tick)
  return mm_per_tick_;
}
inline void Encoder::set_mm_per_tick(float value) {
  
  mm_per_tick_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.mm_per_tick)
}

// float vel_const_mmps = 6;
inline void Encoder::clear_vel_const_mmps() {
  vel_const_mmps_ = 0;
}
inline float Encoder::vel_const_mmps() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.vel_const_mmps)
  return vel_const_mmps_;
}
inline void Encoder::set_vel_const_mmps(float value) {
  
  vel_const_mmps_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.vel_const_mmps)
}

// bool reversed = 7;
inline void Encoder::clear_reversed() {
  reversed_ = false;
}
inline bool Encoder::reversed() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Encoder.reversed)
  return reversed_;
}
inline void Encoder::set_reversed(bool value) {
  
  reversed_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Encoder.reversed)
}

// -------------------------------------------------------------------

// Trigger

// .Nrmk.IndyFramework.Trigger.TriggerType type = 1;
inline void Trigger::clear_type() {
  type_ = 0;
}
inline ::Nrmk::IndyFramework::Trigger_TriggerType Trigger::type() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Trigger.type)
  return static_cast< ::Nrmk::IndyFramework::Trigger_TriggerType >(type_);
}
inline void Trigger::set_type(::Nrmk::IndyFramework::Trigger_TriggerType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Trigger.type)
}

// int64 channel = 2;
inline void Trigger::clear_channel() {
  channel_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Trigger::channel() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Trigger.channel)
  return channel_;
}
inline void Trigger::set_channel(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Trigger.channel)
}

// bool detect_rise = 3;
inline void Trigger::clear_detect_rise() {
  detect_rise_ = false;
}
inline bool Trigger::detect_rise() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Trigger.detect_rise)
  return detect_rise_;
}
inline void Trigger::set_detect_rise(bool value) {
  
  detect_rise_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Trigger.detect_rise)
}

// -------------------------------------------------------------------

// Conveyor

// string name = 1;
inline void Conveyor::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Conveyor::name() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.name)
  return name_.GetNoArena();
}
inline void Conveyor::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Conveyor.name)
}
inline void Conveyor::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Nrmk.IndyFramework.Conveyor.name)
}
inline void Conveyor::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Nrmk.IndyFramework.Conveyor.name)
}
inline void Conveyor::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Nrmk.IndyFramework.Conveyor.name)
}
inline std::string* Conveyor::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Conveyor::release_name() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Conveyor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.name)
}

// .Nrmk.IndyFramework.Encoder encoder = 2;
inline bool Conveyor::has_encoder() const {
  return this != internal_default_instance() && encoder_ != nullptr;
}
inline void Conveyor::clear_encoder() {
  if (GetArenaNoVirtual() == nullptr && encoder_ != nullptr) {
    delete encoder_;
  }
  encoder_ = nullptr;
}
inline const ::Nrmk::IndyFramework::Encoder& Conveyor::encoder() const {
  const ::Nrmk::IndyFramework::Encoder* p = encoder_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.encoder)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Encoder*>(
      &::Nrmk::IndyFramework::_Encoder_default_instance_);
}
inline ::Nrmk::IndyFramework::Encoder* Conveyor::release_encoder() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.encoder)
  
  ::Nrmk::IndyFramework::Encoder* temp = encoder_;
  encoder_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Encoder* Conveyor::mutable_encoder() {
  
  if (encoder_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Encoder>(GetArenaNoVirtual());
    encoder_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.encoder)
  return encoder_;
}
inline void Conveyor::set_allocated_encoder(::Nrmk::IndyFramework::Encoder* encoder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete encoder_;
  }
  if (encoder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      encoder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encoder, submessage_arena);
    }
    
  } else {
    
  }
  encoder_ = encoder;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.encoder)
}

// .Nrmk.IndyFramework.Trigger trigger = 3;
inline bool Conveyor::has_trigger() const {
  return this != internal_default_instance() && trigger_ != nullptr;
}
inline void Conveyor::clear_trigger() {
  if (GetArenaNoVirtual() == nullptr && trigger_ != nullptr) {
    delete trigger_;
  }
  trigger_ = nullptr;
}
inline const ::Nrmk::IndyFramework::Trigger& Conveyor::trigger() const {
  const ::Nrmk::IndyFramework::Trigger* p = trigger_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.trigger)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Trigger*>(
      &::Nrmk::IndyFramework::_Trigger_default_instance_);
}
inline ::Nrmk::IndyFramework::Trigger* Conveyor::release_trigger() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.trigger)
  
  ::Nrmk::IndyFramework::Trigger* temp = trigger_;
  trigger_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Trigger* Conveyor::mutable_trigger() {
  
  if (trigger_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Trigger>(GetArenaNoVirtual());
    trigger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.trigger)
  return trigger_;
}
inline void Conveyor::set_allocated_trigger(::Nrmk::IndyFramework::Trigger* trigger) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trigger_;
  }
  if (trigger) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trigger, submessage_arena);
    }
    
  } else {
    
  }
  trigger_ = trigger;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.trigger)
}

// float offset_dist = 4;
inline void Conveyor::clear_offset_dist() {
  offset_dist_ = 0;
}
inline float Conveyor::offset_dist() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.offset_dist)
  return offset_dist_;
}
inline void Conveyor::set_offset_dist(float value) {
  
  offset_dist_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Conveyor.offset_dist)
}

// float working_dist = 5;
inline void Conveyor::clear_working_dist() {
  working_dist_ = 0;
}
inline float Conveyor::working_dist() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.working_dist)
  return working_dist_;
}
inline void Conveyor::set_working_dist(float value) {
  
  working_dist_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.Conveyor.working_dist)
}

// .Nrmk.IndyFramework.Vector direction = 6;
inline bool Conveyor::has_direction() const {
  return this != internal_default_instance() && direction_ != nullptr;
}
inline const ::Nrmk::IndyFramework::Vector& Conveyor::direction() const {
  const ::Nrmk::IndyFramework::Vector* p = direction_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.direction)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::Vector*>(
      &::Nrmk::IndyFramework::_Vector_default_instance_);
}
inline ::Nrmk::IndyFramework::Vector* Conveyor::release_direction() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.direction)
  
  ::Nrmk::IndyFramework::Vector* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::Vector* Conveyor::mutable_direction() {
  
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::Vector>(GetArenaNoVirtual());
    direction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.direction)
  return direction_;
}
inline void Conveyor::set_allocated_direction(::Nrmk::IndyFramework::Vector* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction_);
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.direction)
}

// .Nrmk.IndyFramework.PosePair starting_pose = 10;
inline bool Conveyor::has_starting_pose() const {
  return this != internal_default_instance() && starting_pose_ != nullptr;
}
inline const ::Nrmk::IndyFramework::PosePair& Conveyor::starting_pose() const {
  const ::Nrmk::IndyFramework::PosePair* p = starting_pose_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.starting_pose)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::PosePair*>(
      &::Nrmk::IndyFramework::_PosePair_default_instance_);
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::release_starting_pose() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.starting_pose)
  
  ::Nrmk::IndyFramework::PosePair* temp = starting_pose_;
  starting_pose_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::mutable_starting_pose() {
  
  if (starting_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::PosePair>(GetArenaNoVirtual());
    starting_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.starting_pose)
  return starting_pose_;
}
inline void Conveyor::set_allocated_starting_pose(::Nrmk::IndyFramework::PosePair* starting_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(starting_pose_);
  }
  if (starting_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starting_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starting_pose, submessage_arena);
    }
    
  } else {
    
  }
  starting_pose_ = starting_pose;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.starting_pose)
}

// .Nrmk.IndyFramework.PosePair terminal_pose = 11;
inline bool Conveyor::has_terminal_pose() const {
  return this != internal_default_instance() && terminal_pose_ != nullptr;
}
inline const ::Nrmk::IndyFramework::PosePair& Conveyor::terminal_pose() const {
  const ::Nrmk::IndyFramework::PosePair* p = terminal_pose_;
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.Conveyor.terminal_pose)
  return p != nullptr ? *p : *reinterpret_cast<const ::Nrmk::IndyFramework::PosePair*>(
      &::Nrmk::IndyFramework::_PosePair_default_instance_);
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::release_terminal_pose() {
  // @@protoc_insertion_point(field_release:Nrmk.IndyFramework.Conveyor.terminal_pose)
  
  ::Nrmk::IndyFramework::PosePair* temp = terminal_pose_;
  terminal_pose_ = nullptr;
  return temp;
}
inline ::Nrmk::IndyFramework::PosePair* Conveyor::mutable_terminal_pose() {
  
  if (terminal_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::Nrmk::IndyFramework::PosePair>(GetArenaNoVirtual());
    terminal_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Nrmk.IndyFramework.Conveyor.terminal_pose)
  return terminal_pose_;
}
inline void Conveyor::set_allocated_terminal_pose(::Nrmk::IndyFramework::PosePair* terminal_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(terminal_pose_);
  }
  if (terminal_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      terminal_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal_pose, submessage_arena);
    }
    
  } else {
    
  }
  terminal_pose_ = terminal_pose;
  // @@protoc_insertion_point(field_set_allocated:Nrmk.IndyFramework.Conveyor.terminal_pose)
}

// -------------------------------------------------------------------

// ConveyorState

// float velocity = 1;
inline void ConveyorState::clear_velocity() {
  velocity_ = 0;
}
inline float ConveyorState::velocity() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.ConveyorState.velocity)
  return velocity_;
}
inline void ConveyorState::set_velocity(float value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.ConveyorState.velocity)
}

// float triggered = 2;
inline void ConveyorState::clear_triggered() {
  triggered_ = 0;
}
inline float ConveyorState::triggered() const {
  // @@protoc_insertion_point(field_get:Nrmk.IndyFramework.ConveyorState.triggered)
  return triggered_;
}
inline void ConveyorState::set_triggered(float value) {
  
  triggered_ = value;
  // @@protoc_insertion_point(field_set:Nrmk.IndyFramework.ConveyorState.triggered)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace IndyFramework
}  // namespace Nrmk

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Nrmk::IndyFramework::GripperCommand_GripperCommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::GripperCommand_GripperCommandType>() {
  return ::Nrmk::IndyFramework::GripperCommand_GripperCommandType_descriptor();
}
template <> struct is_proto_enum< ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle>() {
  return ::Nrmk::IndyFramework::BrakeControlStyle_ControlStyle_descriptor();
}
template <> struct is_proto_enum< ::Nrmk::IndyFramework::SanderCommand_SanderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::SanderCommand_SanderType>() {
  return ::Nrmk::IndyFramework::SanderCommand_SanderType_descriptor();
}
template <> struct is_proto_enum< ::Nrmk::IndyFramework::Encoder_EncoderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::Encoder_EncoderType>() {
  return ::Nrmk::IndyFramework::Encoder_EncoderType_descriptor();
}
template <> struct is_proto_enum< ::Nrmk::IndyFramework::Trigger_TriggerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::Trigger_TriggerType>() {
  return ::Nrmk::IndyFramework::Trigger_TriggerType_descriptor();
}
template <> struct is_proto_enum< ::Nrmk::IndyFramework::GripperType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::GripperType>() {
  return ::Nrmk::IndyFramework::GripperType_descriptor();
}
template <> struct is_proto_enum< ::Nrmk::IndyFramework::DigitalState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::DigitalState>() {
  return ::Nrmk::IndyFramework::DigitalState_descriptor();
}
template <> struct is_proto_enum< ::Nrmk::IndyFramework::EndtoolState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Nrmk::IndyFramework::EndtoolState>() {
  return ::Nrmk::IndyFramework::EndtoolState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_device_5fmsgs_2eproto
