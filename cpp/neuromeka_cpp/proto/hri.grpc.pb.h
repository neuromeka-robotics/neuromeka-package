// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: hri.proto
// Original file comments:
// Created by Gwanwoo Kim on 2021-05-28.
// Copyright 2021 Neuromeka Inc. All rights reserved.
//
#ifndef GRPC_hri_2eproto__INCLUDED
#define GRPC_hri_2eproto__INCLUDED

#include "hri.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace IndyFramework {
namespace Protobuf {
namespace HRI {

class HRI final {
 public:
  static constexpr char const* service_full_name() {
    return "IndyFramework.Protobuf.HRI.HRI";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ContyInitRes>> AsyncContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ContyInitRes>>(AsyncContyInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ContyInitRes>> PrepareAsyncContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ContyInitRes>>(PrepareAsyncContyInitRaw(context, request, cq));
    }
    virtual ::grpc::Status RobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::RobotData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RobotData>> AsyncRobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RobotData>>(AsyncRobotUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RobotData>> PrepareAsyncRobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RobotData>>(PrepareAsyncRobotUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status ProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ProgramData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>> AsyncProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>>(AsyncProgramUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>> PrepareAsyncProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>>(PrepareAsyncProgramUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status ControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ControlData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ControlData>> AsyncControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ControlData>>(AsyncControlUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ControlData>> PrepareAsyncControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ControlData>>(PrepareAsyncControlUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status LinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::LinearData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::LinearData>> AsyncLinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::LinearData>>(AsyncLinearUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::LinearData>> PrepareAsyncLinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::LinearData>>(PrepareAsyncLinearUpdateRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Robot Control
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status JogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::IndyFramework::Protobuf::HRI::JogJointRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogJointRes>> AsyncJogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogJointRes>>(AsyncJogJointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogJointRes>> PrepareAsyncJogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogJointRes>>(PrepareAsyncJogJointRaw(context, request, cq));
    }
    virtual ::grpc::Status JogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogTaskRes>> AsyncJogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogTaskRes>>(AsyncJogTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogTaskRes>> PrepareAsyncJogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogTaskRes>>(PrepareAsyncJogTaskRaw(context, request, cq));
    }
    virtual ::grpc::Status JogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogAxisRes>> AsyncJogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogAxisRes>>(AsyncJogAxisRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogAxisRes>> PrepareAsyncJogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogAxisRes>>(PrepareAsyncJogAxisRaw(context, request, cq));
    }
    //  rpc HoldToMoveJ(HoldToMoveJReq) returns (HoldToMoveJRes) {}
    //  rpc HoldToMoveL(HoldToMoveLReq) returns (HoldToMoveLRes) {}
    //  rpc HoldToAxisJ(HoldToAxisJReq) returns (HoldToAxisJRes) {}
    //
    virtual ::grpc::Status HoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> AsyncHoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncHoldToMoveJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncHoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncHoldToMoveJRaw(context, request, cq));
    }
    virtual ::grpc::Status HoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> AsyncHoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncHoldToMoveLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncHoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncHoldToMoveLRaw(context, request, cq));
    }
    virtual ::grpc::Status HoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> AsyncHoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncHoldToAxisJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncHoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncHoldToAxisJRaw(context, request, cq));
    }
    virtual ::grpc::Status StopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopMotionRes>> AsyncStopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopMotionRes>>(AsyncStopMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopMotionRes>> PrepareAsyncStopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopMotionRes>>(PrepareAsyncStopMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>> AsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>>(AsyncSetRefFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>> PrepareAsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>>(PrepareAsyncSetRefFrameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>> AsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>>(AsyncSetRefFramePlanarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>> PrepareAsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>>(PrepareAsyncSetRefFramePlanarRaw(context, request, cq));
    }
    virtual ::grpc::Status SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>> AsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>>(AsyncSetToolFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>> PrepareAsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>>(PrepareAsyncSetToolFrameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>> AsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>>(AsyncSetSpeedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>> PrepareAsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>>(PrepareAsyncSetSpeedRatioRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>> AsyncSetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>>(AsyncSetSimulationModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>> PrepareAsyncSetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>>(PrepareAsyncSetSimulationModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> AsyncSetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(AsyncSetDirectTeachingModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> PrepareAsyncSetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(PrepareAsyncSetDirectTeachingModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCustomControlModeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::IntMode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IntMode>> AsyncGetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IntMode>>(AsyncGetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IntMode>> PrepareAsyncGetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IntMode>>(PrepareAsyncGetCustomControlModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>> AsyncSetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>>(AsyncSetSensorlessComplianceModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>> PrepareAsyncSetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>>(PrepareAsyncSetSensorlessComplianceModeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>> AsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>>(AsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>> PrepareAsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>>(PrepareAsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    virtual ::grpc::Status SetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetBrakeRes>> AsyncSetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetBrakeRes>>(AsyncSetBrakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetBrakeRes>> PrepareAsyncSetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetBrakeRes>>(PrepareAsyncSetBrakeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::IndyFramework::Protobuf::HRI::SetServoRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetServoRes>> AsyncSetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetServoRes>>(AsyncSetServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetServoRes>> PrepareAsyncSetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetServoRes>>(PrepareAsyncSetServoRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>> AsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>>(AsyncSetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>> PrepareAsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>>(PrepareAsyncSetAutoServoOffRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>> AsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>>(AsyncGetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>> PrepareAsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>>(PrepareAsyncGetAutoServoOffRaw(context, request, cq));
    }
    virtual ::grpc::Status ExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncExecuteToolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncExecuteToolRaw(context, request, cq));
    }
    virtual ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    virtual ::grpc::Status CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>> AsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>>(AsyncCalculateRelativePoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>> PrepareAsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>>(PrepareAsyncCalculateRelativePoseRaw(context, request, cq));
    }
    virtual ::grpc::Status CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>> AsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>>(AsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>> PrepareAsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>>(PrepareAsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Violation Recovery
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetManualRecoverModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetManualRecoverModeRaw(context, request, cq));
    }
    virtual ::grpc::Status SetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetServoRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetServoRecoverRaw(context, request, cq));
    }
    virtual ::grpc::Status JogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncJogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncJogJointRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncJogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncJogJointRecoverRaw(context, request, cq));
    }
    virtual ::grpc::Status Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::IndyFramework::Protobuf::HRI::RecoverRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RecoverRes>> AsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RecoverRes>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RecoverRes>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RecoverRes>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    virtual ::grpc::Status Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::IndyFramework::Protobuf::HRI::RebootRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RebootRes>> AsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RebootRes>>(AsyncRebootRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RebootRes>> PrepareAsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RebootRes>>(PrepareAsyncRebootRaw(context, request, cq));
    }
    virtual ::grpc::Status PowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PowerOffRes>> AsyncPowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PowerOffRes>>(AsyncPowerOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PowerOffRes>> PrepareAsyncPowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PowerOffRes>>(PrepareAsyncPowerOffRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Common
    // ---------------------------------------------------------------- //
    std::unique_ptr< ::grpc::ClientWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>> UpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>>(UpdateIndySWRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>> AsyncUpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>>(AsyncUpdateIndySWRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>> PrepareAsyncUpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>>(PrepareAsyncUpdateIndySWRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>> GetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>>(GetFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>> AsyncGetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>>(AsyncGetFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>> PrepareAsyncGetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>>(PrepareAsyncGetFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>> SetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>>(SetFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>> AsyncSetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>>(AsyncSetFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>> PrepareAsyncSetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>>(PrepareAsyncSetFileRaw(context, response, cq));
    }
    virtual ::grpc::Status RenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RenameFileRes>> AsyncRenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RenameFileRes>>(AsyncRenameFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RenameFileRes>> PrepareAsyncRenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RenameFileRes>>(PrepareAsyncRenameFileRaw(context, request, cq));
    }
    virtual ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RemoveFileRes>> AsyncRemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RemoveFileRes>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RemoveFileRes>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RemoveFileRes>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>> AsyncGetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>>(AsyncGetIndexProgramListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>> PrepareAsyncGetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>>(PrepareAsyncGetIndexProgramListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetProgramListRes>> AsyncGetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetProgramListRes>>(AsyncGetProgramListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetProgramListRes>> PrepareAsyncGetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetProgramListRes>>(PrepareAsyncGetProgramListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogListRes>> AsyncGetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogListRes>>(AsyncGetLogListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogListRes>> PrepareAsyncGetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogListRes>>(PrepareAsyncGetLogListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>> GetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>>(GetLogContentRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>> AsyncGetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>>(AsyncGetLogContentRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>> PrepareAsyncGetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>>(PrepareAsyncGetLogContentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>> GetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>>(GetLogContentListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>> AsyncGetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>>(AsyncGetLogContentListRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>> PrepareAsyncGetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>>(PrepareAsyncGetLogContentListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>> GetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>>(GetLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>> AsyncGetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>>(AsyncGetLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>> PrepareAsyncGetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>>(PrepareAsyncGetLogRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Config
    // ---------------------------------------------------------------- //
    //
    virtual ::grpc::Status GetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVariableListRes>> AsyncGetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVariableListRes>>(AsyncGetVariableListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVariableListRes>> PrepareAsyncGetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVariableListRes>>(PrepareAsyncGetVariableListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>> AsyncGetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>>(AsyncGetMonitoringVariableListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>> PrepareAsyncGetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>>(PrepareAsyncGetMonitoringVariableListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>> AsyncSetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>>(AsyncSetMonitoringVariableListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>> PrepareAsyncSetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>>(PrepareAsyncSetMonitoringVariableListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>> AsyncGetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>>(AsyncGetPalletMakerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>> PrepareAsyncGetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>>(PrepareAsyncGetPalletMakerListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>> AsyncSetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>>(AsyncSetPalletMakerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>> PrepareAsyncSetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>>(PrepareAsyncSetPalletMakerListRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>> AsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>>(AsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>> PrepareAsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>>(PrepareAsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>> AsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>>(AsyncGetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>> PrepareAsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>>(PrepareAsyncGetPalletPointListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>> AsyncSetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>>(AsyncSetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>> PrepareAsyncSetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>>(PrepareAsyncSetPalletPointListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Conveyor* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Conveyor>> AsyncGetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Conveyor>>(AsyncGetConveyorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Conveyor>> PrepareAsyncGetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Conveyor>>(PrepareAsyncGetConveyorRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorNameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorByNameRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorEncoderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorEncoderRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorTriggerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorTriggerRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ConveyorState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ConveyorState>> AsyncGetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ConveyorState>>(AsyncGetConveyorStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ConveyorState>> PrepareAsyncGetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ConveyorState>>(PrepareAsyncGetConveyorStateRaw(context, request, cq));
    }
    virtual ::grpc::Status HoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncHoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncHoldToMoveConveyorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncHoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncHoldToMoveConveyorRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>> AsyncGetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>>(AsyncGetConveyorListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>> PrepareAsyncGetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>>(PrepareAsyncGetConveyorListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>> AsyncSetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>>(AsyncSetConveyorListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>> PrepareAsyncSetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>>(PrepareAsyncSetConveyorListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetInchingRes>> AsyncSetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetInchingRes>>(AsyncSetInchingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetInchingRes>> PrepareAsyncSetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetInchingRes>>(PrepareAsyncSetInchingRaw(context, request, cq));
    }
    virtual ::grpc::Status StopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopInchingRes>> AsyncStopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopInchingRes>>(AsyncStopInchingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopInchingRes>> PrepareAsyncStopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopInchingRes>>(PrepareAsyncStopInchingRaw(context, request, cq));
    }
    virtual ::grpc::Status SetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::IndyFramework::Protobuf::HRI::SetArcRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetArcRes>> AsyncSetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetArcRes>>(AsyncSetArcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetArcRes>> PrepareAsyncSetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetArcRes>>(PrepareAsyncSetArcRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTouchRes>> AsyncSetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTouchRes>>(AsyncSetTouchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTouchRes>> PrepareAsyncSetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTouchRes>>(PrepareAsyncSetTouchRaw(context, request, cq));
    }
    virtual ::grpc::Status SetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::IndyFramework::Protobuf::HRI::SetGasRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetGasRes>> AsyncSetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetGasRes>>(AsyncSetGasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetGasRes>> PrepareAsyncSetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetGasRes>>(PrepareAsyncSetGasRaw(context, request, cq));
    }
    virtual ::grpc::Status IsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IsTouchedRes>> AsyncIsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IsTouchedRes>>(AsyncIsTouchedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IsTouchedRes>> PrepareAsyncIsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IsTouchedRes>>(PrepareAsyncIsTouchedRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>> AsyncGetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>>(AsyncGetVisionServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>> PrepareAsyncGetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>>(PrepareAsyncGetVisionServerListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>> AsyncSetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>>(AsyncSetVisionServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>> PrepareAsyncSetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>>(PrepareAsyncSetVisionServerListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>> AsyncGetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>>(AsyncGetVisionObjectListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>> PrepareAsyncGetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>>(PrepareAsyncGetVisionObjectListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::IndyFramework::Protobuf::HRI::VisionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>> AsyncGetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>>(AsyncGetVisionDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>> PrepareAsyncGetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>>(PrepareAsyncGetVisionDetectionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::IndyFramework::Protobuf::HRI::VisionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>> AsyncGetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>>(AsyncGetVisionRetrievalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>> PrepareAsyncGetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>>(PrepareAsyncGetVisionRetrievalRaw(context, request, cq));
    }
    // rpc GetModbusServer(GetModbusServerReq) returns (GetModbusServerRes) {}
    // rpc SetModbusServer(SetModbusServerReq) returns (SetModbusServerRes) {}
    //
    virtual ::grpc::Status GetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>> AsyncGetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>>(AsyncGetGcodeMotionListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>> PrepareAsyncGetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>>(PrepareAsyncGetGcodeMotionListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>> AsyncGetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>>(AsyncGetModbusServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>> PrepareAsyncGetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>>(PrepareAsyncGetModbusServerListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>> AsyncSetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>>(AsyncSetModbusServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>> PrepareAsyncSetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>>(PrepareAsyncSetModbusServerListRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>> AsyncCheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>>(AsyncCheckModbusConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>> PrepareAsyncCheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>>(PrepareAsyncCheckModbusConnectionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>> AsyncGetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>>(AsyncGetToolFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>> PrepareAsyncGetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>>(PrepareAsyncGetToolFrameListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>> AsyncSetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>>(AsyncSetToolFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>> PrepareAsyncSetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>>(PrepareAsyncSetToolFrameListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>> AsyncGetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>>(AsyncGetRefFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>> PrepareAsyncGetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>>(PrepareAsyncGetRefFrameListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>> AsyncSetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>>(AsyncSetRefFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>> PrepareAsyncSetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>>(PrepareAsyncSetRefFrameListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>> AsyncGetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>>(AsyncGetCustomPosListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>> PrepareAsyncGetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>>(PrepareAsyncGetCustomPosListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>> AsyncSetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>>(AsyncSetCustomPosListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>> PrepareAsyncSetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>>(PrepareAsyncSetCustomPosListRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Robot Config
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>> AsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>>(AsyncSetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>> PrepareAsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>>(PrepareAsyncSetJointControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>> AsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>>(AsyncGetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>> PrepareAsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>>(PrepareAsyncGetJointControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>> AsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>>(AsyncSetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>> PrepareAsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>>(PrepareAsyncSetTaskControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>> AsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>>(AsyncGetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>> PrepareAsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>>(PrepareAsyncGetTaskControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>> AsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>>(AsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>> PrepareAsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>>(PrepareAsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>> AsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>>(AsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>> PrepareAsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>>(PrepareAsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>> AsyncSetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>>(AsyncSetForceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>> PrepareAsyncSetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>>(PrepareAsyncSetForceControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>> AsyncGetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>>(AsyncGetForceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>> PrepareAsyncGetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>>(PrepareAsyncGetForceControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>> AsyncSetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>>(AsyncSetExtAxisControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>> PrepareAsyncSetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>>(PrepareAsyncSetExtAxisControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>> AsyncGetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>>(AsyncGetExtAxisControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>> PrepareAsyncGetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>>(PrepareAsyncGetExtAxisControlGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> AsyncSetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(AsyncSetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> PrepareAsyncSetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(PrepareAsyncSetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> AsyncGetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(AsyncGetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> PrepareAsyncGetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(PrepareAsyncGetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> AsyncSetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(AsyncSetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> PrepareAsyncSetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(PrepareAsyncSetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> AsyncGetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(AsyncGetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> PrepareAsyncGetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(PrepareAsyncGetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    virtual ::grpc::Status SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetFricCompRes>> AsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetFricCompRes>>(AsyncSetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetFricCompRes>> PrepareAsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetFricCompRes>>(PrepareAsyncSetFricCompRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetFricCompRes>> AsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetFricCompRes>>(AsyncGetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetFricCompRes>> PrepareAsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetFricCompRes>>(PrepareAsyncGetFricCompRaw(context, request, cq));
    }
    virtual ::grpc::Status SetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetHomePosRes>> AsyncSetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetHomePosRes>>(AsyncSetHomePosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetHomePosRes>> PrepareAsyncSetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetHomePosRes>>(PrepareAsyncSetHomePosRaw(context, request, cq));
    }
    virtual ::grpc::Status GetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetHomePosRes>> AsyncGetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetHomePosRes>>(AsyncGetHomePosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetHomePosRes>> PrepareAsyncGetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetHomePosRes>>(PrepareAsyncGetHomePosRaw(context, request, cq));
    }
    virtual ::grpc::Status SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMountPosRes>> AsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMountPosRes>>(AsyncSetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMountPosRes>> PrepareAsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMountPosRes>>(PrepareAsyncSetMountPosRaw(context, request, cq));
    }
    virtual ::grpc::Status GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMountPosRes>> AsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMountPosRes>>(AsyncGetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMountPosRes>> PrepareAsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMountPosRes>>(PrepareAsyncGetMountPosRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>> AsyncGetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>>(AsyncGetPackagingPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>> PrepareAsyncGetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>>(PrepareAsyncGetPackagingPosRaw(context, request, cq));
    }
    virtual ::grpc::Status SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>> AsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>>(AsyncSetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>> PrepareAsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>>(PrepareAsyncSetToolPropertyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>> AsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>>(AsyncGetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>> PrepareAsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>>(PrepareAsyncGetToolPropertyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>> AsyncGetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>>(AsyncGetOnStartProgramConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>> PrepareAsyncGetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>>(PrepareAsyncGetOnStartProgramConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status SetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>> AsyncSetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>>(AsyncSetOnStartProgramConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>> PrepareAsyncSetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>>(PrepareAsyncSetOnStartProgramConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>> AsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>>(AsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>> PrepareAsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>>(PrepareAsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>> AsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>>(AsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>> PrepareAsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>>(PrepareAsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>> AsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>>(AsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>> PrepareAsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>>(PrepareAsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>> AsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>>(AsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>> PrepareAsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>>(PrepareAsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>> AsyncGetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>>(AsyncGetSafetyConfigHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>> PrepareAsyncGetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>>(PrepareAsyncGetSafetyConfigHashRaw(context, request, cq));
    }
    virtual ::grpc::Status GetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KinematicsParams>> AsyncGetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KinematicsParams>>(AsyncGetKinematicsParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KinematicsParams>> PrepareAsyncGetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KinematicsParams>>(PrepareAsyncGetKinematicsParamsRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // IndyKey
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status KeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyInitRes>> AsyncKeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyInitRes>>(AsyncKeyInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyInitRes>> PrepareAsyncKeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyInitRes>>(PrepareAsyncKeyInitRaw(context, request, cq));
    }
    virtual ::grpc::Status KeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyDataRes>> AsyncKeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyDataRes>>(AsyncKeyDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyDataRes>> PrepareAsyncKeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyDataRes>>(PrepareAsyncKeyDataRaw(context, request, cq));
    }
    virtual ::grpc::Status ProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ProgramData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>> AsyncProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>>(AsyncProgramUpdateKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>> PrepareAsyncProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>>(PrepareAsyncProgramUpdateKeyRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> AsyncSetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(AsyncSetDirectTeachingModeKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> PrepareAsyncSetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(PrepareAsyncSetDirectTeachingModeKeyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>> AsyncGetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>>(AsyncGetAutoModeConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>> PrepareAsyncGetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>>(PrepareAsyncGetAutoModeConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>> AsyncSetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>>(AsyncSetAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>> PrepareAsyncSetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>>(PrepareAsyncSetAutoModeRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>> AsyncCheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>>(AsyncCheckAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>> PrepareAsyncCheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>>(PrepareAsyncCheckAutoModeRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>> AsyncCheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>>(AsyncCheckReducedModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>> PrepareAsyncCheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>>(PrepareAsyncCheckReducedModeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>> AsyncGetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>>(AsyncGetReducedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>> PrepareAsyncGetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>>(PrepareAsyncGetReducedRatioRaw(context, request, cq));
    }
    virtual ::grpc::Status GetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>> AsyncGetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>>(AsyncGetReducedSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>> PrepareAsyncGetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>>(PrepareAsyncGetReducedSpeedRaw(context, request, cq));
    }
    virtual ::grpc::Status SetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetReducedSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetReducedSpeedRaw(context, request, cq));
    }
    virtual ::grpc::Status GetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::StopState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopState>> AsyncGetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopState>>(AsyncGetStopStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopState>> PrepareAsyncGetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopState>>(PrepareAsyncGetStopStateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>> AsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>>(AsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>> PrepareAsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>>(PrepareAsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    virtual ::grpc::Status RequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Program Control
    // ---------------------------------------------------------------- //
    //
    virtual ::grpc::Status PlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramRes>> AsyncPlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramRes>>(AsyncPlayProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramRes>> PrepareAsyncPlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramRes>>(PrepareAsyncPlayProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status PlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>> AsyncPlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>>(AsyncPlayIndexProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>> PrepareAsyncPlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>>(PrepareAsyncPlayIndexProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status PlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>> AsyncPlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>>(AsyncPlayProgramLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>> PrepareAsyncPlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>>(PrepareAsyncPlayProgramLineRaw(context, request, cq));
    }
    virtual ::grpc::Status ResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>> AsyncResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>>(AsyncResumeProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>> PrepareAsyncResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>>(PrepareAsyncResumeProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status StopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopProgramRes>> AsyncStopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopProgramRes>>(AsyncStopProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopProgramRes>> PrepareAsyncStopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopProgramRes>>(PrepareAsyncStopProgramRaw(context, request, cq));
    }
    virtual ::grpc::Status PauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PauseProgramRes>> AsyncPauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PauseProgramRes>>(AsyncPauseProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PauseProgramRes>> PrepareAsyncPauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PauseProgramRes>>(PrepareAsyncPauseProgramRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // I/O Control
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetAORaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetEndDORaw(context, request, cq));
    }
    virtual ::grpc::Status SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetEndAORaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Configuration
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetToolListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetToolListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ToolList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ToolList>> AsyncGetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ToolList>>(AsyncGetToolListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ToolList>> PrepareAsyncGetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ToolList>>(PrepareAsyncGetToolListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetDIConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetDIConfigListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::DIConfigList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DIConfigList>> AsyncGetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DIConfigList>>(AsyncGetDIConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DIConfigList>> PrepareAsyncGetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DIConfigList>>(PrepareAsyncGetDIConfigListRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetDOConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetDOConfigListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::DOConfigList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DOConfigList>> AsyncGetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DOConfigList>>(AsyncGetDOConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DOConfigList>> PrepareAsyncGetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DOConfigList>>(PrepareAsyncGetDOConfigListRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Collision Detection
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCollSensLevelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>> AsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>>(AsyncGetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>> PrepareAsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>>(PrepareAsyncGetCollSensLevelRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCollPolicyRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionPolicy>> AsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionPolicy>>(AsyncGetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionPolicy>> PrepareAsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionPolicy>>(PrepareAsyncGetCollPolicyRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCollSensParamRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> AsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(AsyncGetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> PrepareAsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(PrepareAsyncGetCollSensParamRaw(context, request, cq));
    }
    virtual ::grpc::Status InitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncInitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncInitCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncInitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncInitCollSensParamRaw(context, request, cq));
    }
    virtual ::grpc::Status PlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> AsyncPlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(AsyncPlayTuningProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> PrepareAsyncPlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(PrepareAsyncPlayTuningProgramRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // TeleOperation
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpDevice>> AsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpDevice>>(AsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpDevice>> PrepareAsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpDevice>>(PrepareAsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpState>> AsyncGetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpState>>(AsyncGetTeleOpStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpState>> PrepareAsyncGetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpState>>(PrepareAsyncGetTeleOpStateRaw(context, request, cq));
    }
    virtual ::grpc::Status ConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    virtual ::grpc::Status DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleP* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleP>> AsyncReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleP>>(AsyncReadTeleOpInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleP>> PrepareAsyncReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleP>>(PrepareAsyncReadTeleOpInputRaw(context, request, cq));
    }
    virtual ::grpc::Status StartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleCalibRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleCalibRaw(context, request, cq));
    }
    virtual ::grpc::Status StartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleRecordRaw(context, request, cq));
    }
    virtual ::grpc::Status StartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTelePlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTelePlayRaw(context, request, cq));
    }
    virtual ::grpc::Status StartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleJogLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleJogLRaw(context, request, cq));
    }
    virtual ::grpc::Status StartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleJogJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleJogJRaw(context, request, cq));
    }
    virtual ::grpc::Status StopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncStopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStopTeleOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStopTeleOpRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetPlayRateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TelePlayRate>> AsyncGetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TelePlayRate>>(AsyncGetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TelePlayRate>> PrepareAsyncGetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TelePlayRate>>(PrepareAsyncGetPlayRateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpFileList>> AsyncGetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpFileList>>(AsyncGetTeleFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpFileList>> PrepareAsyncGetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpFileList>>(PrepareAsyncGetTeleFileListRaw(context, request, cq));
    }
    virtual ::grpc::Status SaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSaveTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSaveTeleMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status LoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncLoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncLoadTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncLoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncLoadTeleMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncDeleteTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncDeleteTeleMotionRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncMoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncMoveTeleJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncMoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncMoveTeleJRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncMoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncMoveTeleLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncMoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncMoveTeleLRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetTeleOpParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetTeleOpParamsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpParams>> AsyncGetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpParams>>(AsyncGetTeleOpParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpParams>> PrepareAsyncGetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpParams>>(PrepareAsyncGetTeleOpParamsRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Sanding
    // ---------------------------------------------------------------- //
    //
    //  rpc MoveFL(MoveFLReq) returns (MoveFLRes) {}
    //
    virtual ::grpc::Status SetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetFTSensorConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetFTSensorConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorDevice>> AsyncGetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorDevice>>(AsyncGetFTSensorConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorDevice>> PrepareAsyncGetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorDevice>>(PrepareAsyncGetFTSensorConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::FTSensorData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorData>> AsyncGetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorData>>(AsyncGetFTSensorDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorData>> PrepareAsyncGetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorData>>(PrepareAsyncGetFTSensorDataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>> AsyncGetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>>(AsyncGetLoadFactorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>> PrepareAsyncGetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>>(PrepareAsyncGetLoadFactorsRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSanderCommandRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SanderCommand* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SanderCommand>> AsyncGetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SanderCommand>>(AsyncGetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SanderCommand>> PrepareAsyncGetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SanderCommand>>(PrepareAsyncGetSanderCommandRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSandingStopConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSandingStopConditionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>> AsyncGetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>>(AsyncGetSandingStopConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>> PrepareAsyncGetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>>(PrepareAsyncGetSandingStopConditionRaw(context, request, cq));
    }
    // /////////////485Gripper//////////////////////
    virtual ::grpc::Status GetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GripperData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GripperData>> AsyncGetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GripperData>>(AsyncGetGripperDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GripperData>> PrepareAsyncGetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GripperData>>(PrepareAsyncGetGripperDataRaw(context, request, cq));
    }
    virtual ::grpc::Status SetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::IndyFramework::Protobuf::HRI::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> AsyncSetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncSetGripperCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncSetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncSetGripperCommandRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Safetics
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSFDActivateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSFDActivateRaw(context, request, cq));
    }
    virtual ::grpc::Status IsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::State* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>> AsyncIsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>>(AsyncIsSFDActivateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>> PrepareAsyncIsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>>(PrepareAsyncIsSFDActivateRaw(context, request, cq));
    }
    virtual ::grpc::Status SFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSFDLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSFDLoginRaw(context, request, cq));
    }
    virtual ::grpc::Status IsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::State* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>> AsyncIsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>>(AsyncIsSFDLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>> PrepareAsyncIsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>>(PrepareAsyncIsSFDLoginRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSFDTargetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSFDTargetRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::IndyFramework::Protobuf::HRI::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSFDOptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSFDOptionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDProjectList>> AsyncGetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDProjectList>>(AsyncGetSFDProjListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDProjectList>> PrepareAsyncGetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDProjectList>>(PrepareAsyncGetSFDProjListRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SFDCriData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDCriData>> AsyncGetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDCriData>>(AsyncGetSFDCRIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDCriData>> PrepareAsyncGetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDCriData>>(PrepareAsyncGetSFDCRIRaw(context, request, cq));
    }
    // /////////////TactTime//////////////////////
    virtual ::grpc::Status GetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TactTime* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TactTime>> AsyncGetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TactTime>>(AsyncGetTactTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TactTime>> PrepareAsyncGetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TactTime>>(PrepareAsyncGetTactTimeRaw(context, request, cq));
    }
    // ---------------------------------------------------------------- //
    // Photoneo
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> AsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void ContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq* request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq* request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::RobotData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::RobotData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ControlData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ControlData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void LinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::LinearData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::LinearData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Robot Control
      // ---------------------------------------------------------------- //
      virtual void JogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq* request, ::IndyFramework::Protobuf::HRI::JogJointRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void JogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq* request, ::IndyFramework::Protobuf::HRI::JogJointRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void JogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq* request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void JogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq* request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void JogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq* request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void JogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq* request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  rpc HoldToMoveJ(HoldToMoveJReq) returns (HoldToMoveJRes) {}
      //  rpc HoldToMoveL(HoldToMoveLReq) returns (HoldToMoveLRes) {}
      //  rpc HoldToAxisJ(HoldToAxisJReq) returns (HoldToAxisJRes) {}
      //
      virtual void HoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void HoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void HoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq* request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq* request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::IntMode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::IntMode* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq* request, ::IndyFramework::Protobuf::HRI::SetServoRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq* request, ::IndyFramework::Protobuf::HRI::SetServoRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Violation Recovery
      // ---------------------------------------------------------------- //
      virtual void SetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void JogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void JogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq* request, ::IndyFramework::Protobuf::HRI::RecoverRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq* request, ::IndyFramework::Protobuf::HRI::RecoverRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq* request, ::IndyFramework::Protobuf::HRI::RebootRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq* request, ::IndyFramework::Protobuf::HRI::RebootRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq* request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq* request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Common
      // ---------------------------------------------------------------- //
      virtual void UpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::ClientWriteReactor< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* reactor) = 0;
      virtual void GetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetFileRes>* reactor) = 0;
      virtual void SetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::ClientWriteReactor< ::IndyFramework::Protobuf::HRI::SetFileReq>* reactor) = 0;
      virtual void RenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq* request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq* request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq* request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq* request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* reactor) = 0;
      virtual void GetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* reactor) = 0;
      virtual void GetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetLogRes>* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Config
      // ---------------------------------------------------------------- //
      //
      virtual void GetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Conveyor* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Conveyor* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ConveyorState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ConveyorState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void HoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq* request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq* request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq* request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq* request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq* request, ::IndyFramework::Protobuf::HRI::SetArcRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq* request, ::IndyFramework::Protobuf::HRI::SetArcRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq* request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq* request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq* request, ::IndyFramework::Protobuf::HRI::SetGasRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq* request, ::IndyFramework::Protobuf::HRI::SetGasRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // rpc GetModbusServer(GetModbusServerReq) returns (GetModbusServerRes) {}
      // rpc SetModbusServer(SetModbusServerReq) returns (SetModbusServerRes) {}
      //
      virtual void GetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Robot Config
      // ---------------------------------------------------------------- //
      virtual void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // IndyKey
      // ---------------------------------------------------------------- //
      virtual void KeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq* request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq* request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void KeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq* request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq* request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::StopState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::StopState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Program Control
      // ---------------------------------------------------------------- //
      //
      virtual void PlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq* request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq* request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // I/O Control
      // ---------------------------------------------------------------- //
      virtual void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Configuration
      // ---------------------------------------------------------------- //
      virtual void SetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ToolList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ToolList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DIConfigList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DIConfigList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DOConfigList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DOConfigList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Collision Detection
      // ---------------------------------------------------------------- //
      virtual void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void InitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // TeleOperation
      // ---------------------------------------------------------------- //
      virtual void GetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleP* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleP* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void LoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void MoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Sanding
      // ---------------------------------------------------------------- //
      //
      //  rpc MoveFL(MoveFLReq) returns (MoveFLRes) {}
      //
      virtual void SetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SanderCommand* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SanderCommand* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // /////////////485Gripper//////////////////////
      virtual void GetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GripperData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GripperData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Safetics
      // ---------------------------------------------------------------- //
      virtual void SetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void IsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDCriData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDCriData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // /////////////TactTime//////////////////////
      virtual void GetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TactTime* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TactTime* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ---------------------------------------------------------------- //
      // Photoneo
      // ---------------------------------------------------------------- //
      virtual void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ContyInitRes>* AsyncContyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ContyInitRes>* PrepareAsyncContyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RobotData>* AsyncRobotUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RobotData>* PrepareAsyncRobotUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>* AsyncProgramUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>* PrepareAsyncProgramUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ControlData>* AsyncControlUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ControlData>* PrepareAsyncControlUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::LinearData>* AsyncLinearUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::LinearData>* PrepareAsyncLinearUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogJointRes>* AsyncJogJointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogJointRes>* PrepareAsyncJogJointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogTaskRes>* AsyncJogTaskRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogTaskRes>* PrepareAsyncJogTaskRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogAxisRes>* AsyncJogAxisRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::JogAxisRes>* PrepareAsyncJogAxisRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* AsyncHoldToMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncHoldToMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* AsyncHoldToMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncHoldToMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* AsyncHoldToAxisJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncHoldToAxisJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopMotionRes>* AsyncStopMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopMotionRes>* PrepareAsyncStopMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>* AsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>* PrepareAsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* AsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* PrepareAsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>* AsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>* PrepareAsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* AsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* PrepareAsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* AsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* PrepareAsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* AsyncSetDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* PrepareAsyncSetDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IntMode>* AsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IntMode>* PrepareAsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* AsyncSetSensorlessComplianceModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* PrepareAsyncSetSensorlessComplianceModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>* AsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>* PrepareAsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetBrakeRes>* AsyncSetBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetBrakeRes>* PrepareAsyncSetBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetServoRes>* AsyncSetServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetServoRes>* PrepareAsyncSetServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* AsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* PrepareAsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* AsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* PrepareAsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncExecuteToolRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncExecuteToolRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* AsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* PrepareAsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* AsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* PrepareAsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetManualRecoverModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetManualRecoverModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetServoRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetServoRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncJogJointRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncJogJointRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RecoverRes>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RecoverRes>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RebootRes>* AsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RebootRes>* PrepareAsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PowerOffRes>* AsyncPowerOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PowerOffRes>* PrepareAsyncPowerOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* UpdateIndySWRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* AsyncUpdateIndySWRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* PrepareAsyncUpdateIndySWRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>* GetFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>* AsyncGetFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetFileRes>* PrepareAsyncGetFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>* SetFileRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>* AsyncSetFileRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::IndyFramework::Protobuf::HRI::SetFileReq>* PrepareAsyncSetFileRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RenameFileRes>* AsyncRenameFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RenameFileRes>* PrepareAsyncRenameFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RemoveFileRes>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::RemoveFileRes>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* AsyncGetIndexProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* PrepareAsyncGetIndexProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetProgramListRes>* AsyncGetProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetProgramListRes>* PrepareAsyncGetProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogListRes>* AsyncGetLogListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogListRes>* PrepareAsyncGetLogListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* GetLogContentRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* AsyncGetLogContentRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* PrepareAsyncGetLogContentRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* GetLogContentListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* AsyncGetLogContentListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* PrepareAsyncGetLogContentListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>* GetLogRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>* AsyncGetLogRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::IndyFramework::Protobuf::HRI::GetLogRes>* PrepareAsyncGetLogRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVariableListRes>* AsyncGetVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVariableListRes>* PrepareAsyncGetVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* AsyncGetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* PrepareAsyncGetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* AsyncSetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* PrepareAsyncSetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* AsyncGetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* PrepareAsyncGetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* AsyncSetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* PrepareAsyncSetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* AsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* PrepareAsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* AsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* PrepareAsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* AsyncSetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* PrepareAsyncSetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Conveyor>* AsyncGetConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Conveyor>* PrepareAsyncGetConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ConveyorState>* AsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ConveyorState>* PrepareAsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncHoldToMoveConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncHoldToMoveConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>* AsyncGetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>* PrepareAsyncGetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>* AsyncSetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>* PrepareAsyncSetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetInchingRes>* AsyncSetInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetInchingRes>* PrepareAsyncSetInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopInchingRes>* AsyncStopInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopInchingRes>* PrepareAsyncStopInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetArcRes>* AsyncSetArcRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetArcRes>* PrepareAsyncSetArcRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTouchRes>* AsyncSetTouchRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTouchRes>* PrepareAsyncSetTouchRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetGasRes>* AsyncSetGasRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetGasRes>* PrepareAsyncSetGasRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IsTouchedRes>* AsyncIsTouchedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::IsTouchedRes>* PrepareAsyncIsTouchedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* AsyncGetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* PrepareAsyncGetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* AsyncSetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* PrepareAsyncSetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* AsyncGetVisionObjectListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* PrepareAsyncGetVisionObjectListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>* AsyncGetVisionDetectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>* PrepareAsyncGetVisionDetectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>* AsyncGetVisionRetrievalRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::VisionResult>* PrepareAsyncGetVisionRetrievalRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* AsyncGetGcodeMotionListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* PrepareAsyncGetGcodeMotionListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* AsyncGetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* PrepareAsyncGetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* AsyncSetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* PrepareAsyncSetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* AsyncCheckModbusConnectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* PrepareAsyncCheckModbusConnectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* AsyncGetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* PrepareAsyncGetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* AsyncSetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* PrepareAsyncSetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* AsyncGetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* PrepareAsyncGetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* AsyncSetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* PrepareAsyncSetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* AsyncGetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* PrepareAsyncGetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* AsyncSetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* PrepareAsyncSetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* AsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* PrepareAsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* AsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* PrepareAsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* AsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* PrepareAsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* AsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* PrepareAsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* AsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* PrepareAsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* AsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* PrepareAsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* AsyncSetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* PrepareAsyncSetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* AsyncGetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* PrepareAsyncGetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* AsyncSetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* PrepareAsyncSetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* AsyncGetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* PrepareAsyncGetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* AsyncSetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* PrepareAsyncSetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* AsyncGetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* PrepareAsyncGetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* AsyncSetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* PrepareAsyncSetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* AsyncGetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* PrepareAsyncGetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetFricCompRes>* AsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetFricCompRes>* PrepareAsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetFricCompRes>* AsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetFricCompRes>* PrepareAsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetHomePosRes>* AsyncSetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetHomePosRes>* PrepareAsyncSetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetHomePosRes>* AsyncGetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetHomePosRes>* PrepareAsyncGetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMountPosRes>* AsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetMountPosRes>* PrepareAsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMountPosRes>* AsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetMountPosRes>* PrepareAsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* AsyncGetPackagingPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* PrepareAsyncGetPackagingPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* AsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* PrepareAsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* AsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* PrepareAsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* AsyncGetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* PrepareAsyncGetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* AsyncSetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* PrepareAsyncSetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* AsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* PrepareAsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* AsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* PrepareAsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* AsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* PrepareAsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* AsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* PrepareAsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* AsyncGetSafetyConfigHashRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* PrepareAsyncGetSafetyConfigHashRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KinematicsParams>* AsyncGetKinematicsParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KinematicsParams>* PrepareAsyncGetKinematicsParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyInitRes>* AsyncKeyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyInitRes>* PrepareAsyncKeyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyDataRes>* AsyncKeyDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::KeyDataRes>* PrepareAsyncKeyDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>* AsyncProgramUpdateKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ProgramData>* PrepareAsyncProgramUpdateKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* AsyncSetDirectTeachingModeKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* PrepareAsyncSetDirectTeachingModeKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* AsyncGetAutoModeConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* PrepareAsyncGetAutoModeConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>* AsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>* PrepareAsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* AsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* PrepareAsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* AsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* PrepareAsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* AsyncGetReducedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* PrepareAsyncGetReducedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* AsyncGetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* PrepareAsyncGetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopState>* AsyncGetStopStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopState>* PrepareAsyncGetStopStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>* AsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>* PrepareAsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramRes>* AsyncPlayProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramRes>* PrepareAsyncPlayProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* AsyncPlayIndexProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* PrepareAsyncPlayIndexProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* AsyncPlayProgramLineRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* PrepareAsyncPlayProgramLineRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>* AsyncResumeProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>* PrepareAsyncResumeProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopProgramRes>* AsyncStopProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::StopProgramRes>* PrepareAsyncStopProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PauseProgramRes>* AsyncPauseProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::PauseProgramRes>* PrepareAsyncPauseProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ToolList>* AsyncGetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::ToolList>* PrepareAsyncGetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DIConfigList>* AsyncGetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DIConfigList>* PrepareAsyncGetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DOConfigList>* AsyncGetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::DOConfigList>* PrepareAsyncGetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>* AsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>* PrepareAsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionPolicy>* AsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionPolicy>* PrepareAsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* AsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* PrepareAsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncInitCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncInitCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* AsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* PrepareAsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpDevice>* AsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpDevice>* PrepareAsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpState>* AsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpState>* PrepareAsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleP>* AsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleP>* PrepareAsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleCalibRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleCalibRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleRecordRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleRecordRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTelePlayRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTelePlayRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleJogLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleJogLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleJogJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleJogJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TelePlayRate>* AsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TelePlayRate>* PrepareAsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpFileList>* AsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpFileList>* PrepareAsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpParams>* AsyncGetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TeleOpParams>* PrepareAsyncGetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorDevice>* AsyncGetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorDevice>* PrepareAsyncGetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorData>* AsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::FTSensorData>* PrepareAsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* AsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* PrepareAsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SanderCommand>* AsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SanderCommand>* PrepareAsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>* AsyncGetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>* PrepareAsyncGetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GripperData>* AsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::GripperData>* PrepareAsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* AsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>* AsyncIsSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>* PrepareAsyncIsSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>* AsyncIsSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::State>* PrepareAsyncIsSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSFDTargetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSFDTargetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSFDOptionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSFDOptionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDProjectList>* AsyncGetSFDProjListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDProjectList>* PrepareAsyncGetSFDProjListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDCriData>* AsyncGetSFDCRIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::SFDCriData>* PrepareAsyncGetSFDCRIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TactTime>* AsyncGetTactTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::TactTime>* PrepareAsyncGetTactTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* AsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ContyInitRes>> AsyncContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ContyInitRes>>(AsyncContyInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ContyInitRes>> PrepareAsyncContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ContyInitRes>>(PrepareAsyncContyInitRaw(context, request, cq));
    }
    ::grpc::Status RobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::RobotData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RobotData>> AsyncRobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RobotData>>(AsyncRobotUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RobotData>> PrepareAsyncRobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RobotData>>(PrepareAsyncRobotUpdateRaw(context, request, cq));
    }
    ::grpc::Status ProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ProgramData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>> AsyncProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>>(AsyncProgramUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>> PrepareAsyncProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>>(PrepareAsyncProgramUpdateRaw(context, request, cq));
    }
    ::grpc::Status ControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ControlData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ControlData>> AsyncControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ControlData>>(AsyncControlUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ControlData>> PrepareAsyncControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ControlData>>(PrepareAsyncControlUpdateRaw(context, request, cq));
    }
    ::grpc::Status LinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::LinearData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::LinearData>> AsyncLinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::LinearData>>(AsyncLinearUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::LinearData>> PrepareAsyncLinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::LinearData>>(PrepareAsyncLinearUpdateRaw(context, request, cq));
    }
    ::grpc::Status JogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::IndyFramework::Protobuf::HRI::JogJointRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogJointRes>> AsyncJogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogJointRes>>(AsyncJogJointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogJointRes>> PrepareAsyncJogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogJointRes>>(PrepareAsyncJogJointRaw(context, request, cq));
    }
    ::grpc::Status JogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogTaskRes>> AsyncJogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogTaskRes>>(AsyncJogTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogTaskRes>> PrepareAsyncJogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogTaskRes>>(PrepareAsyncJogTaskRaw(context, request, cq));
    }
    ::grpc::Status JogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogAxisRes>> AsyncJogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogAxisRes>>(AsyncJogAxisRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogAxisRes>> PrepareAsyncJogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogAxisRes>>(PrepareAsyncJogAxisRaw(context, request, cq));
    }
    ::grpc::Status HoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> AsyncHoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncHoldToMoveJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncHoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncHoldToMoveJRaw(context, request, cq));
    }
    ::grpc::Status HoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> AsyncHoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncHoldToMoveLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncHoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncHoldToMoveLRaw(context, request, cq));
    }
    ::grpc::Status HoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> AsyncHoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncHoldToAxisJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncHoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncHoldToAxisJRaw(context, request, cq));
    }
    ::grpc::Status StopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopMotionRes>> AsyncStopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopMotionRes>>(AsyncStopMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopMotionRes>> PrepareAsyncStopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopMotionRes>>(PrepareAsyncStopMotionRaw(context, request, cq));
    }
    ::grpc::Status SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>> AsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>>(AsyncSetRefFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>> PrepareAsyncSetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>>(PrepareAsyncSetRefFrameRaw(context, request, cq));
    }
    ::grpc::Status SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>> AsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>>(AsyncSetRefFramePlanarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>> PrepareAsyncSetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>>(PrepareAsyncSetRefFramePlanarRaw(context, request, cq));
    }
    ::grpc::Status SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>> AsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>>(AsyncSetToolFrameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>> PrepareAsyncSetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>>(PrepareAsyncSetToolFrameRaw(context, request, cq));
    }
    ::grpc::Status SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>> AsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>>(AsyncSetSpeedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>> PrepareAsyncSetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>>(PrepareAsyncSetSpeedRatioRaw(context, request, cq));
    }
    ::grpc::Status SetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>> AsyncSetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>>(AsyncSetSimulationModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>> PrepareAsyncSetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>>(PrepareAsyncSetSimulationModeRaw(context, request, cq));
    }
    ::grpc::Status SetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> AsyncSetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(AsyncSetDirectTeachingModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> PrepareAsyncSetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(PrepareAsyncSetDirectTeachingModeRaw(context, request, cq));
    }
    ::grpc::Status SetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCustomControlModeRaw(context, request, cq));
    }
    ::grpc::Status GetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::IntMode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IntMode>> AsyncGetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IntMode>>(AsyncGetCustomControlModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IntMode>> PrepareAsyncGetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IntMode>>(PrepareAsyncGetCustomControlModeRaw(context, request, cq));
    }
    ::grpc::Status SetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>> AsyncSetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>>(AsyncSetSensorlessComplianceModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>> PrepareAsyncSetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>>(PrepareAsyncSetSensorlessComplianceModeRaw(context, request, cq));
    }
    ::grpc::Status GetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>> AsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>>(AsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>> PrepareAsyncGetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>>(PrepareAsyncGetBrakeControlStyleRaw(context, request, cq));
    }
    ::grpc::Status SetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetBrakeRes>> AsyncSetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetBrakeRes>>(AsyncSetBrakeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetBrakeRes>> PrepareAsyncSetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetBrakeRes>>(PrepareAsyncSetBrakeRaw(context, request, cq));
    }
    ::grpc::Status SetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::IndyFramework::Protobuf::HRI::SetServoRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetServoRes>> AsyncSetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetServoRes>>(AsyncSetServoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetServoRes>> PrepareAsyncSetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetServoRes>>(PrepareAsyncSetServoRaw(context, request, cq));
    }
    ::grpc::Status SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>> AsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>>(AsyncSetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>> PrepareAsyncSetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>>(PrepareAsyncSetAutoServoOffRaw(context, request, cq));
    }
    ::grpc::Status GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>> AsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>>(AsyncGetAutoServoOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>> PrepareAsyncGetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>>(PrepareAsyncGetAutoServoOffRaw(context, request, cq));
    }
    ::grpc::Status ExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncExecuteToolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncExecuteToolRaw(context, request, cq));
    }
    ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    ::grpc::Status CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>> AsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>>(AsyncCalculateRelativePoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>> PrepareAsyncCalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>>(PrepareAsyncCalculateRelativePoseRaw(context, request, cq));
    }
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>> AsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>>(AsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>> PrepareAsyncCalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>>(PrepareAsyncCalculateCurrentPoseRelRaw(context, request, cq));
    }
    ::grpc::Status SetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetManualRecoverModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetManualRecoverModeRaw(context, request, cq));
    }
    ::grpc::Status SetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetServoRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetServoRecoverRaw(context, request, cq));
    }
    ::grpc::Status JogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncJogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncJogJointRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncJogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncJogJointRecoverRaw(context, request, cq));
    }
    ::grpc::Status Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::IndyFramework::Protobuf::HRI::RecoverRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RecoverRes>> AsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RecoverRes>>(AsyncRecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RecoverRes>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RecoverRes>>(PrepareAsyncRecoverRaw(context, request, cq));
    }
    ::grpc::Status Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::IndyFramework::Protobuf::HRI::RebootRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RebootRes>> AsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RebootRes>>(AsyncRebootRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RebootRes>> PrepareAsyncReboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RebootRes>>(PrepareAsyncRebootRaw(context, request, cq));
    }
    ::grpc::Status PowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PowerOffRes>> AsyncPowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PowerOffRes>>(AsyncPowerOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PowerOffRes>> PrepareAsyncPowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PowerOffRes>>(PrepareAsyncPowerOffRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>> UpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>>(UpdateIndySWRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>> AsyncUpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>>(AsyncUpdateIndySWRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>> PrepareAsyncUpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>>(PrepareAsyncUpdateIndySWRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetFileRes>> GetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetFileRes>>(GetFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetFileRes>> AsyncGetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetFileRes>>(AsyncGetFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetFileRes>> PrepareAsyncGetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetFileRes>>(PrepareAsyncGetFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>> SetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>>(SetFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>> AsyncSetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>>(AsyncSetFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>> PrepareAsyncSetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>>(PrepareAsyncSetFileRaw(context, response, cq));
    }
    ::grpc::Status RenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RenameFileRes>> AsyncRenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RenameFileRes>>(AsyncRenameFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RenameFileRes>> PrepareAsyncRenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RenameFileRes>>(PrepareAsyncRenameFileRaw(context, request, cq));
    }
    ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RemoveFileRes>> AsyncRemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RemoveFileRes>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RemoveFileRes>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RemoveFileRes>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    ::grpc::Status GetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>> AsyncGetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>>(AsyncGetIndexProgramListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>> PrepareAsyncGetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>>(PrepareAsyncGetIndexProgramListRaw(context, request, cq));
    }
    ::grpc::Status GetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetProgramListRes>> AsyncGetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetProgramListRes>>(AsyncGetProgramListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetProgramListRes>> PrepareAsyncGetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetProgramListRes>>(PrepareAsyncGetProgramListRaw(context, request, cq));
    }
    ::grpc::Status GetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLogListRes>> AsyncGetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLogListRes>>(AsyncGetLogListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLogListRes>> PrepareAsyncGetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLogListRes>>(PrepareAsyncGetLogListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>> GetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>>(GetLogContentRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>> AsyncGetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>>(AsyncGetLogContentRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>> PrepareAsyncGetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>>(PrepareAsyncGetLogContentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>> GetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>>(GetLogContentListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>> AsyncGetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>>(AsyncGetLogContentListRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>> PrepareAsyncGetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>>(PrepareAsyncGetLogContentListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogRes>> GetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogRes>>(GetLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogRes>> AsyncGetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogRes>>(AsyncGetLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogRes>> PrepareAsyncGetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogRes>>(PrepareAsyncGetLogRaw(context, request, cq));
    }
    ::grpc::Status GetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVariableListRes>> AsyncGetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVariableListRes>>(AsyncGetVariableListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVariableListRes>> PrepareAsyncGetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVariableListRes>>(PrepareAsyncGetVariableListRaw(context, request, cq));
    }
    ::grpc::Status GetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>> AsyncGetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>>(AsyncGetMonitoringVariableListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>> PrepareAsyncGetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>>(PrepareAsyncGetMonitoringVariableListRaw(context, request, cq));
    }
    ::grpc::Status SetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>> AsyncSetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>>(AsyncSetMonitoringVariableListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>> PrepareAsyncSetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>>(PrepareAsyncSetMonitoringVariableListRaw(context, request, cq));
    }
    ::grpc::Status GetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>> AsyncGetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>>(AsyncGetPalletMakerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>> PrepareAsyncGetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>>(PrepareAsyncGetPalletMakerListRaw(context, request, cq));
    }
    ::grpc::Status SetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>> AsyncSetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>>(AsyncSetPalletMakerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>> PrepareAsyncSetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>>(PrepareAsyncSetPalletMakerListRaw(context, request, cq));
    }
    ::grpc::Status CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>> AsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>>(AsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>> PrepareAsyncCheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>>(PrepareAsyncCheckAproachRetractValidRaw(context, request, cq));
    }
    ::grpc::Status GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>> AsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>>(AsyncGetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>> PrepareAsyncGetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>>(PrepareAsyncGetPalletPointListRaw(context, request, cq));
    }
    ::grpc::Status SetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>> AsyncSetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>>(AsyncSetPalletPointListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>> PrepareAsyncSetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>>(PrepareAsyncSetPalletPointListRaw(context, request, cq));
    }
    ::grpc::Status GetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Conveyor* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Conveyor>> AsyncGetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Conveyor>>(AsyncGetConveyorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Conveyor>> PrepareAsyncGetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Conveyor>>(PrepareAsyncGetConveyorRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorNameRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorByNameRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorEncoderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorEncoderRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorTriggerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorTriggerRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorOffsetRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorStartingPoseRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetConveyorTerminalPoseRaw(context, request, cq));
    }
    ::grpc::Status GetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ConveyorState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ConveyorState>> AsyncGetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ConveyorState>>(AsyncGetConveyorStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ConveyorState>> PrepareAsyncGetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ConveyorState>>(PrepareAsyncGetConveyorStateRaw(context, request, cq));
    }
    ::grpc::Status HoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncHoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncHoldToMoveConveyorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncHoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncHoldToMoveConveyorRaw(context, request, cq));
    }
    ::grpc::Status GetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>> AsyncGetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>>(AsyncGetConveyorListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>> PrepareAsyncGetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>>(PrepareAsyncGetConveyorListRaw(context, request, cq));
    }
    ::grpc::Status SetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>> AsyncSetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>>(AsyncSetConveyorListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>> PrepareAsyncSetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>>(PrepareAsyncSetConveyorListRaw(context, request, cq));
    }
    ::grpc::Status SetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetInchingRes>> AsyncSetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetInchingRes>>(AsyncSetInchingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetInchingRes>> PrepareAsyncSetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetInchingRes>>(PrepareAsyncSetInchingRaw(context, request, cq));
    }
    ::grpc::Status StopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopInchingRes>> AsyncStopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopInchingRes>>(AsyncStopInchingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopInchingRes>> PrepareAsyncStopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopInchingRes>>(PrepareAsyncStopInchingRaw(context, request, cq));
    }
    ::grpc::Status SetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::IndyFramework::Protobuf::HRI::SetArcRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetArcRes>> AsyncSetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetArcRes>>(AsyncSetArcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetArcRes>> PrepareAsyncSetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetArcRes>>(PrepareAsyncSetArcRaw(context, request, cq));
    }
    ::grpc::Status SetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTouchRes>> AsyncSetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTouchRes>>(AsyncSetTouchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTouchRes>> PrepareAsyncSetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTouchRes>>(PrepareAsyncSetTouchRaw(context, request, cq));
    }
    ::grpc::Status SetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::IndyFramework::Protobuf::HRI::SetGasRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetGasRes>> AsyncSetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetGasRes>>(AsyncSetGasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetGasRes>> PrepareAsyncSetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetGasRes>>(PrepareAsyncSetGasRaw(context, request, cq));
    }
    ::grpc::Status IsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IsTouchedRes>> AsyncIsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IsTouchedRes>>(AsyncIsTouchedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IsTouchedRes>> PrepareAsyncIsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IsTouchedRes>>(PrepareAsyncIsTouchedRaw(context, request, cq));
    }
    ::grpc::Status GetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>> AsyncGetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>>(AsyncGetVisionServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>> PrepareAsyncGetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>>(PrepareAsyncGetVisionServerListRaw(context, request, cq));
    }
    ::grpc::Status SetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>> AsyncSetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>>(AsyncSetVisionServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>> PrepareAsyncSetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>>(PrepareAsyncSetVisionServerListRaw(context, request, cq));
    }
    ::grpc::Status GetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>> AsyncGetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>>(AsyncGetVisionObjectListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>> PrepareAsyncGetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>>(PrepareAsyncGetVisionObjectListRaw(context, request, cq));
    }
    ::grpc::Status GetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::IndyFramework::Protobuf::HRI::VisionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>> AsyncGetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>>(AsyncGetVisionDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>> PrepareAsyncGetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>>(PrepareAsyncGetVisionDetectionRaw(context, request, cq));
    }
    ::grpc::Status GetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::IndyFramework::Protobuf::HRI::VisionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>> AsyncGetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>>(AsyncGetVisionRetrievalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>> PrepareAsyncGetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>>(PrepareAsyncGetVisionRetrievalRaw(context, request, cq));
    }
    ::grpc::Status GetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>> AsyncGetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>>(AsyncGetGcodeMotionListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>> PrepareAsyncGetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>>(PrepareAsyncGetGcodeMotionListRaw(context, request, cq));
    }
    ::grpc::Status GetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>> AsyncGetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>>(AsyncGetModbusServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>> PrepareAsyncGetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>>(PrepareAsyncGetModbusServerListRaw(context, request, cq));
    }
    ::grpc::Status SetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>> AsyncSetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>>(AsyncSetModbusServerListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>> PrepareAsyncSetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>>(PrepareAsyncSetModbusServerListRaw(context, request, cq));
    }
    ::grpc::Status CheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>> AsyncCheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>>(AsyncCheckModbusConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>> PrepareAsyncCheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>>(PrepareAsyncCheckModbusConnectionRaw(context, request, cq));
    }
    ::grpc::Status GetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>> AsyncGetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>>(AsyncGetToolFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>> PrepareAsyncGetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>>(PrepareAsyncGetToolFrameListRaw(context, request, cq));
    }
    ::grpc::Status SetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>> AsyncSetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>>(AsyncSetToolFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>> PrepareAsyncSetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>>(PrepareAsyncSetToolFrameListRaw(context, request, cq));
    }
    ::grpc::Status GetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>> AsyncGetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>>(AsyncGetRefFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>> PrepareAsyncGetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>>(PrepareAsyncGetRefFrameListRaw(context, request, cq));
    }
    ::grpc::Status SetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>> AsyncSetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>>(AsyncSetRefFrameListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>> PrepareAsyncSetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>>(PrepareAsyncSetRefFrameListRaw(context, request, cq));
    }
    ::grpc::Status GetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>> AsyncGetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>>(AsyncGetCustomPosListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>> PrepareAsyncGetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>>(PrepareAsyncGetCustomPosListRaw(context, request, cq));
    }
    ::grpc::Status SetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>> AsyncSetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>>(AsyncSetCustomPosListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>> PrepareAsyncSetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>>(PrepareAsyncSetCustomPosListRaw(context, request, cq));
    }
    ::grpc::Status SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>> AsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>>(AsyncSetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>> PrepareAsyncSetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>>(PrepareAsyncSetJointControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>> AsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>>(AsyncGetJointControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>> PrepareAsyncGetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>>(PrepareAsyncGetJointControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>> AsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>>(AsyncSetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>> PrepareAsyncSetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>>(PrepareAsyncSetTaskControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>> AsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>>(AsyncGetTaskControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>> PrepareAsyncGetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>>(PrepareAsyncGetTaskControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>> AsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>>(AsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>> PrepareAsyncSetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>>(PrepareAsyncSetImpedanceControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>> AsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>>(AsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>> PrepareAsyncGetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>>(PrepareAsyncGetImpedanceControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>> AsyncSetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>>(AsyncSetForceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>> PrepareAsyncSetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>>(PrepareAsyncSetForceControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>> AsyncGetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>>(AsyncGetForceControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>> PrepareAsyncGetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>>(PrepareAsyncGetForceControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>> AsyncSetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>>(AsyncSetExtAxisControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>> PrepareAsyncSetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>>(PrepareAsyncSetExtAxisControlGainRaw(context, request, cq));
    }
    ::grpc::Status GetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>> AsyncGetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>>(AsyncGetExtAxisControlGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>> PrepareAsyncGetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>>(PrepareAsyncGetExtAxisControlGainRaw(context, request, cq));
    }
    ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> AsyncSetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(AsyncSetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> PrepareAsyncSetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(PrepareAsyncSetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> AsyncGetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(AsyncGetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> PrepareAsyncGetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(PrepareAsyncGetSensorlessComplianceControlJointGainRaw(context, request, cq));
    }
    ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> AsyncSetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(AsyncSetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>> PrepareAsyncSetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>>(PrepareAsyncSetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> AsyncGetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(AsyncGetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>> PrepareAsyncGetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>>(PrepareAsyncGetSensorlessComplianceControlTaskGainRaw(context, request, cq));
    }
    ::grpc::Status SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetFricCompRes>> AsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetFricCompRes>>(AsyncSetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetFricCompRes>> PrepareAsyncSetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetFricCompRes>>(PrepareAsyncSetFricCompRaw(context, request, cq));
    }
    ::grpc::Status GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetFricCompRes>> AsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetFricCompRes>>(AsyncGetFricCompRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetFricCompRes>> PrepareAsyncGetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetFricCompRes>>(PrepareAsyncGetFricCompRaw(context, request, cq));
    }
    ::grpc::Status SetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetHomePosRes>> AsyncSetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetHomePosRes>>(AsyncSetHomePosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetHomePosRes>> PrepareAsyncSetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetHomePosRes>>(PrepareAsyncSetHomePosRaw(context, request, cq));
    }
    ::grpc::Status GetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetHomePosRes>> AsyncGetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetHomePosRes>>(AsyncGetHomePosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetHomePosRes>> PrepareAsyncGetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetHomePosRes>>(PrepareAsyncGetHomePosRaw(context, request, cq));
    }
    ::grpc::Status SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMountPosRes>> AsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMountPosRes>>(AsyncSetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMountPosRes>> PrepareAsyncSetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMountPosRes>>(PrepareAsyncSetMountPosRaw(context, request, cq));
    }
    ::grpc::Status GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMountPosRes>> AsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMountPosRes>>(AsyncGetMountPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMountPosRes>> PrepareAsyncGetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMountPosRes>>(PrepareAsyncGetMountPosRaw(context, request, cq));
    }
    ::grpc::Status GetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>> AsyncGetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>>(AsyncGetPackagingPosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>> PrepareAsyncGetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>>(PrepareAsyncGetPackagingPosRaw(context, request, cq));
    }
    ::grpc::Status SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>> AsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>>(AsyncSetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>> PrepareAsyncSetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>>(PrepareAsyncSetToolPropertyRaw(context, request, cq));
    }
    ::grpc::Status GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>> AsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>>(AsyncGetToolPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>> PrepareAsyncGetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>>(PrepareAsyncGetToolPropertyRaw(context, request, cq));
    }
    ::grpc::Status GetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>> AsyncGetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>>(AsyncGetOnStartProgramConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>> PrepareAsyncGetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>>(PrepareAsyncGetOnStartProgramConfigRaw(context, request, cq));
    }
    ::grpc::Status SetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>> AsyncSetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>>(AsyncSetOnStartProgramConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>> PrepareAsyncSetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>>(PrepareAsyncSetOnStartProgramConfigRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>> AsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>>(AsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>> PrepareAsyncGetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>>(PrepareAsyncGetSafetyLimitConfigRaw(context, request, cq));
    }
    ::grpc::Status SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>> AsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>>(AsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>> PrepareAsyncSetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>>(PrepareAsyncSetSafetyLimitConfigRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>> AsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>>(AsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>> PrepareAsyncGetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>>(PrepareAsyncGetSafetyStopConfigRaw(context, request, cq));
    }
    ::grpc::Status SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>> AsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>>(AsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>> PrepareAsyncSetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>>(PrepareAsyncSetSafetyStopConfigRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>> AsyncGetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>>(AsyncGetSafetyConfigHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>> PrepareAsyncGetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>>(PrepareAsyncGetSafetyConfigHashRaw(context, request, cq));
    }
    ::grpc::Status GetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KinematicsParams>> AsyncGetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KinematicsParams>>(AsyncGetKinematicsParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KinematicsParams>> PrepareAsyncGetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KinematicsParams>>(PrepareAsyncGetKinematicsParamsRaw(context, request, cq));
    }
    ::grpc::Status KeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyInitRes>> AsyncKeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyInitRes>>(AsyncKeyInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyInitRes>> PrepareAsyncKeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyInitRes>>(PrepareAsyncKeyInitRaw(context, request, cq));
    }
    ::grpc::Status KeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyDataRes>> AsyncKeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyDataRes>>(AsyncKeyDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyDataRes>> PrepareAsyncKeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyDataRes>>(PrepareAsyncKeyDataRaw(context, request, cq));
    }
    ::grpc::Status ProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ProgramData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>> AsyncProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>>(AsyncProgramUpdateKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>> PrepareAsyncProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>>(PrepareAsyncProgramUpdateKeyRaw(context, request, cq));
    }
    ::grpc::Status SetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> AsyncSetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(AsyncSetDirectTeachingModeKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>> PrepareAsyncSetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>>(PrepareAsyncSetDirectTeachingModeKeyRaw(context, request, cq));
    }
    ::grpc::Status GetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>> AsyncGetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>>(AsyncGetAutoModeConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>> PrepareAsyncGetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>>(PrepareAsyncGetAutoModeConfigRaw(context, request, cq));
    }
    ::grpc::Status SetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>> AsyncSetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>>(AsyncSetAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>> PrepareAsyncSetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>>(PrepareAsyncSetAutoModeRaw(context, request, cq));
    }
    ::grpc::Status CheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>> AsyncCheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>>(AsyncCheckAutoModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>> PrepareAsyncCheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>>(PrepareAsyncCheckAutoModeRaw(context, request, cq));
    }
    ::grpc::Status CheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>> AsyncCheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>>(AsyncCheckReducedModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>> PrepareAsyncCheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>>(PrepareAsyncCheckReducedModeRaw(context, request, cq));
    }
    ::grpc::Status GetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>> AsyncGetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>>(AsyncGetReducedRatioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>> PrepareAsyncGetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>>(PrepareAsyncGetReducedRatioRaw(context, request, cq));
    }
    ::grpc::Status GetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>> AsyncGetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>>(AsyncGetReducedSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>> PrepareAsyncGetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>>(PrepareAsyncGetReducedSpeedRaw(context, request, cq));
    }
    ::grpc::Status SetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetReducedSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetReducedSpeedRaw(context, request, cq));
    }
    ::grpc::Status GetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::StopState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopState>> AsyncGetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopState>>(AsyncGetStopStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopState>> PrepareAsyncGetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopState>>(PrepareAsyncGetStopStateRaw(context, request, cq));
    }
    ::grpc::Status GetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>> AsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>>(AsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>> PrepareAsyncGetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>>(PrepareAsyncGetSafetyFunctionStateRaw(context, request, cq));
    }
    ::grpc::Status RequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncRequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncRequestSafetyFunctionRaw(context, request, cq));
    }
    ::grpc::Status PlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramRes>> AsyncPlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramRes>>(AsyncPlayProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramRes>> PrepareAsyncPlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramRes>>(PrepareAsyncPlayProgramRaw(context, request, cq));
    }
    ::grpc::Status PlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>> AsyncPlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>>(AsyncPlayIndexProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>> PrepareAsyncPlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>>(PrepareAsyncPlayIndexProgramRaw(context, request, cq));
    }
    ::grpc::Status PlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>> AsyncPlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>>(AsyncPlayProgramLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>> PrepareAsyncPlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>>(PrepareAsyncPlayProgramLineRaw(context, request, cq));
    }
    ::grpc::Status ResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>> AsyncResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>>(AsyncResumeProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>> PrepareAsyncResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>>(PrepareAsyncResumeProgramRaw(context, request, cq));
    }
    ::grpc::Status StopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopProgramRes>> AsyncStopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopProgramRes>>(AsyncStopProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopProgramRes>> PrepareAsyncStopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopProgramRes>>(PrepareAsyncStopProgramRaw(context, request, cq));
    }
    ::grpc::Status PauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PauseProgramRes>> AsyncPauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PauseProgramRes>>(AsyncPauseProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PauseProgramRes>> PrepareAsyncPauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PauseProgramRes>>(PrepareAsyncPauseProgramRaw(context, request, cq));
    }
    ::grpc::Status SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetDORaw(context, request, cq));
    }
    ::grpc::Status SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetAORaw(context, request, cq));
    }
    ::grpc::Status SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetEndDORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetEndDORaw(context, request, cq));
    }
    ::grpc::Status SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetEndAORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetEndAORaw(context, request, cq));
    }
    ::grpc::Status SetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetToolListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetToolListRaw(context, request, cq));
    }
    ::grpc::Status GetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::ToolList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ToolList>> AsyncGetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ToolList>>(AsyncGetToolListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ToolList>> PrepareAsyncGetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ToolList>>(PrepareAsyncGetToolListRaw(context, request, cq));
    }
    ::grpc::Status SetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetDIConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetDIConfigListRaw(context, request, cq));
    }
    ::grpc::Status GetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::DIConfigList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DIConfigList>> AsyncGetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DIConfigList>>(AsyncGetDIConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DIConfigList>> PrepareAsyncGetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DIConfigList>>(PrepareAsyncGetDIConfigListRaw(context, request, cq));
    }
    ::grpc::Status SetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetDOConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetDOConfigListRaw(context, request, cq));
    }
    ::grpc::Status GetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::DOConfigList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DOConfigList>> AsyncGetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DOConfigList>>(AsyncGetDOConfigListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DOConfigList>> PrepareAsyncGetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DOConfigList>>(PrepareAsyncGetDOConfigListRaw(context, request, cq));
    }
    ::grpc::Status SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCollSensLevelRaw(context, request, cq));
    }
    ::grpc::Status GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>> AsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>>(AsyncGetCollSensLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>> PrepareAsyncGetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>>(PrepareAsyncGetCollSensLevelRaw(context, request, cq));
    }
    ::grpc::Status SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCollPolicyRaw(context, request, cq));
    }
    ::grpc::Status GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionPolicy>> AsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionPolicy>>(AsyncGetCollPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionPolicy>> PrepareAsyncGetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionPolicy>>(PrepareAsyncGetCollPolicyRaw(context, request, cq));
    }
    ::grpc::Status SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetCollSensParamRaw(context, request, cq));
    }
    ::grpc::Status GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> AsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(AsyncGetCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> PrepareAsyncGetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(PrepareAsyncGetCollSensParamRaw(context, request, cq));
    }
    ::grpc::Status InitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncInitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncInitCollSensParamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncInitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncInitCollSensParamRaw(context, request, cq));
    }
    ::grpc::Status PlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> AsyncPlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(AsyncPlayTuningProgramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>> PrepareAsyncPlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>>(PrepareAsyncPlayTuningProgramRaw(context, request, cq));
    }
    ::grpc::Status GetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpDevice>> AsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpDevice>>(AsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpDevice>> PrepareAsyncGetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpDevice>>(PrepareAsyncGetTeleOpDeviceRaw(context, request, cq));
    }
    ::grpc::Status GetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpState>> AsyncGetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpState>>(AsyncGetTeleOpStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpState>> PrepareAsyncGetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpState>>(PrepareAsyncGetTeleOpStateRaw(context, request, cq));
    }
    ::grpc::Status ConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncConnectTeleOpDeviceRaw(context, request, cq));
    }
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncDisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncDisConnectTeleOpDeviceRaw(context, request, cq));
    }
    ::grpc::Status ReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleP* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleP>> AsyncReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleP>>(AsyncReadTeleOpInputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleP>> PrepareAsyncReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleP>>(PrepareAsyncReadTeleOpInputRaw(context, request, cq));
    }
    ::grpc::Status StartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleCalibRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleCalibRaw(context, request, cq));
    }
    ::grpc::Status StartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleRecordRaw(context, request, cq));
    }
    ::grpc::Status StartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTelePlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTelePlayRaw(context, request, cq));
    }
    ::grpc::Status StartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleJogLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleJogLRaw(context, request, cq));
    }
    ::grpc::Status StartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncStartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStartTeleJogJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStartTeleJogJRaw(context, request, cq));
    }
    ::grpc::Status StopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncStopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncStopTeleOpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncStopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncStopTeleOpRaw(context, request, cq));
    }
    ::grpc::Status SetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetPlayRateRaw(context, request, cq));
    }
    ::grpc::Status GetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TelePlayRate>> AsyncGetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TelePlayRate>>(AsyncGetPlayRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TelePlayRate>> PrepareAsyncGetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TelePlayRate>>(PrepareAsyncGetPlayRateRaw(context, request, cq));
    }
    ::grpc::Status GetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpFileList>> AsyncGetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpFileList>>(AsyncGetTeleFileListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpFileList>> PrepareAsyncGetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpFileList>>(PrepareAsyncGetTeleFileListRaw(context, request, cq));
    }
    ::grpc::Status SaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSaveTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSaveTeleMotionRaw(context, request, cq));
    }
    ::grpc::Status LoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncLoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncLoadTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncLoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncLoadTeleMotionRaw(context, request, cq));
    }
    ::grpc::Status DeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncDeleteTeleMotionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncDeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncDeleteTeleMotionRaw(context, request, cq));
    }
    ::grpc::Status MoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncMoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncMoveTeleJRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncMoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncMoveTeleJRaw(context, request, cq));
    }
    ::grpc::Status MoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncMoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncMoveTeleLRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncMoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncMoveTeleLRaw(context, request, cq));
    }
    ::grpc::Status SetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetTeleOpParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetTeleOpParamsRaw(context, request, cq));
    }
    ::grpc::Status GetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpParams>> AsyncGetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpParams>>(AsyncGetTeleOpParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpParams>> PrepareAsyncGetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpParams>>(PrepareAsyncGetTeleOpParamsRaw(context, request, cq));
    }
    ::grpc::Status SetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetFTSensorConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetFTSensorConfigRaw(context, request, cq));
    }
    ::grpc::Status GetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorDevice>> AsyncGetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorDevice>>(AsyncGetFTSensorConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorDevice>> PrepareAsyncGetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorDevice>>(PrepareAsyncGetFTSensorConfigRaw(context, request, cq));
    }
    ::grpc::Status GetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::FTSensorData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorData>> AsyncGetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorData>>(AsyncGetFTSensorDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorData>> PrepareAsyncGetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorData>>(PrepareAsyncGetFTSensorDataRaw(context, request, cq));
    }
    ::grpc::Status GetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>> AsyncGetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>>(AsyncGetLoadFactorsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>> PrepareAsyncGetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>>(PrepareAsyncGetLoadFactorsRaw(context, request, cq));
    }
    ::grpc::Status SetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSanderCommandRaw(context, request, cq));
    }
    ::grpc::Status GetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SanderCommand* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SanderCommand>> AsyncGetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SanderCommand>>(AsyncGetSanderCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SanderCommand>> PrepareAsyncGetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SanderCommand>>(PrepareAsyncGetSanderCommandRaw(context, request, cq));
    }
    ::grpc::Status SetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSandingStopConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSandingStopConditionRaw(context, request, cq));
    }
    ::grpc::Status GetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>> AsyncGetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>>(AsyncGetSandingStopConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>> PrepareAsyncGetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>>(PrepareAsyncGetSandingStopConditionRaw(context, request, cq));
    }
    ::grpc::Status GetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::GripperData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GripperData>> AsyncGetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GripperData>>(AsyncGetGripperDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GripperData>> PrepareAsyncGetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GripperData>>(PrepareAsyncGetGripperDataRaw(context, request, cq));
    }
    ::grpc::Status SetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::IndyFramework::Protobuf::HRI::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> AsyncSetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncSetGripperCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncSetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncSetGripperCommandRaw(context, request, cq));
    }
    ::grpc::Status SetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSFDActivateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSFDActivateRaw(context, request, cq));
    }
    ::grpc::Status IsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::State* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>> AsyncIsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>>(AsyncIsSFDActivateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>> PrepareAsyncIsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>>(PrepareAsyncIsSFDActivateRaw(context, request, cq));
    }
    ::grpc::Status SFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSFDLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSFDLoginRaw(context, request, cq));
    }
    ::grpc::Status IsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::State* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>> AsyncIsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>>(AsyncIsSFDLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>> PrepareAsyncIsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>>(PrepareAsyncIsSFDLoginRaw(context, request, cq));
    }
    ::grpc::Status SetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSFDTargetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSFDTargetRaw(context, request, cq));
    }
    ::grpc::Status SetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::IndyFramework::Protobuf::HRI::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> AsyncSetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(AsyncSetSFDOptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>> PrepareAsyncSetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>>(PrepareAsyncSetSFDOptionRaw(context, request, cq));
    }
    ::grpc::Status GetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDProjectList>> AsyncGetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDProjectList>>(AsyncGetSFDProjListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDProjectList>> PrepareAsyncGetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDProjectList>>(PrepareAsyncGetSFDProjListRaw(context, request, cq));
    }
    ::grpc::Status GetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::SFDCriData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDCriData>> AsyncGetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDCriData>>(AsyncGetSFDCRIRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDCriData>> PrepareAsyncGetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDCriData>>(PrepareAsyncGetSFDCRIRaw(context, request, cq));
    }
    ::grpc::Status GetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::IndyFramework::Protobuf::HRI::TactTime* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TactTime>> AsyncGetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TactTime>>(AsyncGetTactTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TactTime>> PrepareAsyncGetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TactTime>>(PrepareAsyncGetTactTimeRaw(context, request, cq));
    }
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::IndyFramework::Protobuf::HRI::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> AsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(AsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>> PrepareAsyncAddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>>(PrepareAsyncAddPhotoneoCalibPointRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq* request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response, std::function<void(::grpc::Status)>) override;
      void ContyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq* request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::RobotData* response, std::function<void(::grpc::Status)>) override;
      void RobotUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::RobotData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, std::function<void(::grpc::Status)>) override;
      void ProgramUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ControlData* response, std::function<void(::grpc::Status)>) override;
      void ControlUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ControlData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::LinearData* response, std::function<void(::grpc::Status)>) override;
      void LinearUpdate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::LinearData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void JogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq* request, ::IndyFramework::Protobuf::HRI::JogJointRes* response, std::function<void(::grpc::Status)>) override;
      void JogJoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq* request, ::IndyFramework::Protobuf::HRI::JogJointRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void JogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq* request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response, std::function<void(::grpc::Status)>) override;
      void JogTask(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq* request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void JogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq* request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response, std::function<void(::grpc::Status)>) override;
      void JogAxis(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq* request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) override;
      void HoldToMoveJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) override;
      void HoldToMoveL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) override;
      void HoldToAxisJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq* request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response, std::function<void(::grpc::Status)>) override;
      void StopMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq* request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response, std::function<void(::grpc::Status)>) override;
      void SetRefFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response, std::function<void(::grpc::Status)>) override;
      void SetRefFramePlanar(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response, std::function<void(::grpc::Status)>) override;
      void SetToolFrame(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response, std::function<void(::grpc::Status)>) override;
      void SetSpeedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response, std::function<void(::grpc::Status)>) override;
      void SetSimulationMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, std::function<void(::grpc::Status)>) override;
      void SetDirectTeachingMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::IntMode* response, std::function<void(::grpc::Status)>) override;
      void GetCustomControlMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::IntMode* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response, std::function<void(::grpc::Status)>) override;
      void SetSensorlessComplianceMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response, std::function<void(::grpc::Status)>) override;
      void GetBrakeControlStyle(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response, std::function<void(::grpc::Status)>) override;
      void SetBrake(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq* request, ::IndyFramework::Protobuf::HRI::SetServoRes* response, std::function<void(::grpc::Status)>) override;
      void SetServo(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq* request, ::IndyFramework::Protobuf::HRI::SetServoRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response, std::function<void(::grpc::Status)>) override;
      void SetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response, std::function<void(::grpc::Status)>) override;
      void GetAutoServoOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void ExecuteTool(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response, std::function<void(::grpc::Status)>) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateRelativePose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response, std::function<void(::grpc::Status)>) override;
      void CalculateCurrentPoseRel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetManualRecoverMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetServoRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void JogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void JogJointRecover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq* request, ::IndyFramework::Protobuf::HRI::RecoverRes* response, std::function<void(::grpc::Status)>) override;
      void Recover(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq* request, ::IndyFramework::Protobuf::HRI::RecoverRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq* request, ::IndyFramework::Protobuf::HRI::RebootRes* response, std::function<void(::grpc::Status)>) override;
      void Reboot(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq* request, ::IndyFramework::Protobuf::HRI::RebootRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq* request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response, std::function<void(::grpc::Status)>) override;
      void PowerOff(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq* request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateIndySW(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::ClientWriteReactor< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* reactor) override;
      void GetFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetFileRes>* reactor) override;
      void SetFile(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::ClientWriteReactor< ::IndyFramework::Protobuf::HRI::SetFileReq>* reactor) override;
      void RenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq* request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response, std::function<void(::grpc::Status)>) override;
      void RenameFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq* request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response, std::function<void(::grpc::Status)>) override;
      void RemoveFile(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response, std::function<void(::grpc::Status)>) override;
      void GetIndexProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response, std::function<void(::grpc::Status)>) override;
      void GetProgramList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq* request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response, std::function<void(::grpc::Status)>) override;
      void GetLogList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq* request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLogContent(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* reactor) override;
      void GetLogContentList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* reactor) override;
      void GetLog(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq* request, ::grpc::ClientReadReactor< ::IndyFramework::Protobuf::HRI::GetLogRes>* reactor) override;
      void GetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response, std::function<void(::grpc::Status)>) override;
      void GetVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response, std::function<void(::grpc::Status)>) override;
      void GetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response, std::function<void(::grpc::Status)>) override;
      void SetMonitoringVariableList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response, std::function<void(::grpc::Status)>) override;
      void GetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response, std::function<void(::grpc::Status)>) override;
      void SetPalletMakerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response, std::function<void(::grpc::Status)>) override;
      void CheckAproachRetractValid(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response, std::function<void(::grpc::Status)>) override;
      void GetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response, std::function<void(::grpc::Status)>) override;
      void SetPalletPointList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Conveyor* response, std::function<void(::grpc::Status)>) override;
      void GetConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Conveyor* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorByName(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorEncoder(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorTrigger(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorOffset(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorStartingPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorTerminalPose(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ConveyorState* response, std::function<void(::grpc::Status)>) override;
      void GetConveyorState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ConveyorState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void HoldToMoveConveyor(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response, std::function<void(::grpc::Status)>) override;
      void GetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response, std::function<void(::grpc::Status)>) override;
      void SetConveyorList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq* request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response, std::function<void(::grpc::Status)>) override;
      void SetInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq* request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq* request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response, std::function<void(::grpc::Status)>) override;
      void StopInching(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq* request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq* request, ::IndyFramework::Protobuf::HRI::SetArcRes* response, std::function<void(::grpc::Status)>) override;
      void SetArc(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq* request, ::IndyFramework::Protobuf::HRI::SetArcRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq* request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response, std::function<void(::grpc::Status)>) override;
      void SetTouch(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq* request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq* request, ::IndyFramework::Protobuf::HRI::SetGasRes* response, std::function<void(::grpc::Status)>) override;
      void SetGas(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq* request, ::IndyFramework::Protobuf::HRI::SetGasRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response, std::function<void(::grpc::Status)>) override;
      void IsTouched(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response, std::function<void(::grpc::Status)>) override;
      void GetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response, std::function<void(::grpc::Status)>) override;
      void SetVisionServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response, std::function<void(::grpc::Status)>) override;
      void GetVisionObjectList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, std::function<void(::grpc::Status)>) override;
      void GetVisionDetection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, std::function<void(::grpc::Status)>) override;
      void GetVisionRetrieval(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response, std::function<void(::grpc::Status)>) override;
      void GetGcodeMotionList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response, std::function<void(::grpc::Status)>) override;
      void GetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response, std::function<void(::grpc::Status)>) override;
      void SetModbusServerList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response, std::function<void(::grpc::Status)>) override;
      void CheckModbusConnection(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response, std::function<void(::grpc::Status)>) override;
      void GetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response, std::function<void(::grpc::Status)>) override;
      void SetToolFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response, std::function<void(::grpc::Status)>) override;
      void GetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response, std::function<void(::grpc::Status)>) override;
      void SetRefFrameList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response, std::function<void(::grpc::Status)>) override;
      void GetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response, std::function<void(::grpc::Status)>) override;
      void SetCustomPosList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetJointControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetTaskControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetImpedanceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetForceControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetExtAxisControlGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetSensorlessComplianceControlJointGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) override;
      void SetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, std::function<void(::grpc::Status)>) override;
      void GetSensorlessComplianceControlTaskGain(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response, std::function<void(::grpc::Status)>) override;
      void SetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response, std::function<void(::grpc::Status)>) override;
      void GetFricComp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response, std::function<void(::grpc::Status)>) override;
      void SetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response, std::function<void(::grpc::Status)>) override;
      void GetHomePos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response, std::function<void(::grpc::Status)>) override;
      void SetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response, std::function<void(::grpc::Status)>) override;
      void GetMountPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response, std::function<void(::grpc::Status)>) override;
      void GetPackagingPos(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response, std::function<void(::grpc::Status)>) override;
      void SetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response, std::function<void(::grpc::Status)>) override;
      void GetToolProperty(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response, std::function<void(::grpc::Status)>) override;
      void SetOnStartProgramConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response, std::function<void(::grpc::Status)>) override;
      void SetSafetyLimitConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response, std::function<void(::grpc::Status)>) override;
      void SetSafetyStopConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyConfigHash(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response, std::function<void(::grpc::Status)>) override;
      void GetKinematicsParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response, ::grpc::ClientUnaryReactor* reactor) override;
      void KeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq* request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response, std::function<void(::grpc::Status)>) override;
      void KeyInit(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq* request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void KeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq* request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response, std::function<void(::grpc::Status)>) override;
      void KeyData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq* request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, std::function<void(::grpc::Status)>) override;
      void ProgramUpdateKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, std::function<void(::grpc::Status)>) override;
      void SetDirectTeachingModeKey(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response, std::function<void(::grpc::Status)>) override;
      void GetAutoModeConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response, std::function<void(::grpc::Status)>) override;
      void SetAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response, std::function<void(::grpc::Status)>) override;
      void CheckAutoMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response, std::function<void(::grpc::Status)>) override;
      void CheckReducedMode(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response, std::function<void(::grpc::Status)>) override;
      void GetReducedRatio(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response, std::function<void(::grpc::Status)>) override;
      void GetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetReducedSpeed(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::StopState* response, std::function<void(::grpc::Status)>) override;
      void GetStopState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::StopState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response, std::function<void(::grpc::Status)>) override;
      void GetSafetyFunctionState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void RequestSafetyFunction(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response, std::function<void(::grpc::Status)>) override;
      void PlayProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response, std::function<void(::grpc::Status)>) override;
      void PlayIndexProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response, std::function<void(::grpc::Status)>) override;
      void PlayProgramLine(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response, std::function<void(::grpc::Status)>) override;
      void ResumeProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq* request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response, std::function<void(::grpc::Status)>) override;
      void StopProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq* request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response, std::function<void(::grpc::Status)>) override;
      void PauseProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetEndDO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetEndAO(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ToolList* response, std::function<void(::grpc::Status)>) override;
      void GetToolList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ToolList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DIConfigList* response, std::function<void(::grpc::Status)>) override;
      void GetDIConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DIConfigList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DOConfigList* response, std::function<void(::grpc::Status)>) override;
      void GetDOConfigList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DOConfigList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response, std::function<void(::grpc::Status)>) override;
      void GetCollSensLevel(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response, std::function<void(::grpc::Status)>) override;
      void GetCollPolicy(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, std::function<void(::grpc::Status)>) override;
      void GetCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void InitCollSensParam(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, std::function<void(::grpc::Status)>) override;
      void PlayTuningProgram(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response, std::function<void(::grpc::Status)>) override;
      void GetTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpState* response, std::function<void(::grpc::Status)>) override;
      void GetTeleOpState(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void ConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void DisConnectTeleOpDevice(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleP* response, std::function<void(::grpc::Status)>) override;
      void ReadTeleOpInput(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleP* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void StartTeleCalib(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void StartTeleRecord(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void StartTelePlay(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void StartTeleJogL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void StartTeleJogJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void StopTeleOp(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response, std::function<void(::grpc::Status)>) override;
      void GetPlayRate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response, std::function<void(::grpc::Status)>) override;
      void GetTeleFileList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SaveTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void LoadTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void DeleteTeleMotion(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveTeleJ(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void MoveTeleL(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response, std::function<void(::grpc::Status)>) override;
      void GetTeleOpParams(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response, std::function<void(::grpc::Status)>) override;
      void GetFTSensorConfig(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorData* response, std::function<void(::grpc::Status)>) override;
      void GetFTSensorData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response, std::function<void(::grpc::Status)>) override;
      void GetLoadFactors(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SanderCommand* response, std::function<void(::grpc::Status)>) override;
      void GetSanderCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SanderCommand* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response, std::function<void(::grpc::Status)>) override;
      void GetSandingStopCondition(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GripperData* response, std::function<void(::grpc::Status)>) override;
      void GetGripperData(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GripperData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetGripperCommand(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, std::function<void(::grpc::Status)>) override;
      void IsSFDActivate(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void IsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, std::function<void(::grpc::Status)>) override;
      void IsSFDLogin(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetSFDTarget(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, std::function<void(::grpc::Status)>) override;
      void SetSFDOption(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response, std::function<void(::grpc::Status)>) override;
      void GetSFDProjList(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDCriData* response, std::function<void(::grpc::Status)>) override;
      void GetSFDCRI(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDCriData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TactTime* response, std::function<void(::grpc::Status)>) override;
      void GetTactTime(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TactTime* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, std::function<void(::grpc::Status)>) override;
      void AddPhotoneoCalibPoint(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* request, ::IndyFramework::Protobuf::HRI::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ContyInitRes>* AsyncContyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ContyInitRes>* PrepareAsyncContyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RobotData>* AsyncRobotUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RobotData>* PrepareAsyncRobotUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>* AsyncProgramUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>* PrepareAsyncProgramUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ControlData>* AsyncControlUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ControlData>* PrepareAsyncControlUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::LinearData>* AsyncLinearUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::LinearData>* PrepareAsyncLinearUpdateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogJointRes>* AsyncJogJointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogJointRes>* PrepareAsyncJogJointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogTaskRes>* AsyncJogTaskRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogTaskRes>* PrepareAsyncJogTaskRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogAxisRes>* AsyncJogAxisRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::JogAxisRes>* PrepareAsyncJogAxisRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* AsyncHoldToMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncHoldToMoveJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* AsyncHoldToMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncHoldToMoveLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* AsyncHoldToAxisJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncHoldToAxisJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopMotionRes>* AsyncStopMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopMotionRes>* PrepareAsyncStopMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>* AsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>* PrepareAsyncSetRefFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* AsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* PrepareAsyncSetRefFramePlanarRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>* AsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>* PrepareAsyncSetToolFrameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* AsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* PrepareAsyncSetSpeedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* AsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* PrepareAsyncSetSimulationModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* AsyncSetDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* PrepareAsyncSetDirectTeachingModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IntMode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IntMode>* AsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IntMode>* PrepareAsyncGetCustomControlModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* AsyncSetSensorlessComplianceModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* PrepareAsyncSetSensorlessComplianceModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>* AsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>* PrepareAsyncGetBrakeControlStyleRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetBrakeRes>* AsyncSetBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetBrakeRes>* PrepareAsyncSetBrakeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetServoRes>* AsyncSetServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetServoRes>* PrepareAsyncSetServoRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* AsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* PrepareAsyncSetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* AsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* PrepareAsyncGetAutoServoOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncExecuteToolRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncExecuteToolRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* AsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* PrepareAsyncCalculateRelativePoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* AsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* PrepareAsyncCalculateCurrentPoseRelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetManualRecoverModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetManualRecoverModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetServoRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetServoRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Servo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncJogJointRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncJogJointRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RecoverRes>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RecoverRes>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RebootRes>* AsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RebootRes>* PrepareAsyncRebootRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PowerOffRes>* AsyncPowerOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PowerOffRes>* PrepareAsyncPowerOffRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* UpdateIndySWRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response) override;
    ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* AsyncUpdateIndySWRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* PrepareAsyncUpdateIndySWRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetFileRes>* GetFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetFileRes>* AsyncGetFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetFileRes>* PrepareAsyncGetFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>* SetFileRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response) override;
    ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>* AsyncSetFileRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::IndyFramework::Protobuf::HRI::SetFileReq>* PrepareAsyncSetFileRaw(::grpc::ClientContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RenameFileRes>* AsyncRenameFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RenameFileRes>* PrepareAsyncRenameFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RemoveFileRes>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::RemoveFileRes>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* AsyncGetIndexProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* PrepareAsyncGetIndexProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetProgramListRes>* AsyncGetProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetProgramListRes>* PrepareAsyncGetProgramListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLogListRes>* AsyncGetLogListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLogListRes>* PrepareAsyncGetLogListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* GetLogContentRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* AsyncGetLogContentRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* PrepareAsyncGetLogContentRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* GetLogContentListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* AsyncGetLogContentListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* PrepareAsyncGetLogContentListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::IndyFramework::Protobuf::HRI::GetLogRes>* GetLogRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogRes>* AsyncGetLogRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::IndyFramework::Protobuf::HRI::GetLogRes>* PrepareAsyncGetLogRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVariableListRes>* AsyncGetVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVariableListRes>* PrepareAsyncGetVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* AsyncGetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* PrepareAsyncGetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* AsyncSetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* PrepareAsyncSetMonitoringVariableListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* AsyncGetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* PrepareAsyncGetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* AsyncSetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* PrepareAsyncSetPalletMakerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* AsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* PrepareAsyncCheckAproachRetractValidRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* AsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* PrepareAsyncGetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* AsyncSetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* PrepareAsyncSetPalletPointListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Conveyor>* AsyncGetConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Conveyor>* PrepareAsyncGetConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorByNameRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Name& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorEncoderRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Encoder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorTriggerRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Trigger& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorOffsetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Float& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorStartingPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetConveyorTerminalPoseRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PosePair& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ConveyorState>* AsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ConveyorState>* PrepareAsyncGetConveyorStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncHoldToMoveConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncHoldToMoveConveyorRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>* AsyncGetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>* PrepareAsyncGetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>* AsyncSetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>* PrepareAsyncSetConveyorListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetInchingRes>* AsyncSetInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetInchingRes>* PrepareAsyncSetInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopInchingRes>* AsyncStopInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopInchingRes>* PrepareAsyncStopInchingRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetArcRes>* AsyncSetArcRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetArcRes>* PrepareAsyncSetArcRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTouchRes>* AsyncSetTouchRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTouchRes>* PrepareAsyncSetTouchRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetGasRes>* AsyncSetGasRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetGasRes>* PrepareAsyncSetGasRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IsTouchedRes>* AsyncIsTouchedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::IsTouchedRes>* PrepareAsyncIsTouchedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* AsyncGetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* PrepareAsyncGetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* AsyncSetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* PrepareAsyncSetVisionServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* AsyncGetVisionObjectListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* PrepareAsyncGetVisionObjectListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>* AsyncGetVisionDetectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>* PrepareAsyncGetVisionDetectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>* AsyncGetVisionRetrievalRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::VisionResult>* PrepareAsyncGetVisionRetrievalRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* AsyncGetGcodeMotionListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* PrepareAsyncGetGcodeMotionListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* AsyncGetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* PrepareAsyncGetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* AsyncSetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* PrepareAsyncSetModbusServerListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* AsyncCheckModbusConnectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* PrepareAsyncCheckModbusConnectionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* AsyncGetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* PrepareAsyncGetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* AsyncSetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* PrepareAsyncSetToolFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* AsyncGetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* PrepareAsyncGetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* AsyncSetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* PrepareAsyncSetRefFrameListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* AsyncGetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* PrepareAsyncGetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* AsyncSetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* PrepareAsyncSetCustomPosListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* AsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* PrepareAsyncSetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* AsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* PrepareAsyncGetJointControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* AsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* PrepareAsyncSetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* AsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* PrepareAsyncGetTaskControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* AsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* PrepareAsyncSetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* AsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* PrepareAsyncGetImpedanceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* AsyncSetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* PrepareAsyncSetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* AsyncGetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* PrepareAsyncGetForceControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* AsyncSetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* PrepareAsyncSetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* AsyncGetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* PrepareAsyncGetExtAxisControlGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* AsyncSetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* PrepareAsyncSetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* AsyncGetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* PrepareAsyncGetSensorlessComplianceControlJointGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* AsyncSetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* PrepareAsyncSetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* AsyncGetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* PrepareAsyncGetSensorlessComplianceControlTaskGainRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetFricCompRes>* AsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetFricCompRes>* PrepareAsyncSetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetFricCompRes>* AsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetFricCompRes>* PrepareAsyncGetFricCompRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetHomePosRes>* AsyncSetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetHomePosRes>* PrepareAsyncSetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetHomePosRes>* AsyncGetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetHomePosRes>* PrepareAsyncGetHomePosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMountPosRes>* AsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetMountPosRes>* PrepareAsyncSetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMountPosRes>* AsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetMountPosRes>* PrepareAsyncGetMountPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* AsyncGetPackagingPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* PrepareAsyncGetPackagingPosRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* AsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* PrepareAsyncSetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* AsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* PrepareAsyncGetToolPropertyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* AsyncGetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* PrepareAsyncGetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* AsyncSetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* PrepareAsyncSetOnStartProgramConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* AsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* PrepareAsyncGetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* AsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* PrepareAsyncSetSafetyLimitConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* AsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* PrepareAsyncGetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* AsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* PrepareAsyncSetSafetyStopConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* AsyncGetSafetyConfigHashRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* PrepareAsyncGetSafetyConfigHashRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KinematicsParams>* AsyncGetKinematicsParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KinematicsParams>* PrepareAsyncGetKinematicsParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyInitRes>* AsyncKeyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyInitRes>* PrepareAsyncKeyInitRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyDataRes>* AsyncKeyDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::KeyDataRes>* PrepareAsyncKeyDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>* AsyncProgramUpdateKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ProgramData>* PrepareAsyncProgramUpdateKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* AsyncSetDirectTeachingModeKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* PrepareAsyncSetDirectTeachingModeKeyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* AsyncGetAutoModeConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* PrepareAsyncGetAutoModeConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>* AsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>* PrepareAsyncSetAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* AsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* PrepareAsyncCheckAutoModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* AsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* PrepareAsyncCheckReducedModeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* AsyncGetReducedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* PrepareAsyncGetReducedRatioRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* AsyncGetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* PrepareAsyncGetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetReducedSpeedRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopState>* AsyncGetStopStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopState>* PrepareAsyncGetStopStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>* AsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>* PrepareAsyncGetSafetyFunctionStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncRequestSafetyFunctionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramRes>* AsyncPlayProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramRes>* PrepareAsyncPlayProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* AsyncPlayIndexProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* PrepareAsyncPlayIndexProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* AsyncPlayProgramLineRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* PrepareAsyncPlayProgramLineRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>* AsyncResumeProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>* PrepareAsyncResumeProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopProgramRes>* AsyncStopProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::StopProgramRes>* PrepareAsyncStopProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PauseProgramRes>* AsyncPauseProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::PauseProgramRes>* PrepareAsyncPauseProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetEndDORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetEndAORaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::ToolList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ToolList>* AsyncGetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::ToolList>* PrepareAsyncGetToolListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DIConfigList>* AsyncGetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DIConfigList>* PrepareAsyncGetDIConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DOConfigList>* AsyncGetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::DOConfigList>* PrepareAsyncGetDOConfigListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>* AsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>* PrepareAsyncGetCollSensLevelRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionPolicy>* AsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionPolicy>* PrepareAsyncGetCollPolicyRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* AsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* PrepareAsyncGetCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncInitCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncInitCollSensParamRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* AsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* PrepareAsyncPlayTuningProgramRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpDevice>* AsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpDevice>* PrepareAsyncGetTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpState>* AsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpState>* PrepareAsyncGetTeleOpStateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncDisConnectTeleOpDeviceRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleP>* AsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleP>* PrepareAsyncReadTeleOpInputRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleCalibRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleCalibRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleRecordRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleRecordRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTelePlayRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTelePlayRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleJogLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleJogLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncStartTeleJogJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStartTeleJogJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncStopTeleOpRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TelePlayRate>* AsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TelePlayRate>* PrepareAsyncGetPlayRateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpFileList>* AsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpFileList>* PrepareAsyncGetTeleFileListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSaveTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncLoadTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncDeleteTeleMotionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncMoveTeleJRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncMoveTeleLRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpParams>* AsyncGetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TeleOpParams>* PrepareAsyncGetTeleOpParamsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorDevice>* AsyncGetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorDevice>* PrepareAsyncGetFTSensorConfigRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorData>* AsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::FTSensorData>* PrepareAsyncGetFTSensorDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* AsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* PrepareAsyncGetLoadFactorsRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SanderCommand>* AsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SanderCommand>* PrepareAsyncGetSanderCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>* AsyncGetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>* PrepareAsyncGetSandingStopConditionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GripperData>* AsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::GripperData>* PrepareAsyncGetGripperDataRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* AsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncSetGripperCommandRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>* AsyncIsSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>* PrepareAsyncIsSFDActivateRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>* AsyncIsSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::State>* PrepareAsyncIsSFDLoginRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSFDTargetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSFDTargetRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* AsyncSetSFDOptionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Response>* PrepareAsyncSetSFDOptionRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::State& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDProjectList>* AsyncGetSFDProjListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDProjectList>* PrepareAsyncGetSFDProjListRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDCriData>* AsyncGetSFDCRIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::SFDCriData>* PrepareAsyncGetSFDCRIRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TactTime>* AsyncGetTactTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::TactTime>* PrepareAsyncGetTactTimeRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* AsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::IndyFramework::Protobuf::HRI::Empty>* PrepareAsyncAddPhotoneoCalibPointRaw(::grpc::ClientContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ContyInit_;
    const ::grpc::internal::RpcMethod rpcmethod_RobotUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_ProgramUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_ControlUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_LinearUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_JogJoint_;
    const ::grpc::internal::RpcMethod rpcmethod_JogTask_;
    const ::grpc::internal::RpcMethod rpcmethod_JogAxis_;
    const ::grpc::internal::RpcMethod rpcmethod_HoldToMoveJ_;
    const ::grpc::internal::RpcMethod rpcmethod_HoldToMoveL_;
    const ::grpc::internal::RpcMethod rpcmethod_HoldToAxisJ_;
    const ::grpc::internal::RpcMethod rpcmethod_StopMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRefFrame_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRefFramePlanar_;
    const ::grpc::internal::RpcMethod rpcmethod_SetToolFrame_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSpeedRatio_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSimulationMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDirectTeachingMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCustomControlMode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCustomControlMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSensorlessComplianceMode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBrakeControlStyle_;
    const ::grpc::internal::RpcMethod rpcmethod_SetBrake_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServo_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAutoServoOff_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAutoServoOff_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteTool_;
    const ::grpc::internal::RpcMethod rpcmethod_InverseKinematics_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateRelativePose_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateCurrentPoseRel_;
    const ::grpc::internal::RpcMethod rpcmethod_SetManualRecoverMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SetServoRecover_;
    const ::grpc::internal::RpcMethod rpcmethod_JogJointRecover_;
    const ::grpc::internal::RpcMethod rpcmethod_Recover_;
    const ::grpc::internal::RpcMethod rpcmethod_Reboot_;
    const ::grpc::internal::RpcMethod rpcmethod_PowerOff_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateIndySW_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFile_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFile_;
    const ::grpc::internal::RpcMethod rpcmethod_RenameFile_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveFile_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIndexProgramList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProgramList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLogList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLogContent_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLogContentList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLog_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVariableList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMonitoringVariableList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMonitoringVariableList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPalletMakerList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPalletMakerList_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckAproachRetractValid_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPalletPointList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPalletPointList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConveyor_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorName_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorByName_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorEncoder_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorTrigger_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorStartingPose_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorTerminalPose_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConveyorState_;
    const ::grpc::internal::RpcMethod rpcmethod_HoldToMoveConveyor_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConveyorList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetConveyorList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetInching_;
    const ::grpc::internal::RpcMethod rpcmethod_StopInching_;
    const ::grpc::internal::RpcMethod rpcmethod_SetArc_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTouch_;
    const ::grpc::internal::RpcMethod rpcmethod_SetGas_;
    const ::grpc::internal::RpcMethod rpcmethod_IsTouched_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVisionServerList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVisionServerList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVisionObjectList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVisionDetection_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVisionRetrieval_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGcodeMotionList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModbusServerList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetModbusServerList_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckModbusConnection_;
    const ::grpc::internal::RpcMethod rpcmethod_GetToolFrameList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetToolFrameList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRefFrameList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRefFrameList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCustomPosList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCustomPosList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetJointControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTaskControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTaskControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetImpedanceControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetImpedanceControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetForceControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetForceControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetExtAxisControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExtAxisControlGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSensorlessComplianceControlJointGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSensorlessComplianceControlJointGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSensorlessComplianceControlTaskGain_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSensorlessComplianceControlTaskGain_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFricComp_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFricComp_;
    const ::grpc::internal::RpcMethod rpcmethod_SetHomePos_;
    const ::grpc::internal::RpcMethod rpcmethod_GetHomePos_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMountPos_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMountPos_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPackagingPos_;
    const ::grpc::internal::RpcMethod rpcmethod_SetToolProperty_;
    const ::grpc::internal::RpcMethod rpcmethod_GetToolProperty_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOnStartProgramConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_SetOnStartProgramConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyLimitConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSafetyLimitConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyStopConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSafetyStopConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyConfigHash_;
    const ::grpc::internal::RpcMethod rpcmethod_GetKinematicsParams_;
    const ::grpc::internal::RpcMethod rpcmethod_KeyInit_;
    const ::grpc::internal::RpcMethod rpcmethod_KeyData_;
    const ::grpc::internal::RpcMethod rpcmethod_ProgramUpdateKey_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDirectTeachingModeKey_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAutoModeConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAutoMode_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckAutoMode_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckReducedMode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetReducedRatio_;
    const ::grpc::internal::RpcMethod rpcmethod_GetReducedSpeed_;
    const ::grpc::internal::RpcMethod rpcmethod_SetReducedSpeed_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStopState_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSafetyFunctionState_;
    const ::grpc::internal::RpcMethod rpcmethod_RequestSafetyFunction_;
    const ::grpc::internal::RpcMethod rpcmethod_PlayProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_PlayIndexProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_PlayProgramLine_;
    const ::grpc::internal::RpcMethod rpcmethod_ResumeProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_StopProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndDO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEndAO_;
    const ::grpc::internal::RpcMethod rpcmethod_SetToolList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetToolList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDIConfigList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDIConfigList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDOConfigList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDOConfigList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCollSensLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollSensLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCollPolicy_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollPolicy_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCollSensParam_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollSensParam_;
    const ::grpc::internal::RpcMethod rpcmethod_InitCollSensParam_;
    const ::grpc::internal::RpcMethod rpcmethod_PlayTuningProgram_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTeleOpDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTeleOpState_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectTeleOpDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_DisConnectTeleOpDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadTeleOpInput_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTeleCalib_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTeleRecord_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTelePlay_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTeleJogL_;
    const ::grpc::internal::RpcMethod rpcmethod_StartTeleJogJ_;
    const ::grpc::internal::RpcMethod rpcmethod_StopTeleOp_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPlayRate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayRate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTeleFileList_;
    const ::grpc::internal::RpcMethod rpcmethod_SaveTeleMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadTeleMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteTeleMotion_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveTeleJ_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveTeleL_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTeleOpParams_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTeleOpParams_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFTSensorConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFTSensorConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFTSensorData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLoadFactors_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSanderCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSanderCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSandingStopCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSandingStopCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGripperData_;
    const ::grpc::internal::RpcMethod rpcmethod_SetGripperCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSFDActivate_;
    const ::grpc::internal::RpcMethod rpcmethod_IsSFDActivate_;
    const ::grpc::internal::RpcMethod rpcmethod_SFDLogin_;
    const ::grpc::internal::RpcMethod rpcmethod_IsSFDLogin_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSFDTarget_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSFDOption_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSFDProjList_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSFDCRI_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTactTime_;
    const ::grpc::internal::RpcMethod rpcmethod_AddPhotoneoCalibPoint_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ContyInit(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq* request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response);
    virtual ::grpc::Status RobotUpdate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::RobotData* response);
    virtual ::grpc::Status ProgramUpdate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response);
    virtual ::grpc::Status ControlUpdate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ControlData* response);
    virtual ::grpc::Status LinearUpdate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::LinearData* response);
    // ---------------------------------------------------------------- //
    // Robot Control
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status JogJoint(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq* request, ::IndyFramework::Protobuf::HRI::JogJointRes* response);
    virtual ::grpc::Status JogTask(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq* request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response);
    virtual ::grpc::Status JogAxis(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq* request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response);
    //  rpc HoldToMoveJ(HoldToMoveJReq) returns (HoldToMoveJRes) {}
    //  rpc HoldToMoveL(HoldToMoveLReq) returns (HoldToMoveLRes) {}
    //  rpc HoldToAxisJ(HoldToAxisJReq) returns (HoldToAxisJRes) {}
    //
    virtual ::grpc::Status HoldToMoveJ(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response);
    virtual ::grpc::Status HoldToMoveL(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq* request, ::IndyFramework::Protobuf::HRI::Empty* response);
    virtual ::grpc::Status HoldToAxisJ(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response);
    virtual ::grpc::Status StopMotion(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq* request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response);
    virtual ::grpc::Status SetRefFrame(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response);
    virtual ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response);
    virtual ::grpc::Status SetToolFrame(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response);
    virtual ::grpc::Status SetSpeedRatio(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response);
    virtual ::grpc::Status SetSimulationMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response);
    virtual ::grpc::Status SetDirectTeachingMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response);
    virtual ::grpc::Status SetCustomControlMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::IntMode* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetCustomControlMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::IntMode* response);
    virtual ::grpc::Status SetSensorlessComplianceMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response);
    virtual ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response);
    virtual ::grpc::Status SetBrake(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response);
    virtual ::grpc::Status SetServo(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq* request, ::IndyFramework::Protobuf::HRI::SetServoRes* response);
    virtual ::grpc::Status SetAutoServoOff(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response);
    virtual ::grpc::Status GetAutoServoOff(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response);
    virtual ::grpc::Status ExecuteTool(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status InverseKinematics(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response);
    virtual ::grpc::Status CalculateRelativePose(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response);
    virtual ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response);
    // ---------------------------------------------------------------- //
    // Violation Recovery
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetManualRecoverMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetServoRecover(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Servo* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status JogJointRecover(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status Recover(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq* request, ::IndyFramework::Protobuf::HRI::RecoverRes* response);
    virtual ::grpc::Status Reboot(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq* request, ::IndyFramework::Protobuf::HRI::RebootRes* response);
    virtual ::grpc::Status PowerOff(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq* request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response);
    // ---------------------------------------------------------------- //
    // Common
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status UpdateIndySW(::grpc::ServerContext* context, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* reader, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response);
    virtual ::grpc::Status GetFile(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq* request, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* writer);
    virtual ::grpc::Status SetFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::SetFileReq>* reader, ::IndyFramework::Protobuf::HRI::SetFileRes* response);
    virtual ::grpc::Status RenameFile(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq* request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response);
    virtual ::grpc::Status RemoveFile(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response);
    virtual ::grpc::Status GetIndexProgramList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response);
    virtual ::grpc::Status GetProgramList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response);
    virtual ::grpc::Status GetLogList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq* request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response);
    virtual ::grpc::Status GetLogContent(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* request, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* writer);
    virtual ::grpc::Status GetLogContentList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* request, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* writer);
    virtual ::grpc::Status GetLog(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq* request, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* writer);
    // ---------------------------------------------------------------- //
    // Config
    // ---------------------------------------------------------------- //
    //
    virtual ::grpc::Status GetVariableList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response);
    virtual ::grpc::Status GetMonitoringVariableList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response);
    virtual ::grpc::Status SetMonitoringVariableList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response);
    virtual ::grpc::Status GetPalletMakerList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response);
    virtual ::grpc::Status SetPalletMakerList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response);
    virtual ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response);
    virtual ::grpc::Status GetPalletPointList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response);
    virtual ::grpc::Status SetPalletPointList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response);
    virtual ::grpc::Status GetConveyor(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Conveyor* response);
    virtual ::grpc::Status SetConveyorName(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetConveyorByName(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Encoder* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Trigger* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetConveyorOffset(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Float* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetConveyorState(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ConveyorState* response);
    virtual ::grpc::Status HoldToMoveConveyor(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetConveyorList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response);
    virtual ::grpc::Status SetConveyorList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response);
    virtual ::grpc::Status SetInching(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq* request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response);
    virtual ::grpc::Status StopInching(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq* request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response);
    virtual ::grpc::Status SetArc(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq* request, ::IndyFramework::Protobuf::HRI::SetArcRes* response);
    virtual ::grpc::Status SetTouch(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq* request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response);
    virtual ::grpc::Status SetGas(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq* request, ::IndyFramework::Protobuf::HRI::SetGasRes* response);
    virtual ::grpc::Status IsTouched(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response);
    virtual ::grpc::Status GetVisionServerList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response);
    virtual ::grpc::Status SetVisionServerList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response);
    virtual ::grpc::Status GetVisionObjectList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response);
    virtual ::grpc::Status GetVisionDetection(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response);
    virtual ::grpc::Status GetVisionRetrieval(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response);
    // rpc GetModbusServer(GetModbusServerReq) returns (GetModbusServerRes) {}
    // rpc SetModbusServer(SetModbusServerReq) returns (SetModbusServerRes) {}
    //
    virtual ::grpc::Status GetGcodeMotionList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response);
    virtual ::grpc::Status GetModbusServerList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response);
    virtual ::grpc::Status SetModbusServerList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response);
    virtual ::grpc::Status CheckModbusConnection(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response);
    virtual ::grpc::Status GetToolFrameList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response);
    virtual ::grpc::Status SetToolFrameList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response);
    virtual ::grpc::Status GetRefFrameList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response);
    virtual ::grpc::Status SetRefFrameList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response);
    virtual ::grpc::Status GetCustomPosList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response);
    virtual ::grpc::Status SetCustomPosList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response);
    // ---------------------------------------------------------------- //
    // Robot Config
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetJointControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response);
    virtual ::grpc::Status GetJointControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response);
    virtual ::grpc::Status SetTaskControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response);
    virtual ::grpc::Status GetTaskControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response);
    virtual ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response);
    virtual ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response);
    virtual ::grpc::Status SetForceControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response);
    virtual ::grpc::Status GetForceControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response);
    virtual ::grpc::Status SetExtAxisControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response);
    virtual ::grpc::Status GetExtAxisControlGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response);
    virtual ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response);
    virtual ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response);
    virtual ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response);
    virtual ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response);
    virtual ::grpc::Status SetFricComp(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response);
    virtual ::grpc::Status GetFricComp(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response);
    virtual ::grpc::Status SetHomePos(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response);
    virtual ::grpc::Status GetHomePos(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response);
    virtual ::grpc::Status SetMountPos(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response);
    virtual ::grpc::Status GetMountPos(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response);
    virtual ::grpc::Status GetPackagingPos(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response);
    virtual ::grpc::Status SetToolProperty(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response);
    virtual ::grpc::Status GetToolProperty(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response);
    virtual ::grpc::Status GetOnStartProgramConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response);
    virtual ::grpc::Status SetOnStartProgramConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response);
    virtual ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response);
    virtual ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response);
    virtual ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response);
    virtual ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response);
    virtual ::grpc::Status GetSafetyConfigHash(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response);
    virtual ::grpc::Status GetKinematicsParams(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response);
    // ---------------------------------------------------------------- //
    // IndyKey
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status KeyInit(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq* request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response);
    virtual ::grpc::Status KeyData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq* request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response);
    virtual ::grpc::Status ProgramUpdateKey(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response);
    virtual ::grpc::Status SetDirectTeachingModeKey(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response);
    virtual ::grpc::Status GetAutoModeConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response);
    virtual ::grpc::Status SetAutoMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response);
    virtual ::grpc::Status CheckAutoMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response);
    virtual ::grpc::Status CheckReducedMode(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response);
    virtual ::grpc::Status GetReducedRatio(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response);
    virtual ::grpc::Status GetReducedSpeed(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response);
    virtual ::grpc::Status SetReducedSpeed(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetStopState(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::StopState* response);
    virtual ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response);
    virtual ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* request, ::IndyFramework::Protobuf::HRI::Response* response);
    // ---------------------------------------------------------------- //
    // Program Control
    // ---------------------------------------------------------------- //
    //
    virtual ::grpc::Status PlayProgram(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response);
    virtual ::grpc::Status PlayIndexProgram(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response);
    virtual ::grpc::Status PlayProgramLine(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response);
    virtual ::grpc::Status ResumeProgram(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response);
    virtual ::grpc::Status StopProgram(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq* request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response);
    virtual ::grpc::Status PauseProgram(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response);
    // ---------------------------------------------------------------- //
    // I/O Control
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetDO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetAO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetEndDO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetEndAO(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response);
    // ---------------------------------------------------------------- //
    // Configuration
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetToolList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::ToolList* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetToolList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ToolList* response);
    virtual ::grpc::Status SetDIConfigList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetDIConfigList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DIConfigList* response);
    virtual ::grpc::Status SetDOConfigList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetDOConfigList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DOConfigList* response);
    // ---------------------------------------------------------------- //
    // Collision Detection
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetCollSensLevel(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetCollSensLevel(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response);
    virtual ::grpc::Status SetCollPolicy(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetCollPolicy(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response);
    virtual ::grpc::Status SetCollSensParam(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetCollSensParam(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response);
    virtual ::grpc::Status InitCollSensParam(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status PlayTuningProgram(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response);
    // ---------------------------------------------------------------- //
    // TeleOperation
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response);
    virtual ::grpc::Status GetTeleOpState(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpState* response);
    virtual ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleP* response);
    virtual ::grpc::Status StartTeleCalib(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status StartTeleRecord(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status StartTelePlay(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status StartTeleJogL(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status StartTeleJogJ(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status StopTeleOp(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetPlayRate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetPlayRate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response);
    virtual ::grpc::Status GetTeleFileList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response);
    virtual ::grpc::Status SaveTeleMotion(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status LoadTeleMotion(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status MoveTeleJ(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status MoveTeleL(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetTeleOpParams(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetTeleOpParams(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response);
    // ---------------------------------------------------------------- //
    // Sanding
    // ---------------------------------------------------------------- //
    //
    //  rpc MoveFL(MoveFLReq) returns (MoveFLRes) {}
    //
    virtual ::grpc::Status SetFTSensorConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetFTSensorConfig(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response);
    virtual ::grpc::Status GetFTSensorData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorData* response);
    virtual ::grpc::Status GetLoadFactors(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response);
    virtual ::grpc::Status SetSanderCommand(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetSanderCommand(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SanderCommand* response);
    virtual ::grpc::Status SetSandingStopCondition(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetSandingStopCondition(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response);
    // /////////////485Gripper//////////////////////
    virtual ::grpc::Status GetGripperData(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GripperData* response);
    virtual ::grpc::Status SetGripperCommand(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand* request, ::IndyFramework::Protobuf::HRI::Empty* response);
    // ---------------------------------------------------------------- //
    // Safetics
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status SetSFDActivate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status IsSFDActivate(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response);
    virtual ::grpc::Status SFDLogin(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status IsSFDLogin(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response);
    virtual ::grpc::Status SetSFDTarget(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status SetSFDOption(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response);
    virtual ::grpc::Status GetSFDProjList(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response);
    virtual ::grpc::Status GetSFDCRI(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDCriData* response);
    // /////////////TactTime//////////////////////
    virtual ::grpc::Status GetTactTime(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TactTime* response);
    // ---------------------------------------------------------------- //
    // Photoneo
    // ---------------------------------------------------------------- //
    virtual ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* request, ::IndyFramework::Protobuf::HRI::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ContyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ContyInit() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ContyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ContyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::ContyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContyInit(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::ContyInitReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::ContyInitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RobotUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RobotUpdate() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RobotUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RobotUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::RobotData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRobotUpdate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::RobotData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProgramUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProgramUpdate() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ProgramUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProgramUpdate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::ProgramData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControlUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControlUpdate() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ControlUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlUpdate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::ControlData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinearUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinearUpdate() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_LinearUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinearUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::LinearData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinearUpdate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::LinearData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JogJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JogJoint() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_JogJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJointReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogJointRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogJoint(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::JogJointReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::JogJointRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JogTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JogTask() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_JogTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogTask(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogTaskReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogTask(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::JogTaskReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::JogTaskRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JogAxis : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JogAxis() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_JogAxis() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogAxis(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogAxisReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogAxisRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogAxis(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::JogAxisReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::JogAxisRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HoldToMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HoldToMoveJ() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_HoldToMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToMoveJ(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::MoveJReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HoldToMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HoldToMoveL() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_HoldToMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToMoveL(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::MoveLReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HoldToAxisJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HoldToAxisJ() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_HoldToAxisJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToAxisJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AxisJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToAxisJ(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::AxisJReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopMotion() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopMotionReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopMotionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopMotion(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::StopMotionReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::StopMotionRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFrame(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetRefFrameReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetRefFrameRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFramePlanar(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolFrame(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetToolFrameReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetToolFrameRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSpeedRatio(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSimulationMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDirectTeachingMode() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_SetDirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDirectTeachingMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IntMode* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCustomControlMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::IntMode* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCustomControlMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::IntMode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSensorlessComplianceMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSensorlessComplianceMode() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_SetSensorlessComplianceMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorlessComplianceMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBrakeControlStyle(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::BrakeControlStyle>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetBrake() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_SetBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetBrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetBrake(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetBrakeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetBrakeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServo() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetServoReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServo(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetServoReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetServoRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoServoOff(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoServoOff(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteTool(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Name* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateRelativePose(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateCurrentPoseRel(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetManualRecoverMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetManualRecoverMode() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_SetManualRecoverMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecoverMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetManualRecoverMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::State* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetServoRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetServoRecover() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_SetServoRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Servo* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoRecover(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Servo* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JogJointRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JogJointRecover() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_JogJointRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJointRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJTar* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogJointRecover(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::JogJTar* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Recover() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RecoverReq* /*request*/, ::IndyFramework::Protobuf::HRI::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::RecoverReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::RecoverRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Reboot() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RebootReq* /*request*/, ::IndyFramework::Protobuf::HRI::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReboot(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::RebootReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::RebootRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PowerOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PowerOff() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_PowerOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PowerOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PowerOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::PowerOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPowerOff(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::PowerOffReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::PowerOffRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateIndySW : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateIndySW() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_UpdateIndySW() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateIndySW(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateIndySW(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::IndyFramework::Protobuf::HRI::UpdateIndySWRes, ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(36, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFile() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFileReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFile(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetFileReq* request, ::grpc::ServerAsyncWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(37, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetFile() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_SetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::SetFileReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::SetFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::IndyFramework::Protobuf::HRI::SetFileRes, ::IndyFramework::Protobuf::HRI::SetFileReq>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(38, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RenameFile() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RenameFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRenameFile(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::RenameFileReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::RenameFileRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveFile() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RemoveFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::RemoveFileReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::RemoveFileRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIndexProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIndexProgramList() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_GetIndexProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIndexProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIndexProgramList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProgramList() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_GetProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProgramList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetProgramListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetProgramListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLogList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLogList() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetLogList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetLogListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetLogListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetLogListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLogContent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLogContent() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_GetLogContent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContent(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogContent(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetLogContentReq* request, ::grpc::ServerAsyncWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(44, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLogContentList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLogContentList() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_GetLogContentList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContentList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogContentList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetLogContentListReq* request, ::grpc::ServerAsyncWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLog() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLog(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetLogReq* request, ::grpc::ServerAsyncWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(46, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVariableList() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVariableList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetVariableListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetVariableListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMonitoringVariableList() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_GetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMonitoringVariableList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetMonitoringVariableList() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_SetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMonitoringVariableList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPalletMakerList() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_GetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletMakerList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPalletMakerList() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_SetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPalletMakerList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAproachRetractValid(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletPointList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPalletPointList() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_SetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPalletPointList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConveyor() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyor(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Conveyor>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorName(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Name* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorByName(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Name* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Encoder* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorEncoder(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Encoder* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Trigger* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTrigger(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Trigger* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Float* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorOffset(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Float* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorStartingPose(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::PosePair* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTerminalPose(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::PosePair* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyorState(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::ConveyorState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HoldToMoveConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HoldToMoveConveyor() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_HoldToMoveConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToMoveConveyor(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConveyorList() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_GetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyorList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetConveyorListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetConveyorListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetConveyorList() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_SetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetConveyorListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetConveyorListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetInching() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_SetInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetInching(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetInchingReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetInchingRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopInching() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_StopInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopInching(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::StopInchingReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::StopInchingRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetArc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetArc() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_SetArc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetArc(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetArcReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetArcRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetArc(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetArcReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetArcRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTouch() {
      ::grpc::Service::MarkMethodAsync(70);
    }
    ~WithAsyncMethod_SetTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTouch(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTouchReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTouchRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTouch(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetTouchReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetTouchRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetGas : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetGas() {
      ::grpc::Service::MarkMethodAsync(71);
    }
    ~WithAsyncMethod_SetGas() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGas(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetGasReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetGasRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetGas(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetGasReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetGasRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsTouched : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsTouched() {
      ::grpc::Service::MarkMethodAsync(72);
    }
    ~WithAsyncMethod_IsTouched() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTouched(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* /*request*/, ::IndyFramework::Protobuf::HRI::IsTouchedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsTouched(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::IsTouchedReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::IsTouchedRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVisionServerList() {
      ::grpc::Service::MarkMethodAsync(73);
    }
    ~WithAsyncMethod_GetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionServerList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVisionServerList() {
      ::grpc::Service::MarkMethodAsync(74);
    }
    ~WithAsyncMethod_SetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVisionServerList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVisionObjectList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVisionObjectList() {
      ::grpc::Service::MarkMethodAsync(75);
    }
    ~WithAsyncMethod_GetVisionObjectList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionObjectList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionObjectList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVisionDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVisionDetection() {
      ::grpc::Service::MarkMethodAsync(76);
    }
    ~WithAsyncMethod_GetVisionDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionDetection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionDetection(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::VisionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVisionRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVisionRetrieval() {
      ::grpc::Service::MarkMethodAsync(77);
    }
    ~WithAsyncMethod_GetVisionRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionRetrieval(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionRetrieval(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::VisionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGcodeMotionList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGcodeMotionList() {
      ::grpc::Service::MarkMethodAsync(78);
    }
    ~WithAsyncMethod_GetGcodeMotionList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGcodeMotionList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGcodeMotionList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModbusServerList() {
      ::grpc::Service::MarkMethodAsync(79);
    }
    ~WithAsyncMethod_GetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModbusServerList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetModbusServerList() {
      ::grpc::Service::MarkMethodAsync(80);
    }
    ~WithAsyncMethod_SetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetModbusServerList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckModbusConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckModbusConnection() {
      ::grpc::Service::MarkMethodAsync(81);
    }
    ~WithAsyncMethod_CheckModbusConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckModbusConnection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckModbusConnection(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetToolFrameList() {
      ::grpc::Service::MarkMethodAsync(82);
    }
    ~WithAsyncMethod_GetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolFrameList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetToolFrameList() {
      ::grpc::Service::MarkMethodAsync(83);
    }
    ~WithAsyncMethod_SetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolFrameList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRefFrameList() {
      ::grpc::Service::MarkMethodAsync(84);
    }
    ~WithAsyncMethod_GetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRefFrameList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRefFrameList() {
      ::grpc::Service::MarkMethodAsync(85);
    }
    ~WithAsyncMethod_SetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFrameList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCustomPosList() {
      ::grpc::Service::MarkMethodAsync(86);
    }
    ~WithAsyncMethod_GetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCustomPosList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCustomPosList() {
      ::grpc::Service::MarkMethodAsync(87);
    }
    ~WithAsyncMethod_SetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCustomPosList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(87, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodAsync(88);
    }
    ~WithAsyncMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(88, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodAsync(89);
    }
    ~WithAsyncMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(89, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodAsync(90);
    }
    ~WithAsyncMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTaskControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(90, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodAsync(91);
    }
    ~WithAsyncMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(91, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodAsync(92);
    }
    ~WithAsyncMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetImpedanceControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(92, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodAsync(93);
    }
    ~WithAsyncMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetImpedanceControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(93, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetForceControlGain() {
      ::grpc::Service::MarkMethodAsync(94);
    }
    ~WithAsyncMethod_SetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetForceControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(94, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetForceControlGain() {
      ::grpc::Service::MarkMethodAsync(95);
    }
    ~WithAsyncMethod_GetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetForceControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(95, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetExtAxisControlGain() {
      ::grpc::Service::MarkMethodAsync(96);
    }
    ~WithAsyncMethod_SetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExtAxisControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(96, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetExtAxisControlGain() {
      ::grpc::Service::MarkMethodAsync(97);
    }
    ~WithAsyncMethod_GetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExtAxisControlGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(97, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodAsync(98);
    }
    ~WithAsyncMethod_SetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(98, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodAsync(99);
    }
    ~WithAsyncMethod_GetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(99, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodAsync(100);
    }
    ~WithAsyncMethod_SetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(100, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodAsync(101);
    }
    ~WithAsyncMethod_GetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(101, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetFricComp() {
      ::grpc::Service::MarkMethodAsync(102);
    }
    ~WithAsyncMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFricComp(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetFricCompReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetFricCompRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(102, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFricComp() {
      ::grpc::Service::MarkMethodAsync(103);
    }
    ~WithAsyncMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFricComp(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetFricCompReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetFricCompRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(103, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetHomePos() {
      ::grpc::Service::MarkMethodAsync(104);
    }
    ~WithAsyncMethod_SetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetHomePos(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetHomePosReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetHomePosRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(104, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetHomePos() {
      ::grpc::Service::MarkMethodAsync(105);
    }
    ~WithAsyncMethod_GetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetHomePos(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetHomePosReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetHomePosRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(105, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetMountPos() {
      ::grpc::Service::MarkMethodAsync(106);
    }
    ~WithAsyncMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMountPos(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetMountPosReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetMountPosRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(106, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMountPos() {
      ::grpc::Service::MarkMethodAsync(107);
    }
    ~WithAsyncMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMountPos(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetMountPosReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetMountPosRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(107, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPackagingPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPackagingPos() {
      ::grpc::Service::MarkMethodAsync(108);
    }
    ~WithAsyncMethod_GetPackagingPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPackagingPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPackagingPos(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(108, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodAsync(109);
    }
    ~WithAsyncMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolProperty(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(109, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodAsync(110);
    }
    ~WithAsyncMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolProperty(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(110, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodAsync(111);
    }
    ~WithAsyncMethod_GetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOnStartProgramConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(111, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodAsync(112);
    }
    ~WithAsyncMethod_SetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetOnStartProgramConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(112, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodAsync(113);
    }
    ~WithAsyncMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyLimitConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(113, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodAsync(114);
    }
    ~WithAsyncMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyLimitConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(114, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodAsync(115);
    }
    ~WithAsyncMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyStopConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(115, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodAsync(116);
    }
    ~WithAsyncMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyStopConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(116, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyConfigHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyConfigHash() {
      ::grpc::Service::MarkMethodAsync(117);
    }
    ~WithAsyncMethod_GetSafetyConfigHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyConfigHash(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyConfigHash(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(117, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetKinematicsParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetKinematicsParams() {
      ::grpc::Service::MarkMethodAsync(118);
    }
    ~WithAsyncMethod_GetKinematicsParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKinematicsParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::KinematicsParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetKinematicsParams(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::KinematicsParams>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(118, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KeyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KeyInit() {
      ::grpc::Service::MarkMethodAsync(119);
    }
    ~WithAsyncMethod_KeyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyInit(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::KeyInitReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::KeyInitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(119, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KeyData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KeyData() {
      ::grpc::Service::MarkMethodAsync(120);
    }
    ~WithAsyncMethod_KeyData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyDataReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::KeyDataReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::KeyDataRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(120, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProgramUpdateKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProgramUpdateKey() {
      ::grpc::Service::MarkMethodAsync(121);
    }
    ~WithAsyncMethod_ProgramUpdateKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdateKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProgramUpdateKey(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::ProgramData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(121, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDirectTeachingModeKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDirectTeachingModeKey() {
      ::grpc::Service::MarkMethodAsync(122);
    }
    ~WithAsyncMethod_SetDirectTeachingModeKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingModeKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDirectTeachingModeKey(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(122, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAutoModeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAutoModeConfig() {
      ::grpc::Service::MarkMethodAsync(123);
    }
    ~WithAsyncMethod_GetAutoModeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoModeConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoModeConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(123, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodAsync(124);
    }
    ~WithAsyncMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetAutoModeReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SetAutoModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(124, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodAsync(125);
    }
    ~WithAsyncMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAutoMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(125, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodAsync(126);
    }
    ~WithAsyncMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckReducedMode(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(126, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetReducedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetReducedRatio() {
      ::grpc::Service::MarkMethodAsync(127);
    }
    ~WithAsyncMethod_GetReducedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetReducedRatio(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(127, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetReducedSpeed() {
      ::grpc::Service::MarkMethodAsync(128);
    }
    ~WithAsyncMethod_GetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetReducedSpeed(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(128, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetReducedSpeed() {
      ::grpc::Service::MarkMethodAsync(129);
    }
    ~WithAsyncMethod_SetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetReducedSpeed(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(129, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStopState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStopState() {
      ::grpc::Service::MarkMethodAsync(130);
    }
    ~WithAsyncMethod_GetStopState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStopState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::StopState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStopState(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::StopState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(130, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodAsync(131);
    }
    ~WithAsyncMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyFunctionState(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SafetyFunctionState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(131, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodAsync(132);
    }
    ~WithAsyncMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestSafetyFunction(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(132, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayProgram() {
      ::grpc::Service::MarkMethodAsync(133);
    }
    ~WithAsyncMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayProgram(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::PlayProgramReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::PlayProgramRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(133, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayIndexProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayIndexProgram() {
      ::grpc::Service::MarkMethodAsync(134);
    }
    ~WithAsyncMethod_PlayIndexProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayIndexProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayIndexProgram(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(134, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayProgramLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayProgramLine() {
      ::grpc::Service::MarkMethodAsync(135);
    }
    ~WithAsyncMethod_PlayProgramLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgramLine(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayProgramLine(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(135, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodAsync(136);
    }
    ~WithAsyncMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeProgram(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::ResumeProgramReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::ResumeProgramRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(136, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopProgram() {
      ::grpc::Service::MarkMethodAsync(137);
    }
    ~WithAsyncMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopProgram(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::StopProgramReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::StopProgramRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(137, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseProgram() {
      ::grpc::Service::MarkMethodAsync(138);
    }
    ~WithAsyncMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PauseProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseProgram(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::PauseProgramReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::PauseProgramRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(138, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDO() {
      ::grpc::Service::MarkMethodAsync(139);
    }
    ~WithAsyncMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::DOSignals* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(139, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAO() {
      ::grpc::Service::MarkMethodAsync(140);
    }
    ~WithAsyncMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::AOSignals* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(140, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndDO() {
      ::grpc::Service::MarkMethodAsync(141);
    }
    ~WithAsyncMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::EndtoolSignalList* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(141, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEndAO() {
      ::grpc::Service::MarkMethodAsync(142);
    }
    ~WithAsyncMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAO(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::AOSignals* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(142, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetToolList() {
      ::grpc::Service::MarkMethodAsync(143);
    }
    ~WithAsyncMethod_SetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ToolList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::ToolList* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(143, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetToolList() {
      ::grpc::Service::MarkMethodAsync(144);
    }
    ~WithAsyncMethod_GetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ToolList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::ToolList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(144, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDIConfigList() {
      ::grpc::Service::MarkMethodAsync(145);
    }
    ~WithAsyncMethod_SetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DIConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDIConfigList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::DIConfigList* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(145, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDIConfigList() {
      ::grpc::Service::MarkMethodAsync(146);
    }
    ~WithAsyncMethod_GetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DIConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDIConfigList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::DIConfigList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(146, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetDOConfigList() {
      ::grpc::Service::MarkMethodAsync(147);
    }
    ~WithAsyncMethod_SetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDOConfigList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::DOConfigList* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(147, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDOConfigList() {
      ::grpc::Service::MarkMethodAsync(148);
    }
    ~WithAsyncMethod_GetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DOConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDOConfigList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::DOConfigList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(148, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodAsync(149);
    }
    ~WithAsyncMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensLevel(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(149, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodAsync(150);
    }
    ~WithAsyncMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensLevel(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CollisionSensLevel>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(150, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodAsync(151);
    }
    ~WithAsyncMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollPolicy(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::CollisionPolicy* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(151, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodAsync(152);
    }
    ~WithAsyncMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollPolicy(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CollisionPolicy>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(152, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodAsync(153);
    }
    ~WithAsyncMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensParam(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::CollisionThresholds* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(153, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodAsync(154);
    }
    ~WithAsyncMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensParam(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(154, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InitCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InitCollSensParam() {
      ::grpc::Service::MarkMethodAsync(155);
    }
    ~WithAsyncMethod_InitCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InitCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInitCollSensParam(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(155, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodAsync(156);
    }
    ~WithAsyncMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TuningProgram* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayTuningProgram(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::TuningProgram* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::CollisionThresholds>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(156, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodAsync(157);
    }
    ~WithAsyncMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpDevice(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::TeleOpDevice>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(157, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodAsync(158);
    }
    ~WithAsyncMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpState(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::TeleOpState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(158, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodAsync(159);
    }
    ~WithAsyncMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectTeleOpDevice(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::TeleOpDevice* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(159, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodAsync(160);
    }
    ~WithAsyncMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisConnectTeleOpDevice(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(160, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodAsync(161);
    }
    ~WithAsyncMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadTeleOpInput(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::TeleP>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(161, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTeleCalib : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTeleCalib() {
      ::grpc::Service::MarkMethodAsync(162);
    }
    ~WithAsyncMethod_StartTeleCalib() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleCalib(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleCalib(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(162, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTeleRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTeleRecord() {
      ::grpc::Service::MarkMethodAsync(163);
    }
    ~WithAsyncMethod_StartTeleRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleRecord(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleRecord(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(163, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTelePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTelePlay() {
      ::grpc::Service::MarkMethodAsync(164);
    }
    ~WithAsyncMethod_StartTelePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTelePlay(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTelePlay(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(164, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTeleJogL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTeleJogL() {
      ::grpc::Service::MarkMethodAsync(165);
    }
    ~WithAsyncMethod_StartTeleJogL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleJogL(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(165, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartTeleJogJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartTeleJogJ() {
      ::grpc::Service::MarkMethodAsync(166);
    }
    ~WithAsyncMethod_StartTeleJogJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleJogJ(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(166, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodAsync(167);
    }
    ~WithAsyncMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTeleOp(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(167, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodAsync(168);
    }
    ~WithAsyncMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TelePlayRate* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayRate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::TelePlayRate* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(168, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodAsync(169);
    }
    ~WithAsyncMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayRate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::TelePlayRate>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(169, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodAsync(170);
    }
    ~WithAsyncMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleFileList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::TeleOpFileList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(170, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodAsync(171);
    }
    ~WithAsyncMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveTeleMotion(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(171, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodAsync(172);
    }
    ~WithAsyncMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadTeleMotion(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(172, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodAsync(173);
    }
    ~WithAsyncMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTeleMotion(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(173, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodAsync(174);
    }
    ~WithAsyncMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleJ(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::MoveTeleJReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(174, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodAsync(175);
    }
    ~WithAsyncMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleL(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::MoveTeleLReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(175, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTeleOpParams() {
      ::grpc::Service::MarkMethodAsync(176);
    }
    ~WithAsyncMethod_SetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpParams* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTeleOpParams(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::TeleOpParams* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(176, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTeleOpParams() {
      ::grpc::Service::MarkMethodAsync(177);
    }
    ~WithAsyncMethod_GetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpParams(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::TeleOpParams>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(177, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetFTSensorConfig() {
      ::grpc::Service::MarkMethodAsync(178);
    }
    ~WithAsyncMethod_SetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFTSensorConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::FTSensorDevice* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(178, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFTSensorConfig() {
      ::grpc::Service::MarkMethodAsync(179);
    }
    ~WithAsyncMethod_GetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFTSensorConfig(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::FTSensorDevice>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(179, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodAsync(180);
    }
    ~WithAsyncMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFTSensorData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::FTSensorData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(180, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodAsync(181);
    }
    ~WithAsyncMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoadFactors(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(181, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodAsync(182);
    }
    ~WithAsyncMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SanderCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSanderCommand(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SanderCommand* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(182, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodAsync(183);
    }
    ~WithAsyncMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSanderCommand(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SanderCommand>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(183, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSandingStopCondition() {
      ::grpc::Service::MarkMethodAsync(184);
    }
    ~WithAsyncMethod_SetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSandingStopCondition(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(184, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSandingStopCondition() {
      ::grpc::Service::MarkMethodAsync(185);
    }
    ~WithAsyncMethod_GetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSandingStopCondition(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SandingStopConditionState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(185, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGripperData() {
      ::grpc::Service::MarkMethodAsync(186);
    }
    ~WithAsyncMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGripperData(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::GripperData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(186, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodAsync(187);
    }
    ~WithAsyncMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GripperCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetGripperCommand(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::GripperCommand* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(187, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSFDActivate() {
      ::grpc::Service::MarkMethodAsync(188);
    }
    ~WithAsyncMethod_SetSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSFDActivate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::State* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(188, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsSFDActivate() {
      ::grpc::Service::MarkMethodAsync(189);
    }
    ~WithAsyncMethod_IsSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsSFDActivate(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::State>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(189, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SFDLogin() {
      ::grpc::Service::MarkMethodAsync(190);
    }
    ~WithAsyncMethod_SFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDAccount* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSFDLogin(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SFDAccount* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(190, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsSFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsSFDLogin() {
      ::grpc::Service::MarkMethodAsync(191);
    }
    ~WithAsyncMethod_IsSFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsSFDLogin(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::State>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(191, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSFDTarget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSFDTarget() {
      ::grpc::Service::MarkMethodAsync(192);
    }
    ~WithAsyncMethod_SetSFDTarget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDTarget(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSFDTarget(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::SFDCriTarget* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(192, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSFDOption : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSFDOption() {
      ::grpc::Service::MarkMethodAsync(193);
    }
    ~WithAsyncMethod_SetSFDOption() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDOption(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSFDOption(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::State* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(193, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSFDProjList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSFDProjList() {
      ::grpc::Service::MarkMethodAsync(194);
    }
    ~WithAsyncMethod_GetSFDProjList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDProjList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDProjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSFDProjList(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SFDProjectList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(194, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSFDCRI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSFDCRI() {
      ::grpc::Service::MarkMethodAsync(195);
    }
    ~WithAsyncMethod_GetSFDCRI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDCRI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDCriData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSFDCRI(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::SFDCriData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(195, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTactTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTactTime() {
      ::grpc::Service::MarkMethodAsync(196);
    }
    ~WithAsyncMethod_GetTactTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTactTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TactTime* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTactTime(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::Empty* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::TactTime>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(196, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodAsync(197);
    }
    ~WithAsyncMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPhotoneoCalibPoint(::grpc::ServerContext* context, ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* request, ::grpc::ServerAsyncResponseWriter< ::IndyFramework::Protobuf::HRI::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(197, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ContyInit<WithAsyncMethod_RobotUpdate<WithAsyncMethod_ProgramUpdate<WithAsyncMethod_ControlUpdate<WithAsyncMethod_LinearUpdate<WithAsyncMethod_JogJoint<WithAsyncMethod_JogTask<WithAsyncMethod_JogAxis<WithAsyncMethod_HoldToMoveJ<WithAsyncMethod_HoldToMoveL<WithAsyncMethod_HoldToAxisJ<WithAsyncMethod_StopMotion<WithAsyncMethod_SetRefFrame<WithAsyncMethod_SetRefFramePlanar<WithAsyncMethod_SetToolFrame<WithAsyncMethod_SetSpeedRatio<WithAsyncMethod_SetSimulationMode<WithAsyncMethod_SetDirectTeachingMode<WithAsyncMethod_SetCustomControlMode<WithAsyncMethod_GetCustomControlMode<WithAsyncMethod_SetSensorlessComplianceMode<WithAsyncMethod_GetBrakeControlStyle<WithAsyncMethod_SetBrake<WithAsyncMethod_SetServo<WithAsyncMethod_SetAutoServoOff<WithAsyncMethod_GetAutoServoOff<WithAsyncMethod_ExecuteTool<WithAsyncMethod_InverseKinematics<WithAsyncMethod_CalculateRelativePose<WithAsyncMethod_CalculateCurrentPoseRel<WithAsyncMethod_SetManualRecoverMode<WithAsyncMethod_SetServoRecover<WithAsyncMethod_JogJointRecover<WithAsyncMethod_Recover<WithAsyncMethod_Reboot<WithAsyncMethod_PowerOff<WithAsyncMethod_UpdateIndySW<WithAsyncMethod_GetFile<WithAsyncMethod_SetFile<WithAsyncMethod_RenameFile<WithAsyncMethod_RemoveFile<WithAsyncMethod_GetIndexProgramList<WithAsyncMethod_GetProgramList<WithAsyncMethod_GetLogList<WithAsyncMethod_GetLogContent<WithAsyncMethod_GetLogContentList<WithAsyncMethod_GetLog<WithAsyncMethod_GetVariableList<WithAsyncMethod_GetMonitoringVariableList<WithAsyncMethod_SetMonitoringVariableList<WithAsyncMethod_GetPalletMakerList<WithAsyncMethod_SetPalletMakerList<WithAsyncMethod_CheckAproachRetractValid<WithAsyncMethod_GetPalletPointList<WithAsyncMethod_SetPalletPointList<WithAsyncMethod_GetConveyor<WithAsyncMethod_SetConveyorName<WithAsyncMethod_SetConveyorByName<WithAsyncMethod_SetConveyorEncoder<WithAsyncMethod_SetConveyorTrigger<WithAsyncMethod_SetConveyorOffset<WithAsyncMethod_SetConveyorStartingPose<WithAsyncMethod_SetConveyorTerminalPose<WithAsyncMethod_GetConveyorState<WithAsyncMethod_HoldToMoveConveyor<WithAsyncMethod_GetConveyorList<WithAsyncMethod_SetConveyorList<WithAsyncMethod_SetInching<WithAsyncMethod_StopInching<WithAsyncMethod_SetArc<WithAsyncMethod_SetTouch<WithAsyncMethod_SetGas<WithAsyncMethod_IsTouched<WithAsyncMethod_GetVisionServerList<WithAsyncMethod_SetVisionServerList<WithAsyncMethod_GetVisionObjectList<WithAsyncMethod_GetVisionDetection<WithAsyncMethod_GetVisionRetrieval<WithAsyncMethod_GetGcodeMotionList<WithAsyncMethod_GetModbusServerList<WithAsyncMethod_SetModbusServerList<WithAsyncMethod_CheckModbusConnection<WithAsyncMethod_GetToolFrameList<WithAsyncMethod_SetToolFrameList<WithAsyncMethod_GetRefFrameList<WithAsyncMethod_SetRefFrameList<WithAsyncMethod_GetCustomPosList<WithAsyncMethod_SetCustomPosList<WithAsyncMethod_SetJointControlGain<WithAsyncMethod_GetJointControlGain<WithAsyncMethod_SetTaskControlGain<WithAsyncMethod_GetTaskControlGain<WithAsyncMethod_SetImpedanceControlGain<WithAsyncMethod_GetImpedanceControlGain<WithAsyncMethod_SetForceControlGain<WithAsyncMethod_GetForceControlGain<WithAsyncMethod_SetExtAxisControlGain<WithAsyncMethod_GetExtAxisControlGain<WithAsyncMethod_SetSensorlessComplianceControlJointGain<WithAsyncMethod_GetSensorlessComplianceControlJointGain<WithAsyncMethod_SetSensorlessComplianceControlTaskGain<WithAsyncMethod_GetSensorlessComplianceControlTaskGain<WithAsyncMethod_SetFricComp<WithAsyncMethod_GetFricComp<WithAsyncMethod_SetHomePos<WithAsyncMethod_GetHomePos<WithAsyncMethod_SetMountPos<WithAsyncMethod_GetMountPos<WithAsyncMethod_GetPackagingPos<WithAsyncMethod_SetToolProperty<WithAsyncMethod_GetToolProperty<WithAsyncMethod_GetOnStartProgramConfig<WithAsyncMethod_SetOnStartProgramConfig<WithAsyncMethod_GetSafetyLimitConfig<WithAsyncMethod_SetSafetyLimitConfig<WithAsyncMethod_GetSafetyStopConfig<WithAsyncMethod_SetSafetyStopConfig<WithAsyncMethod_GetSafetyConfigHash<WithAsyncMethod_GetKinematicsParams<WithAsyncMethod_KeyInit<WithAsyncMethod_KeyData<WithAsyncMethod_ProgramUpdateKey<WithAsyncMethod_SetDirectTeachingModeKey<WithAsyncMethod_GetAutoModeConfig<WithAsyncMethod_SetAutoMode<WithAsyncMethod_CheckAutoMode<WithAsyncMethod_CheckReducedMode<WithAsyncMethod_GetReducedRatio<WithAsyncMethod_GetReducedSpeed<WithAsyncMethod_SetReducedSpeed<WithAsyncMethod_GetStopState<WithAsyncMethod_GetSafetyFunctionState<WithAsyncMethod_RequestSafetyFunction<WithAsyncMethod_PlayProgram<WithAsyncMethod_PlayIndexProgram<WithAsyncMethod_PlayProgramLine<WithAsyncMethod_ResumeProgram<WithAsyncMethod_StopProgram<WithAsyncMethod_PauseProgram<WithAsyncMethod_SetDO<WithAsyncMethod_SetAO<WithAsyncMethod_SetEndDO<WithAsyncMethod_SetEndAO<WithAsyncMethod_SetToolList<WithAsyncMethod_GetToolList<WithAsyncMethod_SetDIConfigList<WithAsyncMethod_GetDIConfigList<WithAsyncMethod_SetDOConfigList<WithAsyncMethod_GetDOConfigList<WithAsyncMethod_SetCollSensLevel<WithAsyncMethod_GetCollSensLevel<WithAsyncMethod_SetCollPolicy<WithAsyncMethod_GetCollPolicy<WithAsyncMethod_SetCollSensParam<WithAsyncMethod_GetCollSensParam<WithAsyncMethod_InitCollSensParam<WithAsyncMethod_PlayTuningProgram<WithAsyncMethod_GetTeleOpDevice<WithAsyncMethod_GetTeleOpState<WithAsyncMethod_ConnectTeleOpDevice<WithAsyncMethod_DisConnectTeleOpDevice<WithAsyncMethod_ReadTeleOpInput<WithAsyncMethod_StartTeleCalib<WithAsyncMethod_StartTeleRecord<WithAsyncMethod_StartTelePlay<WithAsyncMethod_StartTeleJogL<WithAsyncMethod_StartTeleJogJ<WithAsyncMethod_StopTeleOp<WithAsyncMethod_SetPlayRate<WithAsyncMethod_GetPlayRate<WithAsyncMethod_GetTeleFileList<WithAsyncMethod_SaveTeleMotion<WithAsyncMethod_LoadTeleMotion<WithAsyncMethod_DeleteTeleMotion<WithAsyncMethod_MoveTeleJ<WithAsyncMethod_MoveTeleL<WithAsyncMethod_SetTeleOpParams<WithAsyncMethod_GetTeleOpParams<WithAsyncMethod_SetFTSensorConfig<WithAsyncMethod_GetFTSensorConfig<WithAsyncMethod_GetFTSensorData<WithAsyncMethod_GetLoadFactors<WithAsyncMethod_SetSanderCommand<WithAsyncMethod_GetSanderCommand<WithAsyncMethod_SetSandingStopCondition<WithAsyncMethod_GetSandingStopCondition<WithAsyncMethod_GetGripperData<WithAsyncMethod_SetGripperCommand<WithAsyncMethod_SetSFDActivate<WithAsyncMethod_IsSFDActivate<WithAsyncMethod_SFDLogin<WithAsyncMethod_IsSFDLogin<WithAsyncMethod_SetSFDTarget<WithAsyncMethod_SetSFDOption<WithAsyncMethod_GetSFDProjList<WithAsyncMethod_GetSFDCRI<WithAsyncMethod_GetTactTime<WithAsyncMethod_AddPhotoneoCalibPoint<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ContyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ContyInit() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::ContyInitReq, ::IndyFramework::Protobuf::HRI::ContyInitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::ContyInitReq* request, ::IndyFramework::Protobuf::HRI::ContyInitRes* response) { return this->ContyInit(context, request, response); }));}
    void SetMessageAllocatorFor_ContyInit(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::ContyInitReq, ::IndyFramework::Protobuf::HRI::ContyInitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::ContyInitReq, ::IndyFramework::Protobuf::HRI::ContyInitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ContyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ContyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::ContyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ContyInit(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ContyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::ContyInitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RobotUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RobotUpdate() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::RobotData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::RobotData* response) { return this->RobotUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_RobotUpdate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::RobotData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::RobotData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RobotUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RobotUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::RobotData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RobotUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::RobotData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProgramUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ProgramUpdate() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response) { return this->ProgramUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_ProgramUpdate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProgramUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProgramUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ControlUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ControlUpdate() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ControlData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ControlData* response) { return this->ControlUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_ControlUpdate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ControlData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ControlData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ControlUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ControlData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LinearUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LinearUpdate() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::LinearData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::LinearData* response) { return this->LinearUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_LinearUpdate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::LinearData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::LinearData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LinearUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinearUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::LinearData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LinearUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::LinearData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_JogJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_JogJoint() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogJointReq, ::IndyFramework::Protobuf::HRI::JogJointRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::JogJointReq* request, ::IndyFramework::Protobuf::HRI::JogJointRes* response) { return this->JogJoint(context, request, response); }));}
    void SetMessageAllocatorFor_JogJoint(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::JogJointReq, ::IndyFramework::Protobuf::HRI::JogJointRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogJointReq, ::IndyFramework::Protobuf::HRI::JogJointRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_JogJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJointReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogJointRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogJoint(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJointReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogJointRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_JogTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_JogTask() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogTaskReq, ::IndyFramework::Protobuf::HRI::JogTaskRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::JogTaskReq* request, ::IndyFramework::Protobuf::HRI::JogTaskRes* response) { return this->JogTask(context, request, response); }));}
    void SetMessageAllocatorFor_JogTask(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::JogTaskReq, ::IndyFramework::Protobuf::HRI::JogTaskRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogTaskReq, ::IndyFramework::Protobuf::HRI::JogTaskRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_JogTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogTask(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogTaskReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogTask(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogTaskReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogTaskRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_JogAxis : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_JogAxis() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogAxisReq, ::IndyFramework::Protobuf::HRI::JogAxisRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::JogAxisReq* request, ::IndyFramework::Protobuf::HRI::JogAxisRes* response) { return this->JogAxis(context, request, response); }));}
    void SetMessageAllocatorFor_JogAxis(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::JogAxisReq, ::IndyFramework::Protobuf::HRI::JogAxisRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogAxisReq, ::IndyFramework::Protobuf::HRI::JogAxisRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_JogAxis() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogAxis(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogAxisReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogAxisRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogAxis(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogAxisReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogAxisRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HoldToMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HoldToMoveJ() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveJReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response) { return this->HoldToMoveJ(context, request, response); }));}
    void SetMessageAllocatorFor_HoldToMoveJ(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::MoveJReq, ::IndyFramework::Protobuf::HRI::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveJReq, ::IndyFramework::Protobuf::HRI::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HoldToMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToMoveJ(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HoldToMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HoldToMoveL() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveLReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveLReq* request, ::IndyFramework::Protobuf::HRI::Empty* response) { return this->HoldToMoveL(context, request, response); }));}
    void SetMessageAllocatorFor_HoldToMoveL(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::MoveLReq, ::IndyFramework::Protobuf::HRI::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveLReq, ::IndyFramework::Protobuf::HRI::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HoldToMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToMoveL(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HoldToAxisJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HoldToAxisJ() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AxisJReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::AxisJReq* request, ::IndyFramework::Protobuf::HRI::Empty* response) { return this->HoldToAxisJ(context, request, response); }));}
    void SetMessageAllocatorFor_HoldToAxisJ(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::AxisJReq, ::IndyFramework::Protobuf::HRI::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AxisJReq, ::IndyFramework::Protobuf::HRI::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HoldToAxisJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToAxisJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AxisJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToAxisJ(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AxisJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopMotion() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::StopMotionReq, ::IndyFramework::Protobuf::HRI::StopMotionRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::StopMotionReq* request, ::IndyFramework::Protobuf::HRI::StopMotionRes* response) { return this->StopMotion(context, request, response); }));}
    void SetMessageAllocatorFor_StopMotion(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::StopMotionReq, ::IndyFramework::Protobuf::HRI::StopMotionRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::StopMotionReq, ::IndyFramework::Protobuf::HRI::StopMotionRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopMotionReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopMotionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopMotionReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopMotionRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetRefFrameReq, ::IndyFramework::Protobuf::HRI::SetRefFrameRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* response) { return this->SetRefFrame(context, request, response); }));}
    void SetMessageAllocatorFor_SetRefFrame(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetRefFrameReq, ::IndyFramework::Protobuf::HRI::SetRefFrameRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetRefFrameReq, ::IndyFramework::Protobuf::HRI::SetRefFrameRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRefFrame(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* request, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* response) { return this->SetRefFramePlanar(context, request, response); }));}
    void SetMessageAllocatorFor_SetRefFramePlanar(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRefFramePlanar(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetToolFrameReq, ::IndyFramework::Protobuf::HRI::SetToolFrameRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* response) { return this->SetToolFrame(context, request, response); }));}
    void SetMessageAllocatorFor_SetToolFrame(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetToolFrameReq, ::IndyFramework::Protobuf::HRI::SetToolFrameRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetToolFrameReq, ::IndyFramework::Protobuf::HRI::SetToolFrameRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolFrame(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* request, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* response) { return this->SetSpeedRatio(context, request, response); }));}
    void SetMessageAllocatorFor_SetSpeedRatio(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSpeedRatio(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSimulationModeReq, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* request, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* response) { return this->SetSimulationMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetSimulationMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetSimulationModeReq, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSimulationModeReq, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSimulationMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDirectTeachingMode() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response) { return this->SetDirectTeachingMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetDirectTeachingMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDirectTeachingMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::IntMode, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::IntMode* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetCustomControlMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetCustomControlMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::IntMode, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::IntMode, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IntMode* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IntMode* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::IntMode>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::IntMode* response) { return this->GetCustomControlMode(context, request, response); }));}
    void SetMessageAllocatorFor_GetCustomControlMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::IntMode>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::IntMode>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::IntMode* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSensorlessComplianceMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSensorlessComplianceMode() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* response) { return this->SetSensorlessComplianceMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetSensorlessComplianceMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSensorlessComplianceMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSensorlessComplianceMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::BrakeControlStyle>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* response) { return this->GetBrakeControlStyle(context, request, response); }));}
    void SetMessageAllocatorFor_GetBrakeControlStyle(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::BrakeControlStyle>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::BrakeControlStyle>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBrakeControlStyle(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetBrake() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetBrakeReq, ::IndyFramework::Protobuf::HRI::SetBrakeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* request, ::IndyFramework::Protobuf::HRI::SetBrakeRes* response) { return this->SetBrake(context, request, response); }));}
    void SetMessageAllocatorFor_SetBrake(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetBrakeReq, ::IndyFramework::Protobuf::HRI::SetBrakeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetBrakeReq, ::IndyFramework::Protobuf::HRI::SetBrakeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetBrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetBrake(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetBrakeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServo() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetServoReq, ::IndyFramework::Protobuf::HRI::SetServoRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetServoReq* request, ::IndyFramework::Protobuf::HRI::SetServoRes* response) { return this->SetServo(context, request, response); }));}
    void SetMessageAllocatorFor_SetServo(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetServoReq, ::IndyFramework::Protobuf::HRI::SetServoRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetServoReq, ::IndyFramework::Protobuf::HRI::SetServoRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetServoReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServo(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetServoReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetServoRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* response) { return this->SetAutoServoOff(context, request, response); }));}
    void SetMessageAllocatorFor_SetAutoServoOff(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAutoServoOff(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* request, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* response) { return this->GetAutoServoOff(context, request, response); }));}
    void SetMessageAllocatorFor_GetAutoServoOff(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAutoServoOff(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->ExecuteTool(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteTool(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteTool(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::InverseKinematicsReq, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* request, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* response) { return this->InverseKinematics(context, request, response); }));}
    void SetMessageAllocatorFor_InverseKinematics(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::InverseKinematicsReq, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::InverseKinematicsReq, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InverseKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* request, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* response) { return this->CalculateRelativePose(context, request, response); }));}
    void SetMessageAllocatorFor_CalculateRelativePose(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateRelativePose(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* request, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* response) { return this->CalculateCurrentPoseRel(context, request, response); }));}
    void SetMessageAllocatorFor_CalculateCurrentPoseRel(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateCurrentPoseRel(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetManualRecoverMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetManualRecoverMode() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetManualRecoverMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetManualRecoverMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetManualRecoverMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecoverMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetManualRecoverMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetServoRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetServoRecover() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Servo, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Servo* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetServoRecover(context, request, response); }));}
    void SetMessageAllocatorFor_SetServoRecover(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Servo, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Servo, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetServoRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Servo* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoRecover(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Servo* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_JogJointRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_JogJointRecover() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogJTar, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::JogJTar* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->JogJointRecover(context, request, response); }));}
    void SetMessageAllocatorFor_JogJointRecover(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::JogJTar, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::JogJTar, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_JogJointRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJointRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJTar* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogJointRecover(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJTar* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Recover() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RecoverReq, ::IndyFramework::Protobuf::HRI::RecoverRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::RecoverReq* request, ::IndyFramework::Protobuf::HRI::RecoverRes* response) { return this->Recover(context, request, response); }));}
    void SetMessageAllocatorFor_Recover(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::RecoverReq, ::IndyFramework::Protobuf::HRI::RecoverRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RecoverReq, ::IndyFramework::Protobuf::HRI::RecoverRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RecoverReq* /*request*/, ::IndyFramework::Protobuf::HRI::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Recover(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RecoverReq* /*request*/, ::IndyFramework::Protobuf::HRI::RecoverRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Reboot() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RebootReq, ::IndyFramework::Protobuf::HRI::RebootRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::RebootReq* request, ::IndyFramework::Protobuf::HRI::RebootRes* response) { return this->Reboot(context, request, response); }));}
    void SetMessageAllocatorFor_Reboot(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::RebootReq, ::IndyFramework::Protobuf::HRI::RebootRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RebootReq, ::IndyFramework::Protobuf::HRI::RebootRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RebootReq* /*request*/, ::IndyFramework::Protobuf::HRI::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Reboot(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RebootReq* /*request*/, ::IndyFramework::Protobuf::HRI::RebootRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PowerOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PowerOff() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PowerOffReq, ::IndyFramework::Protobuf::HRI::PowerOffRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::PowerOffReq* request, ::IndyFramework::Protobuf::HRI::PowerOffRes* response) { return this->PowerOff(context, request, response); }));}
    void SetMessageAllocatorFor_PowerOff(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::PowerOffReq, ::IndyFramework::Protobuf::HRI::PowerOffRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PowerOffReq, ::IndyFramework::Protobuf::HRI::PowerOffRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PowerOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PowerOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PowerOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::PowerOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PowerOff(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PowerOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::PowerOffRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateIndySW : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateIndySW() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackClientStreamingHandler< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes>(
            [this](
                   ::grpc::CallbackServerContext* context, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* response) { return this->UpdateIndySW(context, response); }));
    }
    ~WithCallbackMethod_UpdateIndySW() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateIndySW(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* UpdateIndySW(
      ::grpc::CallbackServerContext* /*context*/, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFile() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackServerStreamingHandler< ::IndyFramework::Protobuf::HRI::GetFileReq, ::IndyFramework::Protobuf::HRI::GetFileRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetFileReq* request) { return this->GetFile(context, request); }));
    }
    ~WithCallbackMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFileReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::IndyFramework::Protobuf::HRI::GetFileRes>* GetFile(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFileReq* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetFile() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackClientStreamingHandler< ::IndyFramework::Protobuf::HRI::SetFileReq, ::IndyFramework::Protobuf::HRI::SetFileRes>(
            [this](
                   ::grpc::CallbackServerContext* context, ::IndyFramework::Protobuf::HRI::SetFileRes* response) { return this->SetFile(context, response); }));
    }
    ~WithCallbackMethod_SetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::SetFileReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::SetFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::IndyFramework::Protobuf::HRI::SetFileReq>* SetFile(
      ::grpc::CallbackServerContext* /*context*/, ::IndyFramework::Protobuf::HRI::SetFileRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RenameFile() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RenameFileReq, ::IndyFramework::Protobuf::HRI::RenameFileRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::RenameFileReq* request, ::IndyFramework::Protobuf::HRI::RenameFileRes* response) { return this->RenameFile(context, request, response); }));}
    void SetMessageAllocatorFor_RenameFile(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::RenameFileReq, ::IndyFramework::Protobuf::HRI::RenameFileRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RenameFileReq, ::IndyFramework::Protobuf::HRI::RenameFileRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RenameFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RenameFile(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RenameFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RenameFileRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RemoveFileReq, ::IndyFramework::Protobuf::HRI::RemoveFileRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* request, ::IndyFramework::Protobuf::HRI::RemoveFileRes* response) { return this->RemoveFile(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveFile(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::RemoveFileReq, ::IndyFramework::Protobuf::HRI::RemoveFileRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::RemoveFileReq, ::IndyFramework::Protobuf::HRI::RemoveFileRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RemoveFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RemoveFileRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetIndexProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetIndexProgramList() {
      ::grpc::Service::MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* response) { return this->GetIndexProgramList(context, request, response); }));}
    void SetMessageAllocatorFor_GetIndexProgramList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetIndexProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIndexProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIndexProgramList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetProgramList() {
      ::grpc::Service::MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetProgramListReq, ::IndyFramework::Protobuf::HRI::GetProgramListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* request, ::IndyFramework::Protobuf::HRI::GetProgramListRes* response) { return this->GetProgramList(context, request, response); }));}
    void SetMessageAllocatorFor_GetProgramList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetProgramListReq, ::IndyFramework::Protobuf::HRI::GetProgramListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetProgramListReq, ::IndyFramework::Protobuf::HRI::GetProgramListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProgramList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetProgramListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLogList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLogList() {
      ::grpc::Service::MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetLogListReq, ::IndyFramework::Protobuf::HRI::GetLogListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogListReq* request, ::IndyFramework::Protobuf::HRI::GetLogListRes* response) { return this->GetLogList(context, request, response); }));}
    void SetMessageAllocatorFor_GetLogList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetLogListReq, ::IndyFramework::Protobuf::HRI::GetLogListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetLogListReq, ::IndyFramework::Protobuf::HRI::GetLogListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLogList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetLogListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLogList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetLogListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLogContent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLogContent() {
      ::grpc::Service::MarkMethodCallback(44,
          new ::grpc::internal::CallbackServerStreamingHandler< ::IndyFramework::Protobuf::HRI::GetLogContentReq, ::IndyFramework::Protobuf::HRI::GetLogContentRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* request) { return this->GetLogContent(context, request); }));
    }
    ~WithCallbackMethod_GetLogContent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContent(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* GetLogContent(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLogContentList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLogContentList() {
      ::grpc::Service::MarkMethodCallback(45,
          new ::grpc::internal::CallbackServerStreamingHandler< ::IndyFramework::Protobuf::HRI::GetLogContentListReq, ::IndyFramework::Protobuf::HRI::GetLogContentListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* request) { return this->GetLogContentList(context, request); }));
    }
    ~WithCallbackMethod_GetLogContentList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContentList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* GetLogContentList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLog() {
      ::grpc::Service::MarkMethodCallback(46,
          new ::grpc::internal::CallbackServerStreamingHandler< ::IndyFramework::Protobuf::HRI::GetLogReq, ::IndyFramework::Protobuf::HRI::GetLogRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetLogReq* request) { return this->GetLog(context, request); }));
    }
    ~WithCallbackMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::IndyFramework::Protobuf::HRI::GetLogRes>* GetLog(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogReq* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVariableList() {
      ::grpc::Service::MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetVariableListReq, ::IndyFramework::Protobuf::HRI::GetVariableListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetVariableListRes* response) { return this->GetVariableList(context, request, response); }));}
    void SetMessageAllocatorFor_GetVariableList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetVariableListReq, ::IndyFramework::Protobuf::HRI::GetVariableListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetVariableListReq, ::IndyFramework::Protobuf::HRI::GetVariableListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVariableList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVariableListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMonitoringVariableList() {
      ::grpc::Service::MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* response) { return this->GetMonitoringVariableList(context, request, response); }));}
    void SetMessageAllocatorFor_GetMonitoringVariableList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMonitoringVariableList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetMonitoringVariableList() {
      ::grpc::Service::MarkMethodCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* request, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* response) { return this->SetMonitoringVariableList(context, request, response); }));}
    void SetMessageAllocatorFor_SetMonitoringVariableList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetMonitoringVariableList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPalletMakerList() {
      ::grpc::Service::MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* response) { return this->GetPalletMakerList(context, request, response); }));}
    void SetMessageAllocatorFor_GetPalletMakerList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPalletMakerList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPalletMakerList() {
      ::grpc::Service::MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* response) { return this->SetPalletMakerList(context, request, response); }));}
    void SetMessageAllocatorFor_SetPalletMakerList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPalletMakerList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* request, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* response) { return this->CheckAproachRetractValid(context, request, response); }));}
    void SetMessageAllocatorFor_CheckAproachRetractValid(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAproachRetractValid(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetPalletPointListReq, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* response) { return this->GetPalletPointList(context, request, response); }));}
    void SetMessageAllocatorFor_GetPalletPointList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetPalletPointListReq, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetPalletPointListReq, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPalletPointList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPalletPointList() {
      ::grpc::Service::MarkMethodCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetPalletPointListReq, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* request, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* response) { return this->SetPalletPointList(context, request, response); }));}
    void SetMessageAllocatorFor_SetPalletPointList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetPalletPointListReq, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(54);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetPalletPointListReq, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPalletPointList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConveyor() {
      ::grpc::Service::MarkMethodCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Conveyor>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Conveyor* response) { return this->GetConveyor(context, request, response); }));}
    void SetMessageAllocatorFor_GetConveyor(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Conveyor>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Conveyor>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyor(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Conveyor* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetConveyorName(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorName(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorName(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Name* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetConveyorByName(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorByName(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorByName(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Encoder, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Encoder* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetConveyorEncoder(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorEncoder(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Encoder, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Encoder, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Encoder* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorEncoder(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Encoder* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Trigger, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Trigger* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetConveyorTrigger(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorTrigger(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Trigger, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Trigger, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Trigger* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTrigger(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Trigger* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Float, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Float* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetConveyorOffset(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorOffset(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Float, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Float, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Float* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Float* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetConveyorStartingPose(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorStartingPose(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorStartingPose(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::PosePair* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetConveyorTerminalPose(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorTerminalPose(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTerminalPose(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ConveyorState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ConveyorState* response) { return this->GetConveyorState(context, request, response); }));}
    void SetMessageAllocatorFor_GetConveyorState(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ConveyorState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ConveyorState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyorState(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ConveyorState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HoldToMoveConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HoldToMoveConveyor() {
      ::grpc::Service::MarkMethodCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->HoldToMoveConveyor(context, request, response); }));}
    void SetMessageAllocatorFor_HoldToMoveConveyor(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(64);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HoldToMoveConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToMoveConveyor(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConveyorList() {
      ::grpc::Service::MarkMethodCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetConveyorListReq, ::IndyFramework::Protobuf::HRI::GetConveyorListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* response) { return this->GetConveyorList(context, request, response); }));}
    void SetMessageAllocatorFor_GetConveyorList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetConveyorListReq, ::IndyFramework::Protobuf::HRI::GetConveyorListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(65);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetConveyorListReq, ::IndyFramework::Protobuf::HRI::GetConveyorListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyorList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetConveyorList() {
      ::grpc::Service::MarkMethodCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetConveyorListReq, ::IndyFramework::Protobuf::HRI::SetConveyorListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* request, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* response) { return this->SetConveyorList(context, request, response); }));}
    void SetMessageAllocatorFor_SetConveyorList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetConveyorListReq, ::IndyFramework::Protobuf::HRI::SetConveyorListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(66);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetConveyorListReq, ::IndyFramework::Protobuf::HRI::SetConveyorListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetInching() {
      ::grpc::Service::MarkMethodCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetInchingReq, ::IndyFramework::Protobuf::HRI::SetInchingRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetInchingReq* request, ::IndyFramework::Protobuf::HRI::SetInchingRes* response) { return this->SetInching(context, request, response); }));}
    void SetMessageAllocatorFor_SetInching(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetInchingReq, ::IndyFramework::Protobuf::HRI::SetInchingRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(67);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetInchingReq, ::IndyFramework::Protobuf::HRI::SetInchingRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetInching(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetInchingRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopInching() {
      ::grpc::Service::MarkMethodCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::StopInchingReq, ::IndyFramework::Protobuf::HRI::StopInchingRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::StopInchingReq* request, ::IndyFramework::Protobuf::HRI::StopInchingRes* response) { return this->StopInching(context, request, response); }));}
    void SetMessageAllocatorFor_StopInching(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::StopInchingReq, ::IndyFramework::Protobuf::HRI::StopInchingRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(68);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::StopInchingReq, ::IndyFramework::Protobuf::HRI::StopInchingRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopInching(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopInchingRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetArc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetArc() {
      ::grpc::Service::MarkMethodCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetArcReq, ::IndyFramework::Protobuf::HRI::SetArcRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetArcReq* request, ::IndyFramework::Protobuf::HRI::SetArcRes* response) { return this->SetArc(context, request, response); }));}
    void SetMessageAllocatorFor_SetArc(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetArcReq, ::IndyFramework::Protobuf::HRI::SetArcRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(69);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetArcReq, ::IndyFramework::Protobuf::HRI::SetArcRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetArc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetArc(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetArcReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetArcRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetArc(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetArcReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetArcRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetTouch() {
      ::grpc::Service::MarkMethodCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetTouchReq, ::IndyFramework::Protobuf::HRI::SetTouchRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetTouchReq* request, ::IndyFramework::Protobuf::HRI::SetTouchRes* response) { return this->SetTouch(context, request, response); }));}
    void SetMessageAllocatorFor_SetTouch(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetTouchReq, ::IndyFramework::Protobuf::HRI::SetTouchRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(70);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetTouchReq, ::IndyFramework::Protobuf::HRI::SetTouchRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTouch(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTouchReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTouchRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTouch(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTouchReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTouchRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetGas : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetGas() {
      ::grpc::Service::MarkMethodCallback(71,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetGasReq, ::IndyFramework::Protobuf::HRI::SetGasRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetGasReq* request, ::IndyFramework::Protobuf::HRI::SetGasRes* response) { return this->SetGas(context, request, response); }));}
    void SetMessageAllocatorFor_SetGas(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetGasReq, ::IndyFramework::Protobuf::HRI::SetGasRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(71);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetGasReq, ::IndyFramework::Protobuf::HRI::SetGasRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetGas() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGas(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetGasReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetGasRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetGas(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetGasReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetGasRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsTouched : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsTouched() {
      ::grpc::Service::MarkMethodCallback(72,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::IsTouchedReq, ::IndyFramework::Protobuf::HRI::IsTouchedRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* request, ::IndyFramework::Protobuf::HRI::IsTouchedRes* response) { return this->IsTouched(context, request, response); }));}
    void SetMessageAllocatorFor_IsTouched(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::IsTouchedReq, ::IndyFramework::Protobuf::HRI::IsTouchedRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(72);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::IsTouchedReq, ::IndyFramework::Protobuf::HRI::IsTouchedRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsTouched() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTouched(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* /*request*/, ::IndyFramework::Protobuf::HRI::IsTouchedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsTouched(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* /*request*/, ::IndyFramework::Protobuf::HRI::IsTouchedRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVisionServerList() {
      ::grpc::Service::MarkMethodCallback(73,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetVisionServerListReq, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* response) { return this->GetVisionServerList(context, request, response); }));}
    void SetMessageAllocatorFor_GetVisionServerList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetVisionServerListReq, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(73);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetVisionServerListReq, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetVisionServerList() {
      ::grpc::Service::MarkMethodCallback(74,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetVisionServerListReq, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* request, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* response) { return this->SetVisionServerList(context, request, response); }));}
    void SetMessageAllocatorFor_SetVisionServerList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetVisionServerListReq, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(74);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetVisionServerListReq, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVisionServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVisionObjectList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVisionObjectList() {
      ::grpc::Service::MarkMethodCallback(75,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* request, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* response) { return this->GetVisionObjectList(context, request, response); }));}
    void SetMessageAllocatorFor_GetVisionObjectList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(75);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVisionObjectList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionObjectList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionObjectList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVisionDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVisionDetection() {
      ::grpc::Service::MarkMethodCallback(76,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response) { return this->GetVisionDetection(context, request, response); }));}
    void SetMessageAllocatorFor_GetVisionDetection(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(76);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVisionDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionDetection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVisionRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVisionRetrieval() {
      ::grpc::Service::MarkMethodCallback(77,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::VisionRequest* request, ::IndyFramework::Protobuf::HRI::VisionResult* response) { return this->GetVisionRetrieval(context, request, response); }));}
    void SetMessageAllocatorFor_GetVisionRetrieval(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(77);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVisionRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionRetrieval(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionRetrieval(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGcodeMotionList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGcodeMotionList() {
      ::grpc::Service::MarkMethodCallback(78,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* request, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* response) { return this->GetGcodeMotionList(context, request, response); }));}
    void SetMessageAllocatorFor_GetGcodeMotionList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(78);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGcodeMotionList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGcodeMotionList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGcodeMotionList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetModbusServerList() {
      ::grpc::Service::MarkMethodCallback(79,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetModbusServerListReq, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* response) { return this->GetModbusServerList(context, request, response); }));}
    void SetMessageAllocatorFor_GetModbusServerList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetModbusServerListReq, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(79);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetModbusServerListReq, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModbusServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetModbusServerList() {
      ::grpc::Service::MarkMethodCallback(80,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetModbusServerListReq, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* request, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* response) { return this->SetModbusServerList(context, request, response); }));}
    void SetMessageAllocatorFor_SetModbusServerList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetModbusServerListReq, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(80);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetModbusServerListReq, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetModbusServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckModbusConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckModbusConnection() {
      ::grpc::Service::MarkMethodCallback(81,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* request, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* response) { return this->CheckModbusConnection(context, request, response); }));}
    void SetMessageAllocatorFor_CheckModbusConnection(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(81);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckModbusConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckModbusConnection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckModbusConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetToolFrameList() {
      ::grpc::Service::MarkMethodCallback(82,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetToolFrameListReq, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* response) { return this->GetToolFrameList(context, request, response); }));}
    void SetMessageAllocatorFor_GetToolFrameList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetToolFrameListReq, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(82);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetToolFrameListReq, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetToolFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetToolFrameList() {
      ::grpc::Service::MarkMethodCallback(83,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetToolFrameListReq, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* response) { return this->SetToolFrameList(context, request, response); }));}
    void SetMessageAllocatorFor_SetToolFrameList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetToolFrameListReq, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(83);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetToolFrameListReq, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRefFrameList() {
      ::grpc::Service::MarkMethodCallback(84,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetRefFrameListReq, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* response) { return this->GetRefFrameList(context, request, response); }));}
    void SetMessageAllocatorFor_GetRefFrameList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetRefFrameListReq, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(84);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetRefFrameListReq, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRefFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRefFrameList() {
      ::grpc::Service::MarkMethodCallback(85,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetRefFrameListReq, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* request, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* response) { return this->SetRefFrameList(context, request, response); }));}
    void SetMessageAllocatorFor_SetRefFrameList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetRefFrameListReq, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(85);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetRefFrameListReq, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRefFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCustomPosList() {
      ::grpc::Service::MarkMethodCallback(86,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetCustomPosListReq, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* response) { return this->GetCustomPosList(context, request, response); }));}
    void SetMessageAllocatorFor_GetCustomPosList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetCustomPosListReq, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(86);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetCustomPosListReq, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCustomPosList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCustomPosList() {
      ::grpc::Service::MarkMethodCallback(87,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetCustomPosListReq, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* request, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* response) { return this->SetCustomPosList(context, request, response); }));}
    void SetMessageAllocatorFor_SetCustomPosList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetCustomPosListReq, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(87);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetCustomPosListReq, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCustomPosList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodCallback(88,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetJointControlGainReq, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* response) { return this->SetJointControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_SetJointControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetJointControlGainReq, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(88);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetJointControlGainReq, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodCallback(89,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetJointControlGainReq, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* response) { return this->GetJointControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetJointControlGainReq, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(89);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetJointControlGainReq, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodCallback(90,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* response) { return this->SetTaskControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_SetTaskControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(90);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTaskControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodCallback(91,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* response) { return this->GetTaskControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_GetTaskControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(91);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTaskControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodCallback(92,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* response) { return this->SetImpedanceControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_SetImpedanceControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(92);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetImpedanceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodCallback(93,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* response) { return this->GetImpedanceControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_GetImpedanceControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(93);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetImpedanceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetForceControlGain() {
      ::grpc::Service::MarkMethodCallback(94,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetForceControlGainReq, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* response) { return this->SetForceControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_SetForceControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetForceControlGainReq, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(94);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetForceControlGainReq, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetForceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetForceControlGain() {
      ::grpc::Service::MarkMethodCallback(95,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetForceControlGainReq, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* response) { return this->GetForceControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_GetForceControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetForceControlGainReq, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(95);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetForceControlGainReq, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetForceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetExtAxisControlGain() {
      ::grpc::Service::MarkMethodCallback(96,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* response) { return this->SetExtAxisControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_SetExtAxisControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(96);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetExtAxisControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetExtAxisControlGain() {
      ::grpc::Service::MarkMethodCallback(97,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* request, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* response) { return this->GetExtAxisControlGain(context, request, response); }));}
    void SetMessageAllocatorFor_GetExtAxisControlGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(97);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetExtAxisControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodCallback(98,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response) { return this->SetSensorlessComplianceControlJointGain(context, request, response); }));}
    void SetMessageAllocatorFor_SetSensorlessComplianceControlJointGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(98);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSensorlessComplianceControlJointGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodCallback(99,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response) { return this->GetSensorlessComplianceControlJointGain(context, request, response); }));}
    void SetMessageAllocatorFor_GetSensorlessComplianceControlJointGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(99);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSensorlessComplianceControlJointGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodCallback(100,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* response) { return this->SetSensorlessComplianceControlTaskGain(context, request, response); }));}
    void SetMessageAllocatorFor_SetSensorlessComplianceControlTaskGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(100);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSensorlessComplianceControlTaskGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodCallback(101,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* request, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* response) { return this->GetSensorlessComplianceControlTaskGain(context, request, response); }));}
    void SetMessageAllocatorFor_GetSensorlessComplianceControlTaskGain(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(101);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSensorlessComplianceControlTaskGain(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetFricComp() {
      ::grpc::Service::MarkMethodCallback(102,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetFricCompReq, ::IndyFramework::Protobuf::HRI::SetFricCompRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* request, ::IndyFramework::Protobuf::HRI::SetFricCompRes* response) { return this->SetFricComp(context, request, response); }));}
    void SetMessageAllocatorFor_SetFricComp(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetFricCompReq, ::IndyFramework::Protobuf::HRI::SetFricCompRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(102);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetFricCompReq, ::IndyFramework::Protobuf::HRI::SetFricCompRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFricComp(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetFricCompRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFricComp() {
      ::grpc::Service::MarkMethodCallback(103,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetFricCompReq, ::IndyFramework::Protobuf::HRI::GetFricCompRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* request, ::IndyFramework::Protobuf::HRI::GetFricCompRes* response) { return this->GetFricComp(context, request, response); }));}
    void SetMessageAllocatorFor_GetFricComp(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetFricCompReq, ::IndyFramework::Protobuf::HRI::GetFricCompRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(103);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetFricCompReq, ::IndyFramework::Protobuf::HRI::GetFricCompRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFricComp(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetFricCompRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetHomePos() {
      ::grpc::Service::MarkMethodCallback(104,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetHomePosReq, ::IndyFramework::Protobuf::HRI::SetHomePosRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* request, ::IndyFramework::Protobuf::HRI::SetHomePosRes* response) { return this->SetHomePos(context, request, response); }));}
    void SetMessageAllocatorFor_SetHomePos(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetHomePosReq, ::IndyFramework::Protobuf::HRI::SetHomePosRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(104);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetHomePosReq, ::IndyFramework::Protobuf::HRI::SetHomePosRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetHomePos(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetHomePosRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetHomePos() {
      ::grpc::Service::MarkMethodCallback(105,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetHomePosReq, ::IndyFramework::Protobuf::HRI::GetHomePosRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* request, ::IndyFramework::Protobuf::HRI::GetHomePosRes* response) { return this->GetHomePos(context, request, response); }));}
    void SetMessageAllocatorFor_GetHomePos(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetHomePosReq, ::IndyFramework::Protobuf::HRI::GetHomePosRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(105);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetHomePosReq, ::IndyFramework::Protobuf::HRI::GetHomePosRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetHomePos(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetHomePosRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetMountPos() {
      ::grpc::Service::MarkMethodCallback(106,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetMountPosReq, ::IndyFramework::Protobuf::HRI::SetMountPosRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* request, ::IndyFramework::Protobuf::HRI::SetMountPosRes* response) { return this->SetMountPos(context, request, response); }));}
    void SetMessageAllocatorFor_SetMountPos(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetMountPosReq, ::IndyFramework::Protobuf::HRI::SetMountPosRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(106);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetMountPosReq, ::IndyFramework::Protobuf::HRI::SetMountPosRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetMountPos(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMountPosRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMountPos() {
      ::grpc::Service::MarkMethodCallback(107,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetMountPosReq, ::IndyFramework::Protobuf::HRI::GetMountPosRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* request, ::IndyFramework::Protobuf::HRI::GetMountPosRes* response) { return this->GetMountPos(context, request, response); }));}
    void SetMessageAllocatorFor_GetMountPos(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetMountPosReq, ::IndyFramework::Protobuf::HRI::GetMountPosRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(107);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetMountPosReq, ::IndyFramework::Protobuf::HRI::GetMountPosRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMountPos(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMountPosRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPackagingPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPackagingPos() {
      ::grpc::Service::MarkMethodCallback(108,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetPackagingPosReq, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* request, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* response) { return this->GetPackagingPos(context, request, response); }));}
    void SetMessageAllocatorFor_GetPackagingPos(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetPackagingPosReq, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(108);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetPackagingPosReq, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPackagingPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPackagingPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPackagingPos(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodCallback(109,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetToolPropertyReq, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* response) { return this->SetToolProperty(context, request, response); }));}
    void SetMessageAllocatorFor_SetToolProperty(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetToolPropertyReq, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(109);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetToolPropertyReq, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolProperty(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodCallback(110,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetToolPropertyReq, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* request, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* response) { return this->GetToolProperty(context, request, response); }));}
    void SetMessageAllocatorFor_GetToolProperty(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetToolPropertyReq, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(110);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetToolPropertyReq, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetToolProperty(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodCallback(111,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* response) { return this->GetOnStartProgramConfig(context, request, response); }));}
    void SetMessageAllocatorFor_GetOnStartProgramConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(111);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOnStartProgramConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodCallback(112,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* request, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* response) { return this->SetOnStartProgramConfig(context, request, response); }));}
    void SetMessageAllocatorFor_SetOnStartProgramConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(112);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetOnStartProgramConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodCallback(113,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* response) { return this->GetSafetyLimitConfig(context, request, response); }));}
    void SetMessageAllocatorFor_GetSafetyLimitConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(113);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyLimitConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodCallback(114,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* response) { return this->SetSafetyLimitConfig(context, request, response); }));}
    void SetMessageAllocatorFor_SetSafetyLimitConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(114);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSafetyLimitConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodCallback(115,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* response) { return this->GetSafetyStopConfig(context, request, response); }));}
    void SetMessageAllocatorFor_GetSafetyStopConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(115);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyStopConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodCallback(116,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* request, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* response) { return this->SetSafetyStopConfig(context, request, response); }));}
    void SetMessageAllocatorFor_SetSafetyStopConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(116);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSafetyStopConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSafetyConfigHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSafetyConfigHash() {
      ::grpc::Service::MarkMethodCallback(117,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* request, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* response) { return this->GetSafetyConfigHash(context, request, response); }));}
    void SetMessageAllocatorFor_GetSafetyConfigHash(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(117);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSafetyConfigHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyConfigHash(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyConfigHash(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetKinematicsParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetKinematicsParams() {
      ::grpc::Service::MarkMethodCallback(118,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::KinematicsParams>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::KinematicsParams* response) { return this->GetKinematicsParams(context, request, response); }));}
    void SetMessageAllocatorFor_GetKinematicsParams(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::KinematicsParams>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(118);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::KinematicsParams>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetKinematicsParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKinematicsParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::KinematicsParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetKinematicsParams(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::KinematicsParams* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_KeyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_KeyInit() {
      ::grpc::Service::MarkMethodCallback(119,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::KeyInitReq, ::IndyFramework::Protobuf::HRI::KeyInitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::KeyInitReq* request, ::IndyFramework::Protobuf::HRI::KeyInitRes* response) { return this->KeyInit(context, request, response); }));}
    void SetMessageAllocatorFor_KeyInit(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::KeyInitReq, ::IndyFramework::Protobuf::HRI::KeyInitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(119);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::KeyInitReq, ::IndyFramework::Protobuf::HRI::KeyInitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_KeyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyInit(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyInitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_KeyData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_KeyData() {
      ::grpc::Service::MarkMethodCallback(120,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::KeyDataReq, ::IndyFramework::Protobuf::HRI::KeyDataRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::KeyDataReq* request, ::IndyFramework::Protobuf::HRI::KeyDataRes* response) { return this->KeyData(context, request, response); }));}
    void SetMessageAllocatorFor_KeyData(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::KeyDataReq, ::IndyFramework::Protobuf::HRI::KeyDataRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(120);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::KeyDataReq, ::IndyFramework::Protobuf::HRI::KeyDataRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_KeyData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyDataReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyData(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyDataReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyDataRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProgramUpdateKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ProgramUpdateKey() {
      ::grpc::Service::MarkMethodCallback(121,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ProgramData* response) { return this->ProgramUpdateKey(context, request, response); }));}
    void SetMessageAllocatorFor_ProgramUpdateKey(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(121);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProgramUpdateKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdateKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProgramUpdateKey(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDirectTeachingModeKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDirectTeachingModeKey() {
      ::grpc::Service::MarkMethodCallback(122,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* request, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* response) { return this->SetDirectTeachingModeKey(context, request, response); }));}
    void SetMessageAllocatorFor_SetDirectTeachingModeKey(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(122);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDirectTeachingModeKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingModeKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDirectTeachingModeKey(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAutoModeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAutoModeConfig() {
      ::grpc::Service::MarkMethodCallback(123,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* response) { return this->GetAutoModeConfig(context, request, response); }));}
    void SetMessageAllocatorFor_GetAutoModeConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(123);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAutoModeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoModeConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAutoModeConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodCallback(124,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetAutoModeReq, ::IndyFramework::Protobuf::HRI::SetAutoModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* request, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* response) { return this->SetAutoMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetAutoMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetAutoModeReq, ::IndyFramework::Protobuf::HRI::SetAutoModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(124);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetAutoModeReq, ::IndyFramework::Protobuf::HRI::SetAutoModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodCallback(125,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* response) { return this->CheckAutoMode(context, request, response); }));}
    void SetMessageAllocatorFor_CheckAutoMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(125);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodCallback(126,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* response) { return this->CheckReducedMode(context, request, response); }));}
    void SetMessageAllocatorFor_CheckReducedMode(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(126);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckReducedMode(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetReducedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetReducedRatio() {
      ::grpc::Service::MarkMethodCallback(127,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* response) { return this->GetReducedRatio(context, request, response); }));}
    void SetMessageAllocatorFor_GetReducedRatio(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(127);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetReducedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetReducedRatio(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetReducedSpeed() {
      ::grpc::Service::MarkMethodCallback(128,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* response) { return this->GetReducedSpeed(context, request, response); }));}
    void SetMessageAllocatorFor_GetReducedSpeed(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(128);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetReducedSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetReducedSpeed() {
      ::grpc::Service::MarkMethodCallback(129,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetReducedSpeed(context, request, response); }));}
    void SetMessageAllocatorFor_SetReducedSpeed(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(129);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetReducedSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStopState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStopState() {
      ::grpc::Service::MarkMethodCallback(130,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::StopState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::StopState* response) { return this->GetStopState(context, request, response); }));}
    void SetMessageAllocatorFor_GetStopState(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::StopState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(130);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::StopState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetStopState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStopState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::StopState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStopState(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::StopState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodCallback(131,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SafetyFunctionState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* response) { return this->GetSafetyFunctionState(context, request, response); }));}
    void SetMessageAllocatorFor_GetSafetyFunctionState(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SafetyFunctionState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(131);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SafetyFunctionState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyFunctionState(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodCallback(132,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SafetyFunctionState, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->RequestSafetyFunction(context, request, response); }));}
    void SetMessageAllocatorFor_RequestSafetyFunction(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SafetyFunctionState, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(132);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SafetyFunctionState, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestSafetyFunction(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayProgram() {
      ::grpc::Service::MarkMethodCallback(133,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PlayProgramReq, ::IndyFramework::Protobuf::HRI::PlayProgramRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramRes* response) { return this->PlayProgram(context, request, response); }));}
    void SetMessageAllocatorFor_PlayProgram(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::PlayProgramReq, ::IndyFramework::Protobuf::HRI::PlayProgramRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(133);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PlayProgramReq, ::IndyFramework::Protobuf::HRI::PlayProgramRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PlayIndexProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayIndexProgram() {
      ::grpc::Service::MarkMethodCallback(134,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* request, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* response) { return this->PlayIndexProgram(context, request, response); }));}
    void SetMessageAllocatorFor_PlayIndexProgram(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(134);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayIndexProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayIndexProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayIndexProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PlayProgramLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayProgramLine() {
      ::grpc::Service::MarkMethodCallback(135,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PlayProgramLineReq, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* request, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* response) { return this->PlayProgramLine(context, request, response); }));}
    void SetMessageAllocatorFor_PlayProgramLine(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::PlayProgramLineReq, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(135);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PlayProgramLineReq, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayProgramLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgramLine(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayProgramLine(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodCallback(136,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::ResumeProgramReq, ::IndyFramework::Protobuf::HRI::ResumeProgramRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* request, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* response) { return this->ResumeProgram(context, request, response); }));}
    void SetMessageAllocatorFor_ResumeProgram(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::ResumeProgramReq, ::IndyFramework::Protobuf::HRI::ResumeProgramRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(136);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::ResumeProgramReq, ::IndyFramework::Protobuf::HRI::ResumeProgramRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopProgram() {
      ::grpc::Service::MarkMethodCallback(137,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::StopProgramReq, ::IndyFramework::Protobuf::HRI::StopProgramRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::StopProgramReq* request, ::IndyFramework::Protobuf::HRI::StopProgramRes* response) { return this->StopProgram(context, request, response); }));}
    void SetMessageAllocatorFor_StopProgram(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::StopProgramReq, ::IndyFramework::Protobuf::HRI::StopProgramRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(137);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::StopProgramReq, ::IndyFramework::Protobuf::HRI::StopProgramRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopProgramRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseProgram() {
      ::grpc::Service::MarkMethodCallback(138,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PauseProgramReq, ::IndyFramework::Protobuf::HRI::PauseProgramRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* request, ::IndyFramework::Protobuf::HRI::PauseProgramRes* response) { return this->PauseProgram(context, request, response); }));}
    void SetMessageAllocatorFor_PauseProgram(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::PauseProgramReq, ::IndyFramework::Protobuf::HRI::PauseProgramRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(138);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::PauseProgramReq, ::IndyFramework::Protobuf::HRI::PauseProgramRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PauseProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PauseProgramRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDO() {
      ::grpc::Service::MarkMethodCallback(139,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::DOSignals, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::DOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetDO(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::DOSignals, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(139);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::DOSignals, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAO() {
      ::grpc::Service::MarkMethodCallback(140,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetAO(context, request, response); }));}
    void SetMessageAllocatorFor_SetAO(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(140);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAO(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndDO() {
      ::grpc::Service::MarkMethodCallback(141,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::EndtoolSignalList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetEndDO(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndDO(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::EndtoolSignalList, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(141);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::EndtoolSignalList, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndDO(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEndAO() {
      ::grpc::Service::MarkMethodCallback(142,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::AOSignals* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetEndAO(context, request, response); }));}
    void SetMessageAllocatorFor_SetEndAO(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(142);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndAO(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetToolList() {
      ::grpc::Service::MarkMethodCallback(143,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::ToolList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::ToolList* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetToolList(context, request, response); }));}
    void SetMessageAllocatorFor_SetToolList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::ToolList, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(143);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::ToolList, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ToolList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ToolList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetToolList() {
      ::grpc::Service::MarkMethodCallback(144,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ToolList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::ToolList* response) { return this->GetToolList(context, request, response); }));}
    void SetMessageAllocatorFor_GetToolList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ToolList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(144);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ToolList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ToolList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetToolList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ToolList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDIConfigList() {
      ::grpc::Service::MarkMethodCallback(145,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::DIConfigList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::DIConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetDIConfigList(context, request, response); }));}
    void SetMessageAllocatorFor_SetDIConfigList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::DIConfigList, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(145);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::DIConfigList, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DIConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDIConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DIConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDIConfigList() {
      ::grpc::Service::MarkMethodCallback(146,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DIConfigList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DIConfigList* response) { return this->GetDIConfigList(context, request, response); }));}
    void SetMessageAllocatorFor_GetDIConfigList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DIConfigList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(146);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DIConfigList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DIConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDIConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DIConfigList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetDOConfigList() {
      ::grpc::Service::MarkMethodCallback(147,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::DOConfigList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::DOConfigList* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetDOConfigList(context, request, response); }));}
    void SetMessageAllocatorFor_SetDOConfigList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::DOConfigList, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(147);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::DOConfigList, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDOConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDOConfigList() {
      ::grpc::Service::MarkMethodCallback(148,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DOConfigList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::DOConfigList* response) { return this->GetDOConfigList(context, request, response); }));}
    void SetMessageAllocatorFor_GetDOConfigList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DOConfigList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(148);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DOConfigList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DOConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDOConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DOConfigList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodCallback(149,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CollisionSensLevel, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetCollSensLevel(context, request, response); }));}
    void SetMessageAllocatorFor_SetCollSensLevel(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::CollisionSensLevel, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(149);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CollisionSensLevel, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCollSensLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodCallback(150,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionSensLevel>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* response) { return this->GetCollSensLevel(context, request, response); }));}
    void SetMessageAllocatorFor_GetCollSensLevel(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionSensLevel>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(150);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionSensLevel>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollSensLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodCallback(151,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CollisionPolicy, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetCollPolicy(context, request, response); }));}
    void SetMessageAllocatorFor_SetCollPolicy(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::CollisionPolicy, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(151);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CollisionPolicy, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCollPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodCallback(152,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionPolicy>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionPolicy* response) { return this->GetCollPolicy(context, request, response); }));}
    void SetMessageAllocatorFor_GetCollPolicy(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionPolicy>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(152);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionPolicy>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodCallback(153,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CollisionThresholds, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetCollSensParam(context, request, response); }));}
    void SetMessageAllocatorFor_SetCollSensParam(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::CollisionThresholds, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(153);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::CollisionThresholds, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCollSensParam(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodCallback(154,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionThresholds>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response) { return this->GetCollSensParam(context, request, response); }));}
    void SetMessageAllocatorFor_GetCollSensParam(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionThresholds>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(154);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionThresholds>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollSensParam(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InitCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InitCollSensParam() {
      ::grpc::Service::MarkMethodCallback(155,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->InitCollSensParam(context, request, response); }));}
    void SetMessageAllocatorFor_InitCollSensParam(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(155);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InitCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InitCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InitCollSensParam(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodCallback(156,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TuningProgram, ::IndyFramework::Protobuf::HRI::CollisionThresholds>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::TuningProgram* request, ::IndyFramework::Protobuf::HRI::CollisionThresholds* response) { return this->PlayTuningProgram(context, request, response); }));}
    void SetMessageAllocatorFor_PlayTuningProgram(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::TuningProgram, ::IndyFramework::Protobuf::HRI::CollisionThresholds>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(156);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TuningProgram, ::IndyFramework::Protobuf::HRI::CollisionThresholds>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TuningProgram* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayTuningProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TuningProgram* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodCallback(157,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpDevice>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpDevice* response) { return this->GetTeleOpDevice(context, request, response); }));}
    void SetMessageAllocatorFor_GetTeleOpDevice(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpDevice>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(157);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpDevice>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodCallback(158,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpState* response) { return this->GetTeleOpState(context, request, response); }));}
    void SetMessageAllocatorFor_GetTeleOpState(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(158);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpState(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodCallback(159,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleOpDevice, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->ConnectTeleOpDevice(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectTeleOpDevice(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::TeleOpDevice, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(159);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleOpDevice, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodCallback(160,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->DisConnectTeleOpDevice(context, request, response); }));}
    void SetMessageAllocatorFor_DisConnectTeleOpDevice(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(160);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodCallback(161,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleP>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleP* response) { return this->ReadTeleOpInput(context, request, response); }));}
    void SetMessageAllocatorFor_ReadTeleOpInput(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleP>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(161);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleP>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadTeleOpInput(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleP* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartTeleCalib : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartTeleCalib() {
      ::grpc::Service::MarkMethodCallback(162,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->StartTeleCalib(context, request, response); }));}
    void SetMessageAllocatorFor_StartTeleCalib(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(162);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartTeleCalib() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleCalib(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleCalib(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartTeleRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartTeleRecord() {
      ::grpc::Service::MarkMethodCallback(163,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->StartTeleRecord(context, request, response); }));}
    void SetMessageAllocatorFor_StartTeleRecord(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(163);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartTeleRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleRecord(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartTelePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartTelePlay() {
      ::grpc::Service::MarkMethodCallback(164,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->StartTelePlay(context, request, response); }));}
    void SetMessageAllocatorFor_StartTelePlay(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(164);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartTelePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTelePlay(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTelePlay(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartTeleJogL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartTeleJogL() {
      ::grpc::Service::MarkMethodCallback(165,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->StartTeleJogL(context, request, response); }));}
    void SetMessageAllocatorFor_StartTeleJogL(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(165);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartTeleJogL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleJogL(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartTeleJogJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartTeleJogJ() {
      ::grpc::Service::MarkMethodCallback(166,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->StartTeleJogJ(context, request, response); }));}
    void SetMessageAllocatorFor_StartTeleJogJ(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(166);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartTeleJogJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleJogJ(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodCallback(167,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->StopTeleOp(context, request, response); }));}
    void SetMessageAllocatorFor_StopTeleOp(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(167);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopTeleOp(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodCallback(168,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TelePlayRate, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::TelePlayRate* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetPlayRate(context, request, response); }));}
    void SetMessageAllocatorFor_SetPlayRate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::TelePlayRate, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(168);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TelePlayRate, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TelePlayRate* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TelePlayRate* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodCallback(169,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TelePlayRate>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TelePlayRate* response) { return this->GetPlayRate(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayRate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TelePlayRate>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(169);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TelePlayRate>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TelePlayRate* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodCallback(170,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpFileList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpFileList* response) { return this->GetTeleFileList(context, request, response); }));}
    void SetMessageAllocatorFor_GetTeleFileList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpFileList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(170);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpFileList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpFileList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodCallback(171,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SaveTeleMotion(context, request, response); }));}
    void SetMessageAllocatorFor_SaveTeleMotion(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(171);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodCallback(172,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->LoadTeleMotion(context, request, response); }));}
    void SetMessageAllocatorFor_LoadTeleMotion(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(172);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodCallback(173,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleFileReq* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->DeleteTeleMotion(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteTeleMotion(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(173);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodCallback(174,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveTeleJReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->MoveTeleJ(context, request, response); }));}
    void SetMessageAllocatorFor_MoveTeleJ(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::MoveTeleJReq, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(174);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveTeleJReq, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleJ(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodCallback(175,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveTeleLReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->MoveTeleL(context, request, response); }));}
    void SetMessageAllocatorFor_MoveTeleL(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::MoveTeleLReq, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(175);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::MoveTeleLReq, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleL(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetTeleOpParams() {
      ::grpc::Service::MarkMethodCallback(176,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleOpParams, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::TeleOpParams* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetTeleOpParams(context, request, response); }));}
    void SetMessageAllocatorFor_SetTeleOpParams(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::TeleOpParams, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(176);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::TeleOpParams, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpParams* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTeleOpParams(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpParams* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTeleOpParams() {
      ::grpc::Service::MarkMethodCallback(177,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpParams>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TeleOpParams* response) { return this->GetTeleOpParams(context, request, response); }));}
    void SetMessageAllocatorFor_GetTeleOpParams(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpParams>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(177);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpParams>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpParams(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpParams* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetFTSensorConfig() {
      ::grpc::Service::MarkMethodCallback(178,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::FTSensorDevice, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetFTSensorConfig(context, request, response); }));}
    void SetMessageAllocatorFor_SetFTSensorConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::FTSensorDevice, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(178);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::FTSensorDevice, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFTSensorConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFTSensorConfig() {
      ::grpc::Service::MarkMethodCallback(179,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorDevice>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorDevice* response) { return this->GetFTSensorConfig(context, request, response); }));}
    void SetMessageAllocatorFor_GetFTSensorConfig(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorDevice>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(179);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorDevice>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFTSensorConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodCallback(180,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::FTSensorData* response) { return this->GetFTSensorData(context, request, response); }));}
    void SetMessageAllocatorFor_GetFTSensorData(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(180);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFTSensorData(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodCallback(181,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* response) { return this->GetLoadFactors(context, request, response); }));}
    void SetMessageAllocatorFor_GetLoadFactors(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(181);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLoadFactors(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodCallback(182,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SanderCommand, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SanderCommand* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetSanderCommand(context, request, response); }));}
    void SetMessageAllocatorFor_SetSanderCommand(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SanderCommand, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(182);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SanderCommand, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SanderCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SanderCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodCallback(183,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SanderCommand>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SanderCommand* response) { return this->GetSanderCommand(context, request, response); }));}
    void SetMessageAllocatorFor_GetSanderCommand(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SanderCommand>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(183);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SanderCommand>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SanderCommand* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSandingStopCondition() {
      ::grpc::Service::MarkMethodCallback(184,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SandingStopConditionState, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetSandingStopCondition(context, request, response); }));}
    void SetMessageAllocatorFor_SetSandingStopCondition(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SandingStopConditionState, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(184);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SandingStopConditionState, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSandingStopCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSandingStopCondition() {
      ::grpc::Service::MarkMethodCallback(185,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SandingStopConditionState>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* response) { return this->GetSandingStopCondition(context, request, response); }));}
    void SetMessageAllocatorFor_GetSandingStopCondition(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SandingStopConditionState>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(185);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SandingStopConditionState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSandingStopCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGripperData() {
      ::grpc::Service::MarkMethodCallback(186,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GripperData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::GripperData* response) { return this->GetGripperData(context, request, response); }));}
    void SetMessageAllocatorFor_GetGripperData(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GripperData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(186);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GripperData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGripperData(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GripperData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodCallback(187,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GripperCommand, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::GripperCommand* request, ::IndyFramework::Protobuf::HRI::Empty* response) { return this->SetGripperCommand(context, request, response); }));}
    void SetMessageAllocatorFor_SetGripperCommand(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::GripperCommand, ::IndyFramework::Protobuf::HRI::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(187);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::GripperCommand, ::IndyFramework::Protobuf::HRI::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GripperCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetGripperCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GripperCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSFDActivate() {
      ::grpc::Service::MarkMethodCallback(188,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetSFDActivate(context, request, response); }));}
    void SetMessageAllocatorFor_SetSFDActivate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(188);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSFDActivate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsSFDActivate() {
      ::grpc::Service::MarkMethodCallback(189,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response) { return this->IsSFDActivate(context, request, response); }));}
    void SetMessageAllocatorFor_IsSFDActivate(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(189);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsSFDActivate(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SFDLogin() {
      ::grpc::Service::MarkMethodCallback(190,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SFDAccount, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SFDAccount* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SFDLogin(context, request, response); }));}
    void SetMessageAllocatorFor_SFDLogin(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SFDAccount, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(190);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SFDAccount, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDAccount* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SFDLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDAccount* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsSFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsSFDLogin() {
      ::grpc::Service::MarkMethodCallback(191,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::State* response) { return this->IsSFDLogin(context, request, response); }));}
    void SetMessageAllocatorFor_IsSFDLogin(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(191);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsSFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsSFDLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSFDTarget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSFDTarget() {
      ::grpc::Service::MarkMethodCallback(192,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SFDCriTarget, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetSFDTarget(context, request, response); }));}
    void SetMessageAllocatorFor_SetSFDTarget(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::SFDCriTarget, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(192);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::SFDCriTarget, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSFDTarget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDTarget(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSFDTarget(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSFDOption : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSFDOption() {
      ::grpc::Service::MarkMethodCallback(193,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::State* request, ::IndyFramework::Protobuf::HRI::Response* response) { return this->SetSFDOption(context, request, response); }));}
    void SetMessageAllocatorFor_SetSFDOption(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(193);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSFDOption() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDOption(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSFDOption(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSFDProjList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSFDProjList() {
      ::grpc::Service::MarkMethodCallback(194,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDProjectList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDProjectList* response) { return this->GetSFDProjList(context, request, response); }));}
    void SetMessageAllocatorFor_GetSFDProjList(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDProjectList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(194);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDProjectList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSFDProjList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDProjList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDProjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSFDProjList(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDProjectList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSFDCRI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSFDCRI() {
      ::grpc::Service::MarkMethodCallback(195,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDCriData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::SFDCriData* response) { return this->GetSFDCRI(context, request, response); }));}
    void SetMessageAllocatorFor_GetSFDCRI(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDCriData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(195);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDCriData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSFDCRI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDCRI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDCriData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSFDCRI(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDCriData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTactTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTactTime() {
      ::grpc::Service::MarkMethodCallback(196,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TactTime>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::Empty* request, ::IndyFramework::Protobuf::HRI::TactTime* response) { return this->GetTactTime(context, request, response); }));}
    void SetMessageAllocatorFor_GetTactTime(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TactTime>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(196);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TactTime>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTactTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTactTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TactTime* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTactTime(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TactTime* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodCallback(197,
          new ::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* request, ::IndyFramework::Protobuf::HRI::Empty* response) { return this->AddPhotoneoCalibPoint(context, request, response); }));}
    void SetMessageAllocatorFor_AddPhotoneoCalibPoint(
        ::grpc::MessageAllocator< ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq, ::IndyFramework::Protobuf::HRI::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(197);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq, ::IndyFramework::Protobuf::HRI::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPhotoneoCalibPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ContyInit<WithCallbackMethod_RobotUpdate<WithCallbackMethod_ProgramUpdate<WithCallbackMethod_ControlUpdate<WithCallbackMethod_LinearUpdate<WithCallbackMethod_JogJoint<WithCallbackMethod_JogTask<WithCallbackMethod_JogAxis<WithCallbackMethod_HoldToMoveJ<WithCallbackMethod_HoldToMoveL<WithCallbackMethod_HoldToAxisJ<WithCallbackMethod_StopMotion<WithCallbackMethod_SetRefFrame<WithCallbackMethod_SetRefFramePlanar<WithCallbackMethod_SetToolFrame<WithCallbackMethod_SetSpeedRatio<WithCallbackMethod_SetSimulationMode<WithCallbackMethod_SetDirectTeachingMode<WithCallbackMethod_SetCustomControlMode<WithCallbackMethod_GetCustomControlMode<WithCallbackMethod_SetSensorlessComplianceMode<WithCallbackMethod_GetBrakeControlStyle<WithCallbackMethod_SetBrake<WithCallbackMethod_SetServo<WithCallbackMethod_SetAutoServoOff<WithCallbackMethod_GetAutoServoOff<WithCallbackMethod_ExecuteTool<WithCallbackMethod_InverseKinematics<WithCallbackMethod_CalculateRelativePose<WithCallbackMethod_CalculateCurrentPoseRel<WithCallbackMethod_SetManualRecoverMode<WithCallbackMethod_SetServoRecover<WithCallbackMethod_JogJointRecover<WithCallbackMethod_Recover<WithCallbackMethod_Reboot<WithCallbackMethod_PowerOff<WithCallbackMethod_UpdateIndySW<WithCallbackMethod_GetFile<WithCallbackMethod_SetFile<WithCallbackMethod_RenameFile<WithCallbackMethod_RemoveFile<WithCallbackMethod_GetIndexProgramList<WithCallbackMethod_GetProgramList<WithCallbackMethod_GetLogList<WithCallbackMethod_GetLogContent<WithCallbackMethod_GetLogContentList<WithCallbackMethod_GetLog<WithCallbackMethod_GetVariableList<WithCallbackMethod_GetMonitoringVariableList<WithCallbackMethod_SetMonitoringVariableList<WithCallbackMethod_GetPalletMakerList<WithCallbackMethod_SetPalletMakerList<WithCallbackMethod_CheckAproachRetractValid<WithCallbackMethod_GetPalletPointList<WithCallbackMethod_SetPalletPointList<WithCallbackMethod_GetConveyor<WithCallbackMethod_SetConveyorName<WithCallbackMethod_SetConveyorByName<WithCallbackMethod_SetConveyorEncoder<WithCallbackMethod_SetConveyorTrigger<WithCallbackMethod_SetConveyorOffset<WithCallbackMethod_SetConveyorStartingPose<WithCallbackMethod_SetConveyorTerminalPose<WithCallbackMethod_GetConveyorState<WithCallbackMethod_HoldToMoveConveyor<WithCallbackMethod_GetConveyorList<WithCallbackMethod_SetConveyorList<WithCallbackMethod_SetInching<WithCallbackMethod_StopInching<WithCallbackMethod_SetArc<WithCallbackMethod_SetTouch<WithCallbackMethod_SetGas<WithCallbackMethod_IsTouched<WithCallbackMethod_GetVisionServerList<WithCallbackMethod_SetVisionServerList<WithCallbackMethod_GetVisionObjectList<WithCallbackMethod_GetVisionDetection<WithCallbackMethod_GetVisionRetrieval<WithCallbackMethod_GetGcodeMotionList<WithCallbackMethod_GetModbusServerList<WithCallbackMethod_SetModbusServerList<WithCallbackMethod_CheckModbusConnection<WithCallbackMethod_GetToolFrameList<WithCallbackMethod_SetToolFrameList<WithCallbackMethod_GetRefFrameList<WithCallbackMethod_SetRefFrameList<WithCallbackMethod_GetCustomPosList<WithCallbackMethod_SetCustomPosList<WithCallbackMethod_SetJointControlGain<WithCallbackMethod_GetJointControlGain<WithCallbackMethod_SetTaskControlGain<WithCallbackMethod_GetTaskControlGain<WithCallbackMethod_SetImpedanceControlGain<WithCallbackMethod_GetImpedanceControlGain<WithCallbackMethod_SetForceControlGain<WithCallbackMethod_GetForceControlGain<WithCallbackMethod_SetExtAxisControlGain<WithCallbackMethod_GetExtAxisControlGain<WithCallbackMethod_SetSensorlessComplianceControlJointGain<WithCallbackMethod_GetSensorlessComplianceControlJointGain<WithCallbackMethod_SetSensorlessComplianceControlTaskGain<WithCallbackMethod_GetSensorlessComplianceControlTaskGain<WithCallbackMethod_SetFricComp<WithCallbackMethod_GetFricComp<WithCallbackMethod_SetHomePos<WithCallbackMethod_GetHomePos<WithCallbackMethod_SetMountPos<WithCallbackMethod_GetMountPos<WithCallbackMethod_GetPackagingPos<WithCallbackMethod_SetToolProperty<WithCallbackMethod_GetToolProperty<WithCallbackMethod_GetOnStartProgramConfig<WithCallbackMethod_SetOnStartProgramConfig<WithCallbackMethod_GetSafetyLimitConfig<WithCallbackMethod_SetSafetyLimitConfig<WithCallbackMethod_GetSafetyStopConfig<WithCallbackMethod_SetSafetyStopConfig<WithCallbackMethod_GetSafetyConfigHash<WithCallbackMethod_GetKinematicsParams<WithCallbackMethod_KeyInit<WithCallbackMethod_KeyData<WithCallbackMethod_ProgramUpdateKey<WithCallbackMethod_SetDirectTeachingModeKey<WithCallbackMethod_GetAutoModeConfig<WithCallbackMethod_SetAutoMode<WithCallbackMethod_CheckAutoMode<WithCallbackMethod_CheckReducedMode<WithCallbackMethod_GetReducedRatio<WithCallbackMethod_GetReducedSpeed<WithCallbackMethod_SetReducedSpeed<WithCallbackMethod_GetStopState<WithCallbackMethod_GetSafetyFunctionState<WithCallbackMethod_RequestSafetyFunction<WithCallbackMethod_PlayProgram<WithCallbackMethod_PlayIndexProgram<WithCallbackMethod_PlayProgramLine<WithCallbackMethod_ResumeProgram<WithCallbackMethod_StopProgram<WithCallbackMethod_PauseProgram<WithCallbackMethod_SetDO<WithCallbackMethod_SetAO<WithCallbackMethod_SetEndDO<WithCallbackMethod_SetEndAO<WithCallbackMethod_SetToolList<WithCallbackMethod_GetToolList<WithCallbackMethod_SetDIConfigList<WithCallbackMethod_GetDIConfigList<WithCallbackMethod_SetDOConfigList<WithCallbackMethod_GetDOConfigList<WithCallbackMethod_SetCollSensLevel<WithCallbackMethod_GetCollSensLevel<WithCallbackMethod_SetCollPolicy<WithCallbackMethod_GetCollPolicy<WithCallbackMethod_SetCollSensParam<WithCallbackMethod_GetCollSensParam<WithCallbackMethod_InitCollSensParam<WithCallbackMethod_PlayTuningProgram<WithCallbackMethod_GetTeleOpDevice<WithCallbackMethod_GetTeleOpState<WithCallbackMethod_ConnectTeleOpDevice<WithCallbackMethod_DisConnectTeleOpDevice<WithCallbackMethod_ReadTeleOpInput<WithCallbackMethod_StartTeleCalib<WithCallbackMethod_StartTeleRecord<WithCallbackMethod_StartTelePlay<WithCallbackMethod_StartTeleJogL<WithCallbackMethod_StartTeleJogJ<WithCallbackMethod_StopTeleOp<WithCallbackMethod_SetPlayRate<WithCallbackMethod_GetPlayRate<WithCallbackMethod_GetTeleFileList<WithCallbackMethod_SaveTeleMotion<WithCallbackMethod_LoadTeleMotion<WithCallbackMethod_DeleteTeleMotion<WithCallbackMethod_MoveTeleJ<WithCallbackMethod_MoveTeleL<WithCallbackMethod_SetTeleOpParams<WithCallbackMethod_GetTeleOpParams<WithCallbackMethod_SetFTSensorConfig<WithCallbackMethod_GetFTSensorConfig<WithCallbackMethod_GetFTSensorData<WithCallbackMethod_GetLoadFactors<WithCallbackMethod_SetSanderCommand<WithCallbackMethod_GetSanderCommand<WithCallbackMethod_SetSandingStopCondition<WithCallbackMethod_GetSandingStopCondition<WithCallbackMethod_GetGripperData<WithCallbackMethod_SetGripperCommand<WithCallbackMethod_SetSFDActivate<WithCallbackMethod_IsSFDActivate<WithCallbackMethod_SFDLogin<WithCallbackMethod_IsSFDLogin<WithCallbackMethod_SetSFDTarget<WithCallbackMethod_SetSFDOption<WithCallbackMethod_GetSFDProjList<WithCallbackMethod_GetSFDCRI<WithCallbackMethod_GetTactTime<WithCallbackMethod_AddPhotoneoCalibPoint<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ContyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ContyInit() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ContyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ContyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::ContyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RobotUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RobotUpdate() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RobotUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RobotUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::RobotData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProgramUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProgramUpdate() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ProgramUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControlUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControlUpdate() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ControlUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinearUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinearUpdate() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_LinearUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinearUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::LinearData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JogJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JogJoint() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_JogJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJointReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogJointRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JogTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JogTask() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_JogTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogTask(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogTaskReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JogAxis : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JogAxis() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_JogAxis() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogAxis(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogAxisReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogAxisRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HoldToMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HoldToMoveJ() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_HoldToMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HoldToMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HoldToMoveL() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_HoldToMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HoldToAxisJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HoldToAxisJ() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_HoldToAxisJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToAxisJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AxisJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopMotion() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopMotionReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopMotionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDirectTeachingMode() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_SetDirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IntMode* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSensorlessComplianceMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSensorlessComplianceMode() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_SetSensorlessComplianceMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetBrake() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_SetBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetBrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServo() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetServoReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetManualRecoverMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetManualRecoverMode() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_SetManualRecoverMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecoverMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetServoRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetServoRecover() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_SetServoRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Servo* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JogJointRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JogJointRecover() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_JogJointRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJointRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJTar* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Recover() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RecoverReq* /*request*/, ::IndyFramework::Protobuf::HRI::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Reboot() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RebootReq* /*request*/, ::IndyFramework::Protobuf::HRI::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PowerOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PowerOff() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_PowerOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PowerOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PowerOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::PowerOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateIndySW : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateIndySW() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_UpdateIndySW() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateIndySW(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFile() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFileReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetFile() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_SetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::SetFileReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::SetFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RenameFile() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RenameFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveFile() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RemoveFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIndexProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIndexProgramList() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_GetIndexProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIndexProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProgramList() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_GetProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLogList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLogList() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetLogList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetLogListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLogContent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLogContent() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_GetLogContent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContent(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLogContentList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLogContentList() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_GetLogContentList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContentList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLog() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVariableList() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMonitoringVariableList() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_GetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetMonitoringVariableList() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_SetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPalletMakerList() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_GetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPalletMakerList() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_SetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPalletPointList() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_SetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConveyor() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Encoder* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Trigger* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Float* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HoldToMoveConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HoldToMoveConveyor() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_HoldToMoveConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConveyorList() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_GetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetConveyorList() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_SetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetInching() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_SetInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopInching() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_StopInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetArc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetArc() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_SetArc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetArc(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetArcReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetArcRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTouch() {
      ::grpc::Service::MarkMethodGeneric(70);
    }
    ~WithGenericMethod_SetTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTouch(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTouchReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTouchRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetGas : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetGas() {
      ::grpc::Service::MarkMethodGeneric(71);
    }
    ~WithGenericMethod_SetGas() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGas(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetGasReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetGasRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsTouched : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsTouched() {
      ::grpc::Service::MarkMethodGeneric(72);
    }
    ~WithGenericMethod_IsTouched() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTouched(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* /*request*/, ::IndyFramework::Protobuf::HRI::IsTouchedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVisionServerList() {
      ::grpc::Service::MarkMethodGeneric(73);
    }
    ~WithGenericMethod_GetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVisionServerList() {
      ::grpc::Service::MarkMethodGeneric(74);
    }
    ~WithGenericMethod_SetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVisionObjectList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVisionObjectList() {
      ::grpc::Service::MarkMethodGeneric(75);
    }
    ~WithGenericMethod_GetVisionObjectList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionObjectList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVisionDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVisionDetection() {
      ::grpc::Service::MarkMethodGeneric(76);
    }
    ~WithGenericMethod_GetVisionDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionDetection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVisionRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVisionRetrieval() {
      ::grpc::Service::MarkMethodGeneric(77);
    }
    ~WithGenericMethod_GetVisionRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionRetrieval(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGcodeMotionList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGcodeMotionList() {
      ::grpc::Service::MarkMethodGeneric(78);
    }
    ~WithGenericMethod_GetGcodeMotionList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGcodeMotionList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModbusServerList() {
      ::grpc::Service::MarkMethodGeneric(79);
    }
    ~WithGenericMethod_GetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetModbusServerList() {
      ::grpc::Service::MarkMethodGeneric(80);
    }
    ~WithGenericMethod_SetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckModbusConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckModbusConnection() {
      ::grpc::Service::MarkMethodGeneric(81);
    }
    ~WithGenericMethod_CheckModbusConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckModbusConnection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetToolFrameList() {
      ::grpc::Service::MarkMethodGeneric(82);
    }
    ~WithGenericMethod_GetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetToolFrameList() {
      ::grpc::Service::MarkMethodGeneric(83);
    }
    ~WithGenericMethod_SetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRefFrameList() {
      ::grpc::Service::MarkMethodGeneric(84);
    }
    ~WithGenericMethod_GetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRefFrameList() {
      ::grpc::Service::MarkMethodGeneric(85);
    }
    ~WithGenericMethod_SetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCustomPosList() {
      ::grpc::Service::MarkMethodGeneric(86);
    }
    ~WithGenericMethod_GetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCustomPosList() {
      ::grpc::Service::MarkMethodGeneric(87);
    }
    ~WithGenericMethod_SetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodGeneric(88);
    }
    ~WithGenericMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodGeneric(89);
    }
    ~WithGenericMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodGeneric(90);
    }
    ~WithGenericMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodGeneric(91);
    }
    ~WithGenericMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodGeneric(92);
    }
    ~WithGenericMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodGeneric(93);
    }
    ~WithGenericMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetForceControlGain() {
      ::grpc::Service::MarkMethodGeneric(94);
    }
    ~WithGenericMethod_SetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetForceControlGain() {
      ::grpc::Service::MarkMethodGeneric(95);
    }
    ~WithGenericMethod_GetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetExtAxisControlGain() {
      ::grpc::Service::MarkMethodGeneric(96);
    }
    ~WithGenericMethod_SetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetExtAxisControlGain() {
      ::grpc::Service::MarkMethodGeneric(97);
    }
    ~WithGenericMethod_GetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodGeneric(98);
    }
    ~WithGenericMethod_SetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodGeneric(99);
    }
    ~WithGenericMethod_GetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodGeneric(100);
    }
    ~WithGenericMethod_SetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodGeneric(101);
    }
    ~WithGenericMethod_GetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetFricComp() {
      ::grpc::Service::MarkMethodGeneric(102);
    }
    ~WithGenericMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFricComp() {
      ::grpc::Service::MarkMethodGeneric(103);
    }
    ~WithGenericMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetHomePos() {
      ::grpc::Service::MarkMethodGeneric(104);
    }
    ~WithGenericMethod_SetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetHomePos() {
      ::grpc::Service::MarkMethodGeneric(105);
    }
    ~WithGenericMethod_GetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetMountPos() {
      ::grpc::Service::MarkMethodGeneric(106);
    }
    ~WithGenericMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMountPos() {
      ::grpc::Service::MarkMethodGeneric(107);
    }
    ~WithGenericMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPackagingPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPackagingPos() {
      ::grpc::Service::MarkMethodGeneric(108);
    }
    ~WithGenericMethod_GetPackagingPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPackagingPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodGeneric(109);
    }
    ~WithGenericMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodGeneric(110);
    }
    ~WithGenericMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodGeneric(111);
    }
    ~WithGenericMethod_GetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodGeneric(112);
    }
    ~WithGenericMethod_SetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodGeneric(113);
    }
    ~WithGenericMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodGeneric(114);
    }
    ~WithGenericMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodGeneric(115);
    }
    ~WithGenericMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodGeneric(116);
    }
    ~WithGenericMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyConfigHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyConfigHash() {
      ::grpc::Service::MarkMethodGeneric(117);
    }
    ~WithGenericMethod_GetSafetyConfigHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyConfigHash(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetKinematicsParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetKinematicsParams() {
      ::grpc::Service::MarkMethodGeneric(118);
    }
    ~WithGenericMethod_GetKinematicsParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKinematicsParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::KinematicsParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KeyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KeyInit() {
      ::grpc::Service::MarkMethodGeneric(119);
    }
    ~WithGenericMethod_KeyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KeyData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KeyData() {
      ::grpc::Service::MarkMethodGeneric(120);
    }
    ~WithGenericMethod_KeyData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyDataReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProgramUpdateKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProgramUpdateKey() {
      ::grpc::Service::MarkMethodGeneric(121);
    }
    ~WithGenericMethod_ProgramUpdateKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdateKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDirectTeachingModeKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDirectTeachingModeKey() {
      ::grpc::Service::MarkMethodGeneric(122);
    }
    ~WithGenericMethod_SetDirectTeachingModeKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingModeKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAutoModeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAutoModeConfig() {
      ::grpc::Service::MarkMethodGeneric(123);
    }
    ~WithGenericMethod_GetAutoModeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoModeConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodGeneric(124);
    }
    ~WithGenericMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodGeneric(125);
    }
    ~WithGenericMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodGeneric(126);
    }
    ~WithGenericMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetReducedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetReducedRatio() {
      ::grpc::Service::MarkMethodGeneric(127);
    }
    ~WithGenericMethod_GetReducedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetReducedSpeed() {
      ::grpc::Service::MarkMethodGeneric(128);
    }
    ~WithGenericMethod_GetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetReducedSpeed() {
      ::grpc::Service::MarkMethodGeneric(129);
    }
    ~WithGenericMethod_SetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStopState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStopState() {
      ::grpc::Service::MarkMethodGeneric(130);
    }
    ~WithGenericMethod_GetStopState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStopState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::StopState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodGeneric(131);
    }
    ~WithGenericMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodGeneric(132);
    }
    ~WithGenericMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayProgram() {
      ::grpc::Service::MarkMethodGeneric(133);
    }
    ~WithGenericMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PlayIndexProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayIndexProgram() {
      ::grpc::Service::MarkMethodGeneric(134);
    }
    ~WithGenericMethod_PlayIndexProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayIndexProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PlayProgramLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayProgramLine() {
      ::grpc::Service::MarkMethodGeneric(135);
    }
    ~WithGenericMethod_PlayProgramLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgramLine(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodGeneric(136);
    }
    ~WithGenericMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopProgram() {
      ::grpc::Service::MarkMethodGeneric(137);
    }
    ~WithGenericMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseProgram() {
      ::grpc::Service::MarkMethodGeneric(138);
    }
    ~WithGenericMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PauseProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDO() {
      ::grpc::Service::MarkMethodGeneric(139);
    }
    ~WithGenericMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAO() {
      ::grpc::Service::MarkMethodGeneric(140);
    }
    ~WithGenericMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndDO() {
      ::grpc::Service::MarkMethodGeneric(141);
    }
    ~WithGenericMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEndAO() {
      ::grpc::Service::MarkMethodGeneric(142);
    }
    ~WithGenericMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetToolList() {
      ::grpc::Service::MarkMethodGeneric(143);
    }
    ~WithGenericMethod_SetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ToolList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetToolList() {
      ::grpc::Service::MarkMethodGeneric(144);
    }
    ~WithGenericMethod_GetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ToolList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDIConfigList() {
      ::grpc::Service::MarkMethodGeneric(145);
    }
    ~WithGenericMethod_SetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DIConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDIConfigList() {
      ::grpc::Service::MarkMethodGeneric(146);
    }
    ~WithGenericMethod_GetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DIConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetDOConfigList() {
      ::grpc::Service::MarkMethodGeneric(147);
    }
    ~WithGenericMethod_SetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDOConfigList() {
      ::grpc::Service::MarkMethodGeneric(148);
    }
    ~WithGenericMethod_GetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DOConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodGeneric(149);
    }
    ~WithGenericMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodGeneric(150);
    }
    ~WithGenericMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodGeneric(151);
    }
    ~WithGenericMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodGeneric(152);
    }
    ~WithGenericMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodGeneric(153);
    }
    ~WithGenericMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodGeneric(154);
    }
    ~WithGenericMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InitCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InitCollSensParam() {
      ::grpc::Service::MarkMethodGeneric(155);
    }
    ~WithGenericMethod_InitCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InitCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodGeneric(156);
    }
    ~WithGenericMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TuningProgram* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodGeneric(157);
    }
    ~WithGenericMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodGeneric(158);
    }
    ~WithGenericMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodGeneric(159);
    }
    ~WithGenericMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodGeneric(160);
    }
    ~WithGenericMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodGeneric(161);
    }
    ~WithGenericMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTeleCalib : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTeleCalib() {
      ::grpc::Service::MarkMethodGeneric(162);
    }
    ~WithGenericMethod_StartTeleCalib() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleCalib(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTeleRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTeleRecord() {
      ::grpc::Service::MarkMethodGeneric(163);
    }
    ~WithGenericMethod_StartTeleRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleRecord(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTelePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTelePlay() {
      ::grpc::Service::MarkMethodGeneric(164);
    }
    ~WithGenericMethod_StartTelePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTelePlay(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTeleJogL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTeleJogL() {
      ::grpc::Service::MarkMethodGeneric(165);
    }
    ~WithGenericMethod_StartTeleJogL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartTeleJogJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartTeleJogJ() {
      ::grpc::Service::MarkMethodGeneric(166);
    }
    ~WithGenericMethod_StartTeleJogJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodGeneric(167);
    }
    ~WithGenericMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodGeneric(168);
    }
    ~WithGenericMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TelePlayRate* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodGeneric(169);
    }
    ~WithGenericMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodGeneric(170);
    }
    ~WithGenericMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodGeneric(171);
    }
    ~WithGenericMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodGeneric(172);
    }
    ~WithGenericMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodGeneric(173);
    }
    ~WithGenericMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodGeneric(174);
    }
    ~WithGenericMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodGeneric(175);
    }
    ~WithGenericMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTeleOpParams() {
      ::grpc::Service::MarkMethodGeneric(176);
    }
    ~WithGenericMethod_SetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpParams* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTeleOpParams() {
      ::grpc::Service::MarkMethodGeneric(177);
    }
    ~WithGenericMethod_GetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetFTSensorConfig() {
      ::grpc::Service::MarkMethodGeneric(178);
    }
    ~WithGenericMethod_SetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFTSensorConfig() {
      ::grpc::Service::MarkMethodGeneric(179);
    }
    ~WithGenericMethod_GetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodGeneric(180);
    }
    ~WithGenericMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodGeneric(181);
    }
    ~WithGenericMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodGeneric(182);
    }
    ~WithGenericMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SanderCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodGeneric(183);
    }
    ~WithGenericMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSandingStopCondition() {
      ::grpc::Service::MarkMethodGeneric(184);
    }
    ~WithGenericMethod_SetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSandingStopCondition() {
      ::grpc::Service::MarkMethodGeneric(185);
    }
    ~WithGenericMethod_GetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGripperData() {
      ::grpc::Service::MarkMethodGeneric(186);
    }
    ~WithGenericMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodGeneric(187);
    }
    ~WithGenericMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GripperCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSFDActivate() {
      ::grpc::Service::MarkMethodGeneric(188);
    }
    ~WithGenericMethod_SetSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsSFDActivate() {
      ::grpc::Service::MarkMethodGeneric(189);
    }
    ~WithGenericMethod_IsSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SFDLogin() {
      ::grpc::Service::MarkMethodGeneric(190);
    }
    ~WithGenericMethod_SFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDAccount* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsSFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsSFDLogin() {
      ::grpc::Service::MarkMethodGeneric(191);
    }
    ~WithGenericMethod_IsSFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSFDTarget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSFDTarget() {
      ::grpc::Service::MarkMethodGeneric(192);
    }
    ~WithGenericMethod_SetSFDTarget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDTarget(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSFDOption : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSFDOption() {
      ::grpc::Service::MarkMethodGeneric(193);
    }
    ~WithGenericMethod_SetSFDOption() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDOption(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSFDProjList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSFDProjList() {
      ::grpc::Service::MarkMethodGeneric(194);
    }
    ~WithGenericMethod_GetSFDProjList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDProjList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDProjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSFDCRI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSFDCRI() {
      ::grpc::Service::MarkMethodGeneric(195);
    }
    ~WithGenericMethod_GetSFDCRI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDCRI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDCriData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTactTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTactTime() {
      ::grpc::Service::MarkMethodGeneric(196);
    }
    ~WithGenericMethod_GetTactTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTactTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TactTime* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodGeneric(197);
    }
    ~WithGenericMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ContyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ContyInit() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ContyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ContyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::ContyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContyInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RobotUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RobotUpdate() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_RobotUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RobotUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::RobotData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRobotUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProgramUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProgramUpdate() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ProgramUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProgramUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControlUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControlUpdate() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ControlUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinearUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinearUpdate() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_LinearUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinearUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::LinearData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinearUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JogJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JogJoint() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_JogJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJointReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogJointRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogJoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JogTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JogTask() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_JogTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogTask(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogTaskReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JogAxis : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JogAxis() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_JogAxis() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogAxis(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogAxisReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogAxisRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogAxis(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HoldToMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HoldToMoveJ() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_HoldToMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToMoveJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HoldToMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HoldToMoveL() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_HoldToMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToMoveL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HoldToAxisJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HoldToAxisJ() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_HoldToAxisJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToAxisJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AxisJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToAxisJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopMotion() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopMotionReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopMotionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFrame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFramePlanar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolFrame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSpeedRatio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSimulationMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDirectTeachingMode() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_SetDirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDirectTeachingMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IntMode* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCustomControlMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCustomControlMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSensorlessComplianceMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSensorlessComplianceMode() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_SetSensorlessComplianceMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorlessComplianceMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBrakeControlStyle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetBrake() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_SetBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetBrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetBrake(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServo() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetServoReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoServoOff(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoServoOff(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteTool(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateRelativePose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateCurrentPoseRel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetManualRecoverMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetManualRecoverMode() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_SetManualRecoverMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecoverMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetManualRecoverMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetServoRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetServoRecover() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_SetServoRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Servo* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetServoRecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JogJointRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JogJointRecover() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_JogJointRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJointRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJTar* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJogJointRecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Recover() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RecoverReq* /*request*/, ::IndyFramework::Protobuf::HRI::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Reboot() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RebootReq* /*request*/, ::IndyFramework::Protobuf::HRI::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReboot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PowerOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PowerOff() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_PowerOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PowerOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PowerOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::PowerOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPowerOff(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateIndySW : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateIndySW() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_UpdateIndySW() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateIndySW(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateIndySW(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(36, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFile() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFileReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(37, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetFile() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_SetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::SetFileReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::SetFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(38, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RenameFile() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RenameFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRenameFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RemoveFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIndexProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIndexProgramList() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_GetIndexProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIndexProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIndexProgramList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProgramList() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_GetProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProgramList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLogList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLogList() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetLogList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetLogListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLogContent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLogContent() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_GetLogContent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContent(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogContent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(44, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLogContentList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLogContentList() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_GetLogContentList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContentList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogContentList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLog() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(46, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVariableList() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVariableList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMonitoringVariableList() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_GetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMonitoringVariableList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetMonitoringVariableList() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_SetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMonitoringVariableList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPalletMakerList() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_GetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletMakerList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPalletMakerList() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_SetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPalletMakerList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAproachRetractValid(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPalletPointList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPalletPointList() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_SetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPalletPointList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConveyor() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorByName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Encoder* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorEncoder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Trigger* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTrigger(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Float* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorStartingPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorTerminalPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyorState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HoldToMoveConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HoldToMoveConveyor() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_HoldToMoveConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHoldToMoveConveyor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConveyorList() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_GetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConveyorList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetConveyorList() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_SetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetConveyorList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetInching() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_SetInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetInching(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopInching() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_StopInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopInching(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetArc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetArc() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_SetArc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetArc(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetArcReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetArcRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetArc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTouch() {
      ::grpc::Service::MarkMethodRaw(70);
    }
    ~WithRawMethod_SetTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTouch(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTouchReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTouchRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTouch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetGas : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetGas() {
      ::grpc::Service::MarkMethodRaw(71);
    }
    ~WithRawMethod_SetGas() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGas(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetGasReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetGasRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetGas(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsTouched : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsTouched() {
      ::grpc::Service::MarkMethodRaw(72);
    }
    ~WithRawMethod_IsTouched() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTouched(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* /*request*/, ::IndyFramework::Protobuf::HRI::IsTouchedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsTouched(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVisionServerList() {
      ::grpc::Service::MarkMethodRaw(73);
    }
    ~WithRawMethod_GetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionServerList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVisionServerList() {
      ::grpc::Service::MarkMethodRaw(74);
    }
    ~WithRawMethod_SetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVisionServerList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(74, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVisionObjectList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVisionObjectList() {
      ::grpc::Service::MarkMethodRaw(75);
    }
    ~WithRawMethod_GetVisionObjectList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionObjectList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionObjectList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(75, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVisionDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVisionDetection() {
      ::grpc::Service::MarkMethodRaw(76);
    }
    ~WithRawMethod_GetVisionDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionDetection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionDetection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(76, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVisionRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVisionRetrieval() {
      ::grpc::Service::MarkMethodRaw(77);
    }
    ~WithRawMethod_GetVisionRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionRetrieval(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisionRetrieval(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(77, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGcodeMotionList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGcodeMotionList() {
      ::grpc::Service::MarkMethodRaw(78);
    }
    ~WithRawMethod_GetGcodeMotionList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGcodeMotionList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGcodeMotionList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(78, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModbusServerList() {
      ::grpc::Service::MarkMethodRaw(79);
    }
    ~WithRawMethod_GetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModbusServerList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(79, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetModbusServerList() {
      ::grpc::Service::MarkMethodRaw(80);
    }
    ~WithRawMethod_SetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetModbusServerList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(80, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckModbusConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckModbusConnection() {
      ::grpc::Service::MarkMethodRaw(81);
    }
    ~WithRawMethod_CheckModbusConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckModbusConnection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckModbusConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(81, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetToolFrameList() {
      ::grpc::Service::MarkMethodRaw(82);
    }
    ~WithRawMethod_GetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolFrameList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(82, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetToolFrameList() {
      ::grpc::Service::MarkMethodRaw(83);
    }
    ~WithRawMethod_SetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolFrameList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(83, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRefFrameList() {
      ::grpc::Service::MarkMethodRaw(84);
    }
    ~WithRawMethod_GetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRefFrameList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(84, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRefFrameList() {
      ::grpc::Service::MarkMethodRaw(85);
    }
    ~WithRawMethod_SetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRefFrameList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(85, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCustomPosList() {
      ::grpc::Service::MarkMethodRaw(86);
    }
    ~WithRawMethod_GetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCustomPosList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(86, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCustomPosList() {
      ::grpc::Service::MarkMethodRaw(87);
    }
    ~WithRawMethod_SetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCustomPosList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(87, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodRaw(88);
    }
    ~WithRawMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(88, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodRaw(89);
    }
    ~WithRawMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(89, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodRaw(90);
    }
    ~WithRawMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTaskControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(90, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodRaw(91);
    }
    ~WithRawMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTaskControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(91, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodRaw(92);
    }
    ~WithRawMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(92, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodRaw(93);
    }
    ~WithRawMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(93, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetForceControlGain() {
      ::grpc::Service::MarkMethodRaw(94);
    }
    ~WithRawMethod_SetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetForceControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(94, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetForceControlGain() {
      ::grpc::Service::MarkMethodRaw(95);
    }
    ~WithRawMethod_GetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetForceControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(95, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetExtAxisControlGain() {
      ::grpc::Service::MarkMethodRaw(96);
    }
    ~WithRawMethod_SetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExtAxisControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(96, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetExtAxisControlGain() {
      ::grpc::Service::MarkMethodRaw(97);
    }
    ~WithRawMethod_GetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExtAxisControlGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(97, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodRaw(98);
    }
    ~WithRawMethod_SetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(98, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodRaw(99);
    }
    ~WithRawMethod_GetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(99, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodRaw(100);
    }
    ~WithRawMethod_SetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(100, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodRaw(101);
    }
    ~WithRawMethod_GetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(101, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetFricComp() {
      ::grpc::Service::MarkMethodRaw(102);
    }
    ~WithRawMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFricComp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(102, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFricComp() {
      ::grpc::Service::MarkMethodRaw(103);
    }
    ~WithRawMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFricComp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(103, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetHomePos() {
      ::grpc::Service::MarkMethodRaw(104);
    }
    ~WithRawMethod_SetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetHomePos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(104, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetHomePos() {
      ::grpc::Service::MarkMethodRaw(105);
    }
    ~WithRawMethod_GetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetHomePos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(105, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetMountPos() {
      ::grpc::Service::MarkMethodRaw(106);
    }
    ~WithRawMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMountPos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(106, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMountPos() {
      ::grpc::Service::MarkMethodRaw(107);
    }
    ~WithRawMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMountPos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(107, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPackagingPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPackagingPos() {
      ::grpc::Service::MarkMethodRaw(108);
    }
    ~WithRawMethod_GetPackagingPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPackagingPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPackagingPos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(108, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodRaw(109);
    }
    ~WithRawMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolProperty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(109, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodRaw(110);
    }
    ~WithRawMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolProperty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(110, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodRaw(111);
    }
    ~WithRawMethod_GetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOnStartProgramConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(111, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodRaw(112);
    }
    ~WithRawMethod_SetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetOnStartProgramConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(112, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodRaw(113);
    }
    ~WithRawMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(113, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodRaw(114);
    }
    ~WithRawMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(114, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodRaw(115);
    }
    ~WithRawMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(115, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodRaw(116);
    }
    ~WithRawMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(116, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyConfigHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyConfigHash() {
      ::grpc::Service::MarkMethodRaw(117);
    }
    ~WithRawMethod_GetSafetyConfigHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyConfigHash(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyConfigHash(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(117, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetKinematicsParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetKinematicsParams() {
      ::grpc::Service::MarkMethodRaw(118);
    }
    ~WithRawMethod_GetKinematicsParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKinematicsParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::KinematicsParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetKinematicsParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(118, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KeyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KeyInit() {
      ::grpc::Service::MarkMethodRaw(119);
    }
    ~WithRawMethod_KeyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(119, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KeyData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KeyData() {
      ::grpc::Service::MarkMethodRaw(120);
    }
    ~WithRawMethod_KeyData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyDataReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKeyData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(120, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProgramUpdateKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProgramUpdateKey() {
      ::grpc::Service::MarkMethodRaw(121);
    }
    ~WithRawMethod_ProgramUpdateKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdateKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProgramUpdateKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(121, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDirectTeachingModeKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDirectTeachingModeKey() {
      ::grpc::Service::MarkMethodRaw(122);
    }
    ~WithRawMethod_SetDirectTeachingModeKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingModeKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDirectTeachingModeKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(122, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAutoModeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAutoModeConfig() {
      ::grpc::Service::MarkMethodRaw(123);
    }
    ~WithRawMethod_GetAutoModeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoModeConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAutoModeConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(123, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodRaw(124);
    }
    ~WithRawMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAutoMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(124, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodRaw(125);
    }
    ~WithRawMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckAutoMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(125, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodRaw(126);
    }
    ~WithRawMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckReducedMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(126, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetReducedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetReducedRatio() {
      ::grpc::Service::MarkMethodRaw(127);
    }
    ~WithRawMethod_GetReducedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetReducedRatio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(127, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetReducedSpeed() {
      ::grpc::Service::MarkMethodRaw(128);
    }
    ~WithRawMethod_GetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetReducedSpeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(128, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetReducedSpeed() {
      ::grpc::Service::MarkMethodRaw(129);
    }
    ~WithRawMethod_SetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetReducedSpeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(129, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStopState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStopState() {
      ::grpc::Service::MarkMethodRaw(130);
    }
    ~WithRawMethod_GetStopState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStopState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::StopState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStopState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(130, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodRaw(131);
    }
    ~WithRawMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSafetyFunctionState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(131, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodRaw(132);
    }
    ~WithRawMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestSafetyFunction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(132, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayProgram() {
      ::grpc::Service::MarkMethodRaw(133);
    }
    ~WithRawMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(133, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayIndexProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayIndexProgram() {
      ::grpc::Service::MarkMethodRaw(134);
    }
    ~WithRawMethod_PlayIndexProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayIndexProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayIndexProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(134, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayProgramLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayProgramLine() {
      ::grpc::Service::MarkMethodRaw(135);
    }
    ~WithRawMethod_PlayProgramLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgramLine(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayProgramLine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(135, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodRaw(136);
    }
    ~WithRawMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(136, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopProgram() {
      ::grpc::Service::MarkMethodRaw(137);
    }
    ~WithRawMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(137, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseProgram() {
      ::grpc::Service::MarkMethodRaw(138);
    }
    ~WithRawMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PauseProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(138, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDO() {
      ::grpc::Service::MarkMethodRaw(139);
    }
    ~WithRawMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(139, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAO() {
      ::grpc::Service::MarkMethodRaw(140);
    }
    ~WithRawMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(140, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndDO() {
      ::grpc::Service::MarkMethodRaw(141);
    }
    ~WithRawMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndDO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(141, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEndAO() {
      ::grpc::Service::MarkMethodRaw(142);
    }
    ~WithRawMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEndAO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(142, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetToolList() {
      ::grpc::Service::MarkMethodRaw(143);
    }
    ~WithRawMethod_SetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ToolList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetToolList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(143, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetToolList() {
      ::grpc::Service::MarkMethodRaw(144);
    }
    ~WithRawMethod_GetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ToolList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetToolList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(144, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDIConfigList() {
      ::grpc::Service::MarkMethodRaw(145);
    }
    ~WithRawMethod_SetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DIConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDIConfigList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(145, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDIConfigList() {
      ::grpc::Service::MarkMethodRaw(146);
    }
    ~WithRawMethod_GetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DIConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDIConfigList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(146, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetDOConfigList() {
      ::grpc::Service::MarkMethodRaw(147);
    }
    ~WithRawMethod_SetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDOConfigList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(147, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDOConfigList() {
      ::grpc::Service::MarkMethodRaw(148);
    }
    ~WithRawMethod_GetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DOConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDOConfigList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(148, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodRaw(149);
    }
    ~WithRawMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(149, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodRaw(150);
    }
    ~WithRawMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(150, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodRaw(151);
    }
    ~WithRawMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollPolicy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(151, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodRaw(152);
    }
    ~WithRawMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollPolicy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(152, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodRaw(153);
    }
    ~WithRawMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCollSensParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(153, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodRaw(154);
    }
    ~WithRawMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollSensParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(154, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InitCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InitCollSensParam() {
      ::grpc::Service::MarkMethodRaw(155);
    }
    ~WithRawMethod_InitCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InitCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInitCollSensParam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(155, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodRaw(156);
    }
    ~WithRawMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TuningProgram* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayTuningProgram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(156, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodRaw(157);
    }
    ~WithRawMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(157, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodRaw(158);
    }
    ~WithRawMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(158, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRaw(159);
    }
    ~WithRawMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(159, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRaw(160);
    }
    ~WithRawMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(160, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodRaw(161);
    }
    ~WithRawMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadTeleOpInput(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(161, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTeleCalib : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTeleCalib() {
      ::grpc::Service::MarkMethodRaw(162);
    }
    ~WithRawMethod_StartTeleCalib() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleCalib(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleCalib(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(162, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTeleRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTeleRecord() {
      ::grpc::Service::MarkMethodRaw(163);
    }
    ~WithRawMethod_StartTeleRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleRecord(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleRecord(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(163, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTelePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTelePlay() {
      ::grpc::Service::MarkMethodRaw(164);
    }
    ~WithRawMethod_StartTelePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTelePlay(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTelePlay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(164, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTeleJogL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTeleJogL() {
      ::grpc::Service::MarkMethodRaw(165);
    }
    ~WithRawMethod_StartTeleJogL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleJogL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(165, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartTeleJogJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartTeleJogJ() {
      ::grpc::Service::MarkMethodRaw(166);
    }
    ~WithRawMethod_StartTeleJogJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartTeleJogJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(166, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodRaw(167);
    }
    ~WithRawMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopTeleOp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(167, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodRaw(168);
    }
    ~WithRawMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TelePlayRate* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPlayRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(168, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodRaw(169);
    }
    ~WithRawMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(169, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodRaw(170);
    }
    ~WithRawMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleFileList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(170, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodRaw(171);
    }
    ~WithRawMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveTeleMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(171, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodRaw(172);
    }
    ~WithRawMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadTeleMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(172, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodRaw(173);
    }
    ~WithRawMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTeleMotion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(173, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodRaw(174);
    }
    ~WithRawMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleJ(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(174, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodRaw(175);
    }
    ~WithRawMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTeleL(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(175, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTeleOpParams() {
      ::grpc::Service::MarkMethodRaw(176);
    }
    ~WithRawMethod_SetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpParams* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTeleOpParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(176, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTeleOpParams() {
      ::grpc::Service::MarkMethodRaw(177);
    }
    ~WithRawMethod_GetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTeleOpParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(177, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetFTSensorConfig() {
      ::grpc::Service::MarkMethodRaw(178);
    }
    ~WithRawMethod_SetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFTSensorConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(178, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFTSensorConfig() {
      ::grpc::Service::MarkMethodRaw(179);
    }
    ~WithRawMethod_GetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFTSensorConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(179, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodRaw(180);
    }
    ~WithRawMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFTSensorData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(180, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodRaw(181);
    }
    ~WithRawMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoadFactors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(181, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodRaw(182);
    }
    ~WithRawMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SanderCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSanderCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(182, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodRaw(183);
    }
    ~WithRawMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSanderCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(183, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSandingStopCondition() {
      ::grpc::Service::MarkMethodRaw(184);
    }
    ~WithRawMethod_SetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSandingStopCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(184, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSandingStopCondition() {
      ::grpc::Service::MarkMethodRaw(185);
    }
    ~WithRawMethod_GetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSandingStopCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(185, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGripperData() {
      ::grpc::Service::MarkMethodRaw(186);
    }
    ~WithRawMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGripperData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(186, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodRaw(187);
    }
    ~WithRawMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GripperCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetGripperCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(187, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSFDActivate() {
      ::grpc::Service::MarkMethodRaw(188);
    }
    ~WithRawMethod_SetSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSFDActivate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(188, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsSFDActivate() {
      ::grpc::Service::MarkMethodRaw(189);
    }
    ~WithRawMethod_IsSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsSFDActivate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(189, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SFDLogin() {
      ::grpc::Service::MarkMethodRaw(190);
    }
    ~WithRawMethod_SFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDAccount* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSFDLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(190, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsSFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsSFDLogin() {
      ::grpc::Service::MarkMethodRaw(191);
    }
    ~WithRawMethod_IsSFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsSFDLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(191, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSFDTarget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSFDTarget() {
      ::grpc::Service::MarkMethodRaw(192);
    }
    ~WithRawMethod_SetSFDTarget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDTarget(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSFDTarget(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(192, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSFDOption : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSFDOption() {
      ::grpc::Service::MarkMethodRaw(193);
    }
    ~WithRawMethod_SetSFDOption() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDOption(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSFDOption(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(193, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSFDProjList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSFDProjList() {
      ::grpc::Service::MarkMethodRaw(194);
    }
    ~WithRawMethod_GetSFDProjList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDProjList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDProjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSFDProjList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(194, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSFDCRI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSFDCRI() {
      ::grpc::Service::MarkMethodRaw(195);
    }
    ~WithRawMethod_GetSFDCRI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDCRI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDCriData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSFDCRI(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(195, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTactTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTactTime() {
      ::grpc::Service::MarkMethodRaw(196);
    }
    ~WithRawMethod_GetTactTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTactTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TactTime* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTactTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(196, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodRaw(197);
    }
    ~WithRawMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPhotoneoCalibPoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(197, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ContyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ContyInit() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ContyInit(context, request, response); }));
    }
    ~WithRawCallbackMethod_ContyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ContyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::ContyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ContyInit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RobotUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RobotUpdate() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RobotUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_RobotUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RobotUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::RobotData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RobotUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProgramUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ProgramUpdate() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProgramUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_ProgramUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProgramUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ControlUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ControlUpdate() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControlUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_ControlUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LinearUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LinearUpdate() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinearUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_LinearUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinearUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::LinearData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LinearUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_JogJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_JogJoint() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JogJoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_JogJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJointReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogJointRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogJoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_JogTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_JogTask() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JogTask(context, request, response); }));
    }
    ~WithRawCallbackMethod_JogTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogTask(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogTaskReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_JogAxis : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_JogAxis() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JogAxis(context, request, response); }));
    }
    ~WithRawCallbackMethod_JogAxis() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogAxis(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogAxisReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogAxisRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogAxis(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HoldToMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HoldToMoveJ() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HoldToMoveJ(context, request, response); }));
    }
    ~WithRawCallbackMethod_HoldToMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToMoveJ(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HoldToMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HoldToMoveL() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HoldToMoveL(context, request, response); }));
    }
    ~WithRawCallbackMethod_HoldToMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToMoveL(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HoldToAxisJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HoldToAxisJ() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HoldToAxisJ(context, request, response); }));
    }
    ~WithRawCallbackMethod_HoldToAxisJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToAxisJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AxisJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToAxisJ(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopMotion() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopMotionReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopMotionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRefFrame(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRefFrame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRefFramePlanar(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRefFramePlanar(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetToolFrame(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolFrame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSpeedRatio(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSpeedRatio(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSimulationMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSimulationMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDirectTeachingMode() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDirectTeachingMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDirectTeachingMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCustomControlMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IntMode* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCustomControlMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCustomControlMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSensorlessComplianceMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSensorlessComplianceMode() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSensorlessComplianceMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSensorlessComplianceMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSensorlessComplianceMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBrakeControlStyle(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBrakeControlStyle(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetBrake() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetBrake(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetBrake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetBrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetBrake(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServo() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServo(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetServoReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAutoServoOff(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAutoServoOff(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAutoServoOff(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAutoServoOff(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteTool(context, request, response); }));
    }
    ~WithRawCallbackMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ExecuteTool(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InverseKinematics(context, request, response); }));
    }
    ~WithRawCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InverseKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CalculateRelativePose(context, request, response); }));
    }
    ~WithRawCallbackMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateRelativePose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CalculateCurrentPoseRel(context, request, response); }));
    }
    ~WithRawCallbackMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateCurrentPoseRel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetManualRecoverMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetManualRecoverMode() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetManualRecoverMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetManualRecoverMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualRecoverMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetManualRecoverMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetServoRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetServoRecover() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetServoRecover(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetServoRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetServoRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Servo* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetServoRecover(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_JogJointRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_JogJointRecover() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JogJointRecover(context, request, response); }));
    }
    ~WithRawCallbackMethod_JogJointRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JogJointRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJTar* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JogJointRecover(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Recover() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Recover(context, request, response); }));
    }
    ~WithRawCallbackMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RecoverReq* /*request*/, ::IndyFramework::Protobuf::HRI::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Recover(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Reboot() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Reboot(context, request, response); }));
    }
    ~WithRawCallbackMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RebootReq* /*request*/, ::IndyFramework::Protobuf::HRI::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Reboot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PowerOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PowerOff() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PowerOff(context, request, response); }));
    }
    ~WithRawCallbackMethod_PowerOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PowerOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PowerOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::PowerOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PowerOff(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateIndySW : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateIndySW() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->UpdateIndySW(context, response); }));
    }
    ~WithRawCallbackMethod_UpdateIndySW() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateIndySW(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::UpdateIndySWReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::UpdateIndySWRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* UpdateIndySW(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFile() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetFile(context, request); }));
    }
    ~WithRawCallbackMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFileReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetFile() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->SetFile(context, response); }));
    }
    ~WithRawCallbackMethod_SetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::IndyFramework::Protobuf::HRI::SetFileReq>* /*reader*/, ::IndyFramework::Protobuf::HRI::SetFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* SetFile(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RenameFile() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RenameFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RenameFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RenameFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RemoveFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetIndexProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetIndexProgramList() {
      ::grpc::Service::MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetIndexProgramList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetIndexProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIndexProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIndexProgramList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetProgramList() {
      ::grpc::Service::MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProgramList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetProgramList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLogList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLogList() {
      ::grpc::Service::MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLogList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLogList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetLogListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLogList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLogContent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLogContent() {
      ::grpc::Service::MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetLogContent(context, request); }));
    }
    ~WithRawCallbackMethod_GetLogContent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContent(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetLogContent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLogContentList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLogContentList() {
      ::grpc::Service::MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetLogContentList(context, request); }));
    }
    ~WithRawCallbackMethod_GetLogContentList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogContentList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetLogContentList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLog() {
      ::grpc::Service::MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetLog(context, request); }));
    }
    ~WithRawCallbackMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVariableList() {
      ::grpc::Service::MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVariableList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVariableList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMonitoringVariableList() {
      ::grpc::Service::MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMonitoringVariableList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMonitoringVariableList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetMonitoringVariableList() {
      ::grpc::Service::MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetMonitoringVariableList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetMonitoringVariableList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPalletMakerList() {
      ::grpc::Service::MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPalletMakerList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPalletMakerList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPalletMakerList() {
      ::grpc::Service::MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPalletMakerList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPalletMakerList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckAproachRetractValid(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAproachRetractValid(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPalletPointList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPalletPointList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPalletPointList() {
      ::grpc::Service::MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPalletPointList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPalletPointList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConveyor() {
      ::grpc::Service::MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConveyor(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorName(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodRawCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorByName(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorByName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodRawCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorEncoder(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Encoder* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorEncoder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodRawCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorTrigger(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Trigger* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTrigger(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodRawCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorOffset(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Float* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodRawCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorStartingPose(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorStartingPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodRawCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorTerminalPose(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorTerminalPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodRawCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConveyorState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyorState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HoldToMoveConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HoldToMoveConveyor() {
      ::grpc::Service::MarkMethodRawCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HoldToMoveConveyor(context, request, response); }));
    }
    ~WithRawCallbackMethod_HoldToMoveConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HoldToMoveConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HoldToMoveConveyor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConveyorList() {
      ::grpc::Service::MarkMethodRawCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConveyorList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConveyorList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetConveyorList() {
      ::grpc::Service::MarkMethodRawCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetConveyorList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetConveyorList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetInching() {
      ::grpc::Service::MarkMethodRawCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetInching(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetInching(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopInching() {
      ::grpc::Service::MarkMethodRawCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopInching(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopInching(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetArc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetArc() {
      ::grpc::Service::MarkMethodRawCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetArc(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetArc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetArc(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetArcReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetArcRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetArc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetTouch() {
      ::grpc::Service::MarkMethodRawCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTouch(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTouch(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTouchReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTouchRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTouch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetGas : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetGas() {
      ::grpc::Service::MarkMethodRawCallback(71,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetGas(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetGas() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGas(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetGasReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetGasRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetGas(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsTouched : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsTouched() {
      ::grpc::Service::MarkMethodRawCallback(72,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsTouched(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsTouched() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTouched(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* /*request*/, ::IndyFramework::Protobuf::HRI::IsTouchedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsTouched(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVisionServerList() {
      ::grpc::Service::MarkMethodRawCallback(73,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVisionServerList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetVisionServerList() {
      ::grpc::Service::MarkMethodRawCallback(74,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVisionServerList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVisionServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVisionObjectList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVisionObjectList() {
      ::grpc::Service::MarkMethodRawCallback(75,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVisionObjectList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVisionObjectList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionObjectList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionObjectList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVisionDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVisionDetection() {
      ::grpc::Service::MarkMethodRawCallback(76,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVisionDetection(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVisionDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionDetection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVisionRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVisionRetrieval() {
      ::grpc::Service::MarkMethodRawCallback(77,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVisionRetrieval(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVisionRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisionRetrieval(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVisionRetrieval(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGcodeMotionList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGcodeMotionList() {
      ::grpc::Service::MarkMethodRawCallback(78,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGcodeMotionList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGcodeMotionList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGcodeMotionList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGcodeMotionList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetModbusServerList() {
      ::grpc::Service::MarkMethodRawCallback(79,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModbusServerList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModbusServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetModbusServerList() {
      ::grpc::Service::MarkMethodRawCallback(80,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetModbusServerList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetModbusServerList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckModbusConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckModbusConnection() {
      ::grpc::Service::MarkMethodRawCallback(81,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckModbusConnection(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckModbusConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckModbusConnection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckModbusConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetToolFrameList() {
      ::grpc::Service::MarkMethodRawCallback(82,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetToolFrameList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetToolFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetToolFrameList() {
      ::grpc::Service::MarkMethodRawCallback(83,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetToolFrameList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRefFrameList() {
      ::grpc::Service::MarkMethodRawCallback(84,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRefFrameList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRefFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRefFrameList() {
      ::grpc::Service::MarkMethodRawCallback(85,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRefFrameList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRefFrameList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCustomPosList() {
      ::grpc::Service::MarkMethodRawCallback(86,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCustomPosList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCustomPosList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCustomPosList() {
      ::grpc::Service::MarkMethodRawCallback(87,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCustomPosList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCustomPosList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodRawCallback(88,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetJointControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodRawCallback(89,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodRawCallback(90,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTaskControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTaskControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodRawCallback(91,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTaskControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTaskControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodRawCallback(92,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetImpedanceControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetImpedanceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodRawCallback(93,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetImpedanceControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetImpedanceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetForceControlGain() {
      ::grpc::Service::MarkMethodRawCallback(94,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetForceControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetForceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetForceControlGain() {
      ::grpc::Service::MarkMethodRawCallback(95,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetForceControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetForceControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetExtAxisControlGain() {
      ::grpc::Service::MarkMethodRawCallback(96,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetExtAxisControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetExtAxisControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetExtAxisControlGain() {
      ::grpc::Service::MarkMethodRawCallback(97,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetExtAxisControlGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetExtAxisControlGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodRawCallback(98,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSensorlessComplianceControlJointGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSensorlessComplianceControlJointGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodRawCallback(99,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSensorlessComplianceControlJointGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSensorlessComplianceControlJointGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodRawCallback(100,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSensorlessComplianceControlTaskGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSensorlessComplianceControlTaskGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodRawCallback(101,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSensorlessComplianceControlTaskGain(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSensorlessComplianceControlTaskGain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetFricComp() {
      ::grpc::Service::MarkMethodRawCallback(102,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetFricComp(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFricComp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFricComp() {
      ::grpc::Service::MarkMethodRawCallback(103,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFricComp(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFricComp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetHomePos() {
      ::grpc::Service::MarkMethodRawCallback(104,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetHomePos(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetHomePos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetHomePos() {
      ::grpc::Service::MarkMethodRawCallback(105,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetHomePos(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetHomePos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetMountPos() {
      ::grpc::Service::MarkMethodRawCallback(106,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetMountPos(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetMountPos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMountPos() {
      ::grpc::Service::MarkMethodRawCallback(107,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMountPos(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMountPos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPackagingPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPackagingPos() {
      ::grpc::Service::MarkMethodRawCallback(108,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPackagingPos(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPackagingPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPackagingPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPackagingPos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodRawCallback(109,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetToolProperty(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolProperty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodRawCallback(110,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetToolProperty(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetToolProperty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodRawCallback(111,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOnStartProgramConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOnStartProgramConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodRawCallback(112,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetOnStartProgramConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetOnStartProgramConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodRawCallback(113,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSafetyLimitConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyLimitConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodRawCallback(114,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSafetyLimitConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSafetyLimitConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodRawCallback(115,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSafetyStopConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyStopConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodRawCallback(116,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSafetyStopConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSafetyStopConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSafetyConfigHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSafetyConfigHash() {
      ::grpc::Service::MarkMethodRawCallback(117,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSafetyConfigHash(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSafetyConfigHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyConfigHash(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyConfigHash(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetKinematicsParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetKinematicsParams() {
      ::grpc::Service::MarkMethodRawCallback(118,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetKinematicsParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetKinematicsParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetKinematicsParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::KinematicsParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetKinematicsParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_KeyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_KeyInit() {
      ::grpc::Service::MarkMethodRawCallback(119,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KeyInit(context, request, response); }));
    }
    ~WithRawCallbackMethod_KeyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyInit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_KeyData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_KeyData() {
      ::grpc::Service::MarkMethodRawCallback(120,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KeyData(context, request, response); }));
    }
    ~WithRawCallbackMethod_KeyData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KeyData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyDataReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KeyData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProgramUpdateKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ProgramUpdateKey() {
      ::grpc::Service::MarkMethodRawCallback(121,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProgramUpdateKey(context, request, response); }));
    }
    ~WithRawCallbackMethod_ProgramUpdateKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProgramUpdateKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProgramUpdateKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDirectTeachingModeKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDirectTeachingModeKey() {
      ::grpc::Service::MarkMethodRawCallback(122,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDirectTeachingModeKey(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDirectTeachingModeKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDirectTeachingModeKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDirectTeachingModeKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAutoModeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAutoModeConfig() {
      ::grpc::Service::MarkMethodRawCallback(123,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAutoModeConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAutoModeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAutoModeConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAutoModeConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodRawCallback(124,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAutoMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodRawCallback(125,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckAutoMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckAutoMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodRawCallback(126,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckReducedMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckReducedMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetReducedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetReducedRatio() {
      ::grpc::Service::MarkMethodRawCallback(127,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetReducedRatio(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetReducedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetReducedRatio(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetReducedSpeed() {
      ::grpc::Service::MarkMethodRawCallback(128,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetReducedSpeed(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetReducedSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetReducedSpeed() {
      ::grpc::Service::MarkMethodRawCallback(129,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetReducedSpeed(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetReducedSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStopState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStopState() {
      ::grpc::Service::MarkMethodRawCallback(130,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStopState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetStopState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStopState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::StopState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStopState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodRawCallback(131,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSafetyFunctionState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSafetyFunctionState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodRawCallback(132,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RequestSafetyFunction(context, request, response); }));
    }
    ~WithRawCallbackMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestSafetyFunction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayProgram() {
      ::grpc::Service::MarkMethodRawCallback(133,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayIndexProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayIndexProgram() {
      ::grpc::Service::MarkMethodRawCallback(134,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayIndexProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayIndexProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayIndexProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayIndexProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayProgramLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayProgramLine() {
      ::grpc::Service::MarkMethodRawCallback(135,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayProgramLine(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayProgramLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayProgramLine(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayProgramLine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodRawCallback(136,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResumeProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopProgram() {
      ::grpc::Service::MarkMethodRawCallback(137,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseProgram() {
      ::grpc::Service::MarkMethodRawCallback(138,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PauseProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDO() {
      ::grpc::Service::MarkMethodRawCallback(139,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAO() {
      ::grpc::Service::MarkMethodRawCallback(140,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndDO() {
      ::grpc::Service::MarkMethodRawCallback(141,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndDO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndDO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEndAO() {
      ::grpc::Service::MarkMethodRawCallback(142,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEndAO(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEndAO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetToolList() {
      ::grpc::Service::MarkMethodRawCallback(143,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetToolList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ToolList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetToolList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetToolList() {
      ::grpc::Service::MarkMethodRawCallback(144,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetToolList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ToolList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetToolList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDIConfigList() {
      ::grpc::Service::MarkMethodRawCallback(145,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDIConfigList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DIConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDIConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDIConfigList() {
      ::grpc::Service::MarkMethodRawCallback(146,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDIConfigList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DIConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDIConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetDOConfigList() {
      ::grpc::Service::MarkMethodRawCallback(147,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDOConfigList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetDOConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDOConfigList() {
      ::grpc::Service::MarkMethodRawCallback(148,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDOConfigList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DOConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDOConfigList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodRawCallback(149,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCollSensLevel(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCollSensLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodRawCallback(150,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCollSensLevel(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollSensLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodRawCallback(151,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCollPolicy(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCollPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodRawCallback(152,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCollPolicy(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodRawCallback(153,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCollSensParam(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCollSensParam(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodRawCallback(154,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCollSensParam(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCollSensParam(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InitCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InitCollSensParam() {
      ::grpc::Service::MarkMethodRawCallback(155,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InitCollSensParam(context, request, response); }));
    }
    ~WithRawCallbackMethod_InitCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InitCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InitCollSensParam(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodRawCallback(156,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayTuningProgram(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TuningProgram* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayTuningProgram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodRawCallback(157,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTeleOpDevice(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodRawCallback(158,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTeleOpState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRawCallback(159,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectTeleOpDevice(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodRawCallback(160,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisConnectTeleOpDevice(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisConnectTeleOpDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodRawCallback(161,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadTeleOpInput(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadTeleOpInput(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartTeleCalib : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartTeleCalib() {
      ::grpc::Service::MarkMethodRawCallback(162,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartTeleCalib(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartTeleCalib() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleCalib(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleCalib(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartTeleRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartTeleRecord() {
      ::grpc::Service::MarkMethodRawCallback(163,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartTeleRecord(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartTeleRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleRecord(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartTelePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartTelePlay() {
      ::grpc::Service::MarkMethodRawCallback(164,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartTelePlay(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartTelePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTelePlay(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTelePlay(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartTeleJogL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartTeleJogL() {
      ::grpc::Service::MarkMethodRawCallback(165,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartTeleJogL(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartTeleJogL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleJogL(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartTeleJogJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartTeleJogJ() {
      ::grpc::Service::MarkMethodRawCallback(166,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartTeleJogJ(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartTeleJogJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartTeleJogJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartTeleJogJ(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodRawCallback(167,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopTeleOp(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopTeleOp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodRawCallback(168,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPlayRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TelePlayRate* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodRawCallback(169,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodRawCallback(170,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTeleFileList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleFileList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodRawCallback(171,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SaveTeleMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodRawCallback(172,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadTeleMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodRawCallback(173,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteTeleMotion(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTeleMotion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodRawCallback(174,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveTeleJ(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleJ(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodRawCallback(175,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MoveTeleL(context, request, response); }));
    }
    ~WithRawCallbackMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MoveTeleL(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetTeleOpParams() {
      ::grpc::Service::MarkMethodRawCallback(176,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTeleOpParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpParams* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTeleOpParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTeleOpParams() {
      ::grpc::Service::MarkMethodRawCallback(177,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTeleOpParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTeleOpParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetFTSensorConfig() {
      ::grpc::Service::MarkMethodRawCallback(178,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetFTSensorConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetFTSensorConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFTSensorConfig() {
      ::grpc::Service::MarkMethodRawCallback(179,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFTSensorConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFTSensorConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodRawCallback(180,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFTSensorData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFTSensorData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodRawCallback(181,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLoadFactors(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLoadFactors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodRawCallback(182,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSanderCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SanderCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodRawCallback(183,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSanderCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSanderCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSandingStopCondition() {
      ::grpc::Service::MarkMethodRawCallback(184,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSandingStopCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSandingStopCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSandingStopCondition() {
      ::grpc::Service::MarkMethodRawCallback(185,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSandingStopCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSandingStopCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGripperData() {
      ::grpc::Service::MarkMethodRawCallback(186,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGripperData(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGripperData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodRawCallback(187,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetGripperCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GripperCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetGripperCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSFDActivate() {
      ::grpc::Service::MarkMethodRawCallback(188,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSFDActivate(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSFDActivate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsSFDActivate() {
      ::grpc::Service::MarkMethodRawCallback(189,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsSFDActivate(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsSFDActivate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SFDLogin() {
      ::grpc::Service::MarkMethodRawCallback(190,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SFDLogin(context, request, response); }));
    }
    ~WithRawCallbackMethod_SFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDAccount* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SFDLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsSFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsSFDLogin() {
      ::grpc::Service::MarkMethodRawCallback(191,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsSFDLogin(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsSFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsSFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsSFDLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSFDTarget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSFDTarget() {
      ::grpc::Service::MarkMethodRawCallback(192,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSFDTarget(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSFDTarget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDTarget(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSFDTarget(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSFDOption : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSFDOption() {
      ::grpc::Service::MarkMethodRawCallback(193,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSFDOption(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSFDOption() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSFDOption(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSFDOption(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSFDProjList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSFDProjList() {
      ::grpc::Service::MarkMethodRawCallback(194,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSFDProjList(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSFDProjList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDProjList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDProjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSFDProjList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSFDCRI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSFDCRI() {
      ::grpc::Service::MarkMethodRawCallback(195,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSFDCRI(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSFDCRI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSFDCRI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDCriData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSFDCRI(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTactTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTactTime() {
      ::grpc::Service::MarkMethodRawCallback(196,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTactTime(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTactTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTactTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TactTime* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTactTime(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodRawCallback(197,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddPhotoneoCalibPoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPhotoneoCalibPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ContyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ContyInit() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::ContyInitReq, ::IndyFramework::Protobuf::HRI::ContyInitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::ContyInitReq, ::IndyFramework::Protobuf::HRI::ContyInitRes>* streamer) {
                       return this->StreamedContyInit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ContyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ContyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::ContyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedContyInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::ContyInitReq,::IndyFramework::Protobuf::HRI::ContyInitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RobotUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RobotUpdate() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::RobotData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::RobotData>* streamer) {
                       return this->StreamedRobotUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RobotUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RobotUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::RobotData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRobotUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::RobotData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProgramUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProgramUpdate() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>* streamer) {
                       return this->StreamedProgramUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProgramUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProgramUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProgramUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::ProgramData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControlUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControlUpdate() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ControlData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ControlData>* streamer) {
                       return this->StreamedControlUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControlUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControlUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ControlData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControlUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::ControlData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinearUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinearUpdate() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::LinearData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::LinearData>* streamer) {
                       return this->StreamedLinearUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinearUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinearUpdate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::LinearData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinearUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::LinearData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JogJoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JogJoint() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::JogJointReq, ::IndyFramework::Protobuf::HRI::JogJointRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::JogJointReq, ::IndyFramework::Protobuf::HRI::JogJointRes>* streamer) {
                       return this->StreamedJogJoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JogJoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JogJoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJointReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogJointRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJogJoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::JogJointReq,::IndyFramework::Protobuf::HRI::JogJointRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JogTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JogTask() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::JogTaskReq, ::IndyFramework::Protobuf::HRI::JogTaskRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::JogTaskReq, ::IndyFramework::Protobuf::HRI::JogTaskRes>* streamer) {
                       return this->StreamedJogTask(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JogTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JogTask(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogTaskReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJogTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::JogTaskReq,::IndyFramework::Protobuf::HRI::JogTaskRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JogAxis : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JogAxis() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::JogAxisReq, ::IndyFramework::Protobuf::HRI::JogAxisRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::JogAxisReq, ::IndyFramework::Protobuf::HRI::JogAxisRes>* streamer) {
                       return this->StreamedJogAxis(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JogAxis() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JogAxis(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogAxisReq* /*request*/, ::IndyFramework::Protobuf::HRI::JogAxisRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJogAxis(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::JogAxisReq,::IndyFramework::Protobuf::HRI::JogAxisRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HoldToMoveJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HoldToMoveJ() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::MoveJReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::MoveJReq, ::IndyFramework::Protobuf::HRI::Empty>* streamer) {
                       return this->StreamedHoldToMoveJ(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HoldToMoveJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HoldToMoveJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHoldToMoveJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::MoveJReq,::IndyFramework::Protobuf::HRI::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HoldToMoveL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HoldToMoveL() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::MoveLReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::MoveLReq, ::IndyFramework::Protobuf::HRI::Empty>* streamer) {
                       return this->StreamedHoldToMoveL(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HoldToMoveL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HoldToMoveL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHoldToMoveL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::MoveLReq,::IndyFramework::Protobuf::HRI::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HoldToAxisJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HoldToAxisJ() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::AxisJReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::AxisJReq, ::IndyFramework::Protobuf::HRI::Empty>* streamer) {
                       return this->StreamedHoldToAxisJ(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HoldToAxisJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HoldToAxisJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AxisJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHoldToAxisJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::AxisJReq,::IndyFramework::Protobuf::HRI::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopMotion() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::StopMotionReq, ::IndyFramework::Protobuf::HRI::StopMotionRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::StopMotionReq, ::IndyFramework::Protobuf::HRI::StopMotionRes>* streamer) {
                       return this->StreamedStopMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopMotionReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopMotionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::StopMotionReq,::IndyFramework::Protobuf::HRI::StopMotionRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRefFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRefFrame() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetRefFrameReq, ::IndyFramework::Protobuf::HRI::SetRefFrameRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetRefFrameReq, ::IndyFramework::Protobuf::HRI::SetRefFrameRes>* streamer) {
                       return this->StreamedSetRefFrame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRefFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRefFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRefFrame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetRefFrameReq,::IndyFramework::Protobuf::HRI::SetRefFrameRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRefFramePlanar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRefFramePlanar() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* streamer) {
                       return this->StreamedSetRefFramePlanar(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRefFramePlanar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRefFramePlanar(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRefFramePlanar(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetRefFramePlanarReq,::IndyFramework::Protobuf::HRI::SetRefFramePlanarRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetToolFrame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetToolFrame() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetToolFrameReq, ::IndyFramework::Protobuf::HRI::SetToolFrameRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetToolFrameReq, ::IndyFramework::Protobuf::HRI::SetToolFrameRes>* streamer) {
                       return this->StreamedSetToolFrame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetToolFrame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetToolFrame(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetToolFrame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetToolFrameReq,::IndyFramework::Protobuf::HRI::SetToolFrameRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSpeedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSpeedRatio() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* streamer) {
                       return this->StreamedSetSpeedRatio(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSpeedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSpeedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSpeedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSpeedRatio(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetSpeedRatioReq,::IndyFramework::Protobuf::HRI::SetSpeedRatioRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSimulationMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSimulationMode() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetSimulationModeReq, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetSimulationModeReq, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* streamer) {
                       return this->StreamedSetSimulationMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSimulationMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSimulationMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSimulationModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSimulationModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSimulationMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetSimulationModeReq,::IndyFramework::Protobuf::HRI::SetSimulationModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDirectTeachingMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDirectTeachingMode() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* streamer) {
                       return this->StreamedSetDirectTeachingMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDirectTeachingMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDirectTeachingMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDirectTeachingMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq,::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCustomControlMode() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::IntMode, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::IntMode, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetCustomControlMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IntMode* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCustomControlMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::IntMode,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCustomControlMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCustomControlMode() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::IntMode>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::IntMode>* streamer) {
                       return this->StreamedGetCustomControlMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCustomControlMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCustomControlMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::IntMode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCustomControlMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::IntMode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSensorlessComplianceMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSensorlessComplianceMode() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* streamer) {
                       return this->StreamedSetSensorlessComplianceMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSensorlessComplianceMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSensorlessComplianceMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSensorlessComplianceMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeReq,::IndyFramework::Protobuf::HRI::SetSensorlessComplianceModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBrakeControlStyle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBrakeControlStyle() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::BrakeControlStyle>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::BrakeControlStyle>* streamer) {
                       return this->StreamedGetBrakeControlStyle(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBrakeControlStyle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBrakeControlStyle(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::BrakeControlStyle* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBrakeControlStyle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::BrakeControlStyle>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetBrake : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetBrake() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetBrakeReq, ::IndyFramework::Protobuf::HRI::SetBrakeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetBrakeReq, ::IndyFramework::Protobuf::HRI::SetBrakeRes>* streamer) {
                       return this->StreamedSetBrake(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetBrake() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetBrake(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetBrakeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetBrakeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetBrake(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetBrakeReq,::IndyFramework::Protobuf::HRI::SetBrakeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServo() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetServoReq, ::IndyFramework::Protobuf::HRI::SetServoRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetServoReq, ::IndyFramework::Protobuf::HRI::SetServoRes>* streamer) {
                       return this->StreamedSetServo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServo(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetServoReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetServoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetServoReq,::IndyFramework::Protobuf::HRI::SetServoRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAutoServoOff() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* streamer) {
                       return this->StreamedSetAutoServoOff(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAutoServoOff(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetAutoServoOffReq,::IndyFramework::Protobuf::HRI::SetAutoServoOffRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAutoServoOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAutoServoOff() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* streamer) {
                       return this->StreamedGetAutoServoOff(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAutoServoOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAutoServoOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoServoOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAutoServoOff(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetAutoServoOffReq,::IndyFramework::Protobuf::HRI::GetAutoServoOffRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteTool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteTool() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedExecuteTool(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteTool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteTool(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteTool(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Name,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::InverseKinematicsReq, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::InverseKinematicsReq, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* streamer) {
                       return this->StreamedInverseKinematics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::InverseKinematicsReq* /*request*/, ::IndyFramework::Protobuf::HRI::InverseKinematicsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInverseKinematics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::InverseKinematicsReq,::IndyFramework::Protobuf::HRI::InverseKinematicsRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateRelativePose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateRelativePose() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* streamer) {
                       return this->StreamedCalculateRelativePose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CalculateRelativePose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateRelativePose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateRelativePose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::CalculateRelativePoseReq,::IndyFramework::Protobuf::HRI::CalculateRelativePoseRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateCurrentPoseRel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateCurrentPoseRel() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* streamer) {
                       return this->StreamedCalculateCurrentPoseRel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CalculateCurrentPoseRel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateCurrentPoseRel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq* /*request*/, ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateCurrentPoseRel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelReq,::IndyFramework::Protobuf::HRI::CalculateCurrentPoseRelRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetManualRecoverMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetManualRecoverMode() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetManualRecoverMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetManualRecoverMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetManualRecoverMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetManualRecoverMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::State,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetServoRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetServoRecover() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Servo, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Servo, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetServoRecover(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetServoRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetServoRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Servo* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetServoRecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Servo,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JogJointRecover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JogJointRecover() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::JogJTar, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::JogJTar, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedJogJointRecover(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JogJointRecover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JogJointRecover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::JogJTar* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJogJointRecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::JogJTar,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Recover() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::RecoverReq, ::IndyFramework::Protobuf::HRI::RecoverRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::RecoverReq, ::IndyFramework::Protobuf::HRI::RecoverRes>* streamer) {
                       return this->StreamedRecover(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RecoverReq* /*request*/, ::IndyFramework::Protobuf::HRI::RecoverRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::RecoverReq,::IndyFramework::Protobuf::HRI::RecoverRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Reboot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Reboot() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::RebootReq, ::IndyFramework::Protobuf::HRI::RebootRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::RebootReq, ::IndyFramework::Protobuf::HRI::RebootRes>* streamer) {
                       return this->StreamedReboot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Reboot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Reboot(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RebootReq* /*request*/, ::IndyFramework::Protobuf::HRI::RebootRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReboot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::RebootReq,::IndyFramework::Protobuf::HRI::RebootRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PowerOff : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PowerOff() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::PowerOffReq, ::IndyFramework::Protobuf::HRI::PowerOffRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::PowerOffReq, ::IndyFramework::Protobuf::HRI::PowerOffRes>* streamer) {
                       return this->StreamedPowerOff(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PowerOff() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PowerOff(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PowerOffReq* /*request*/, ::IndyFramework::Protobuf::HRI::PowerOffRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPowerOff(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::PowerOffReq,::IndyFramework::Protobuf::HRI::PowerOffRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RenameFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RenameFile() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::RenameFileReq, ::IndyFramework::Protobuf::HRI::RenameFileRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::RenameFileReq, ::IndyFramework::Protobuf::HRI::RenameFileRes>* streamer) {
                       return this->StreamedRenameFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RenameFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RenameFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RenameFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RenameFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRenameFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::RenameFileReq,::IndyFramework::Protobuf::HRI::RenameFileRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveFile() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::RemoveFileReq, ::IndyFramework::Protobuf::HRI::RemoveFileRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::RemoveFileReq, ::IndyFramework::Protobuf::HRI::RemoveFileRes>* streamer) {
                       return this->StreamedRemoveFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::RemoveFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::RemoveFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::RemoveFileReq,::IndyFramework::Protobuf::HRI::RemoveFileRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIndexProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIndexProgramList() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* streamer) {
                       return this->StreamedGetIndexProgramList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetIndexProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIndexProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetIndexProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIndexProgramList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetIndexProgramListReq,::IndyFramework::Protobuf::HRI::GetIndexProgramListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProgramList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProgramList() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetProgramListReq, ::IndyFramework::Protobuf::HRI::GetProgramListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetProgramListReq, ::IndyFramework::Protobuf::HRI::GetProgramListRes>* streamer) {
                       return this->StreamedGetProgramList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProgramList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProgramList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetProgramListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetProgramListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProgramList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetProgramListReq,::IndyFramework::Protobuf::HRI::GetProgramListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLogList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLogList() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetLogListReq, ::IndyFramework::Protobuf::HRI::GetLogListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetLogListReq, ::IndyFramework::Protobuf::HRI::GetLogListRes>* streamer) {
                       return this->StreamedGetLogList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLogList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLogList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetLogListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLogList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetLogListReq,::IndyFramework::Protobuf::HRI::GetLogListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVariableList() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetVariableListReq, ::IndyFramework::Protobuf::HRI::GetVariableListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetVariableListReq, ::IndyFramework::Protobuf::HRI::GetVariableListRes>* streamer) {
                       return this->StreamedGetVariableList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVariableList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetVariableListReq,::IndyFramework::Protobuf::HRI::GetVariableListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMonitoringVariableList() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* streamer) {
                       return this->StreamedGetMonitoringVariableList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMonitoringVariableList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetMonitoringVariableListReq,::IndyFramework::Protobuf::HRI::GetMonitoringVariableListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMonitoringVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetMonitoringVariableList() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* streamer) {
                       return this->StreamedSetMonitoringVariableList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetMonitoringVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMonitoringVariableList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMonitoringVariableList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetMonitoringVariableListReq,::IndyFramework::Protobuf::HRI::SetMonitoringVariableListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPalletMakerList() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* streamer) {
                       return this->StreamedGetPalletMakerList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPalletMakerList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetPalletMakerListReq,::IndyFramework::Protobuf::HRI::GetPalletMakerListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPalletMakerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPalletMakerList() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* streamer) {
                       return this->StreamedSetPalletMakerList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPalletMakerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPalletMakerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletMakerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPalletMakerList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetPalletMakerListReq,::IndyFramework::Protobuf::HRI::SetPalletMakerListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckAproachRetractValid : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckAproachRetractValid() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* streamer) {
                       return this->StreamedCheckAproachRetractValid(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckAproachRetractValid() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckAproachRetractValid(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckAproachRetractValid(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::CheckAproachRetractValidReq,::IndyFramework::Protobuf::HRI::CheckAproachRetractValidRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPalletPointList() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetPalletPointListReq, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetPalletPointListReq, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* streamer) {
                       return this->StreamedGetPalletPointList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPalletPointList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetPalletPointListReq,::IndyFramework::Protobuf::HRI::GetPalletPointListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPalletPointList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPalletPointList() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetPalletPointListReq, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetPalletPointListReq, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* streamer) {
                       return this->StreamedSetPalletPointList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPalletPointList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPalletPointList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetPalletPointListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetPalletPointListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPalletPointList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetPalletPointListReq,::IndyFramework::Protobuf::HRI::SetPalletPointListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConveyor() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Conveyor>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Conveyor>* streamer) {
                       return this->StreamedGetConveyor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Conveyor* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConveyor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Conveyor>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorName() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetConveyorName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Name,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorByName() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Name, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetConveyorByName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorByName(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Name* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorByName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Name,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorEncoder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorEncoder() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Encoder, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Encoder, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetConveyorEncoder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorEncoder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorEncoder(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Encoder* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorEncoder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Encoder,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorTrigger : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorTrigger() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Trigger, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Trigger, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetConveyorTrigger(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorTrigger(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Trigger* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorTrigger(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Trigger,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorOffset() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Float, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Float, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetConveyorOffset(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorOffset(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Float* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorOffset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Float,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorStartingPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorStartingPose() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetConveyorStartingPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorStartingPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorStartingPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorStartingPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::PosePair,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorTerminalPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorTerminalPose() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::PosePair, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetConveyorTerminalPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorTerminalPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorTerminalPose(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PosePair* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorTerminalPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::PosePair,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConveyorState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConveyorState() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ConveyorState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ConveyorState>* streamer) {
                       return this->StreamedGetConveyorState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConveyorState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConveyorState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ConveyorState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConveyorState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::ConveyorState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HoldToMoveConveyor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HoldToMoveConveyor() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedHoldToMoveConveyor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HoldToMoveConveyor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HoldToMoveConveyor(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHoldToMoveConveyor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::HoldToMoveConveyorReq,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConveyorList() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetConveyorListReq, ::IndyFramework::Protobuf::HRI::GetConveyorListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetConveyorListReq, ::IndyFramework::Protobuf::HRI::GetConveyorListRes>* streamer) {
                       return this->StreamedGetConveyorList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConveyorList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetConveyorListReq,::IndyFramework::Protobuf::HRI::GetConveyorListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetConveyorList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetConveyorList() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetConveyorListReq, ::IndyFramework::Protobuf::HRI::SetConveyorListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetConveyorListReq, ::IndyFramework::Protobuf::HRI::SetConveyorListRes>* streamer) {
                       return this->StreamedSetConveyorList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetConveyorList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetConveyorList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetConveyorListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetConveyorListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetConveyorList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetConveyorListReq,::IndyFramework::Protobuf::HRI::SetConveyorListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetInching() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetInchingReq, ::IndyFramework::Protobuf::HRI::SetInchingRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetInchingReq, ::IndyFramework::Protobuf::HRI::SetInchingRes>* streamer) {
                       return this->StreamedSetInching(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetInching(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetInchingReq,::IndyFramework::Protobuf::HRI::SetInchingRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopInching : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopInching() {
      ::grpc::Service::MarkMethodStreamed(68,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::StopInchingReq, ::IndyFramework::Protobuf::HRI::StopInchingRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::StopInchingReq, ::IndyFramework::Protobuf::HRI::StopInchingRes>* streamer) {
                       return this->StreamedStopInching(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopInching() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopInching(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopInchingReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopInchingRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopInching(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::StopInchingReq,::IndyFramework::Protobuf::HRI::StopInchingRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetArc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetArc() {
      ::grpc::Service::MarkMethodStreamed(69,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetArcReq, ::IndyFramework::Protobuf::HRI::SetArcRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetArcReq, ::IndyFramework::Protobuf::HRI::SetArcRes>* streamer) {
                       return this->StreamedSetArc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetArc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetArc(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetArcReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetArcRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetArc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetArcReq,::IndyFramework::Protobuf::HRI::SetArcRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTouch() {
      ::grpc::Service::MarkMethodStreamed(70,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetTouchReq, ::IndyFramework::Protobuf::HRI::SetTouchRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetTouchReq, ::IndyFramework::Protobuf::HRI::SetTouchRes>* streamer) {
                       return this->StreamedSetTouch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTouch(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTouchReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTouchRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTouch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetTouchReq,::IndyFramework::Protobuf::HRI::SetTouchRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetGas : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetGas() {
      ::grpc::Service::MarkMethodStreamed(71,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetGasReq, ::IndyFramework::Protobuf::HRI::SetGasRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetGasReq, ::IndyFramework::Protobuf::HRI::SetGasRes>* streamer) {
                       return this->StreamedSetGas(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetGas() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetGas(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetGasReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetGasRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetGas(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetGasReq,::IndyFramework::Protobuf::HRI::SetGasRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsTouched : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsTouched() {
      ::grpc::Service::MarkMethodStreamed(72,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::IsTouchedReq, ::IndyFramework::Protobuf::HRI::IsTouchedRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::IsTouchedReq, ::IndyFramework::Protobuf::HRI::IsTouchedRes>* streamer) {
                       return this->StreamedIsTouched(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsTouched() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsTouched(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::IsTouchedReq* /*request*/, ::IndyFramework::Protobuf::HRI::IsTouchedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsTouched(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::IsTouchedReq,::IndyFramework::Protobuf::HRI::IsTouchedRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVisionServerList() {
      ::grpc::Service::MarkMethodStreamed(73,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetVisionServerListReq, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetVisionServerListReq, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* streamer) {
                       return this->StreamedGetVisionServerList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVisionServerList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetVisionServerListReq,::IndyFramework::Protobuf::HRI::GetVisionServerListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVisionServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVisionServerList() {
      ::grpc::Service::MarkMethodStreamed(74,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetVisionServerListReq, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetVisionServerListReq, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* streamer) {
                       return this->StreamedSetVisionServerList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVisionServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVisionServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetVisionServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetVisionServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVisionServerList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetVisionServerListReq,::IndyFramework::Protobuf::HRI::SetVisionServerListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVisionObjectList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVisionObjectList() {
      ::grpc::Service::MarkMethodStreamed(75,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* streamer) {
                       return this->StreamedGetVisionObjectList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVisionObjectList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVisionObjectList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetVisionObjectListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVisionObjectList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetVisionObjectListReq,::IndyFramework::Protobuf::HRI::GetVisionObjectListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVisionDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVisionDetection() {
      ::grpc::Service::MarkMethodStreamed(76,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>* streamer) {
                       return this->StreamedGetVisionDetection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVisionDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVisionDetection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVisionDetection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::VisionRequest,::IndyFramework::Protobuf::HRI::VisionResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVisionRetrieval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVisionRetrieval() {
      ::grpc::Service::MarkMethodStreamed(77,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::VisionRequest, ::IndyFramework::Protobuf::HRI::VisionResult>* streamer) {
                       return this->StreamedGetVisionRetrieval(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVisionRetrieval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVisionRetrieval(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::VisionRequest* /*request*/, ::IndyFramework::Protobuf::HRI::VisionResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVisionRetrieval(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::VisionRequest,::IndyFramework::Protobuf::HRI::VisionResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGcodeMotionList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGcodeMotionList() {
      ::grpc::Service::MarkMethodStreamed(78,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* streamer) {
                       return this->StreamedGetGcodeMotionList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGcodeMotionList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGcodeMotionList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGcodeMotionList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetGcodeMotionListReq,::IndyFramework::Protobuf::HRI::GetGcodeMotionListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModbusServerList() {
      ::grpc::Service::MarkMethodStreamed(79,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetModbusServerListReq, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetModbusServerListReq, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* streamer) {
                       return this->StreamedGetModbusServerList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModbusServerList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetModbusServerListReq,::IndyFramework::Protobuf::HRI::GetModbusServerListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetModbusServerList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetModbusServerList() {
      ::grpc::Service::MarkMethodStreamed(80,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetModbusServerListReq, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetModbusServerListReq, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* streamer) {
                       return this->StreamedSetModbusServerList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetModbusServerList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetModbusServerList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetModbusServerListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetModbusServerListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetModbusServerList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetModbusServerListReq,::IndyFramework::Protobuf::HRI::SetModbusServerListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckModbusConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckModbusConnection() {
      ::grpc::Service::MarkMethodStreamed(81,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* streamer) {
                       return this->StreamedCheckModbusConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckModbusConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckModbusConnection(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq* /*request*/, ::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckModbusConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::CheckModbusConnectionReq,::IndyFramework::Protobuf::HRI::CheckModbusConnectionRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetToolFrameList() {
      ::grpc::Service::MarkMethodStreamed(82,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetToolFrameListReq, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetToolFrameListReq, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* streamer) {
                       return this->StreamedGetToolFrameList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetToolFrameList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetToolFrameListReq,::IndyFramework::Protobuf::HRI::GetToolFrameListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetToolFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetToolFrameList() {
      ::grpc::Service::MarkMethodStreamed(83,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetToolFrameListReq, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetToolFrameListReq, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* streamer) {
                       return this->StreamedSetToolFrameList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetToolFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetToolFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetToolFrameList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetToolFrameListReq,::IndyFramework::Protobuf::HRI::SetToolFrameListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRefFrameList() {
      ::grpc::Service::MarkMethodStreamed(84,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetRefFrameListReq, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetRefFrameListReq, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* streamer) {
                       return this->StreamedGetRefFrameList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRefFrameList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetRefFrameListReq,::IndyFramework::Protobuf::HRI::GetRefFrameListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRefFrameList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRefFrameList() {
      ::grpc::Service::MarkMethodStreamed(85,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetRefFrameListReq, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetRefFrameListReq, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* streamer) {
                       return this->StreamedSetRefFrameList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRefFrameList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRefFrameList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetRefFrameListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetRefFrameListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRefFrameList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetRefFrameListReq,::IndyFramework::Protobuf::HRI::SetRefFrameListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCustomPosList() {
      ::grpc::Service::MarkMethodStreamed(86,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetCustomPosListReq, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetCustomPosListReq, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* streamer) {
                       return this->StreamedGetCustomPosList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCustomPosList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetCustomPosListReq,::IndyFramework::Protobuf::HRI::GetCustomPosListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCustomPosList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCustomPosList() {
      ::grpc::Service::MarkMethodStreamed(87,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetCustomPosListReq, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetCustomPosListReq, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* streamer) {
                       return this->StreamedSetCustomPosList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCustomPosList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCustomPosList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetCustomPosListReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetCustomPosListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCustomPosList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetCustomPosListReq,::IndyFramework::Protobuf::HRI::SetCustomPosListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetJointControlGain() {
      ::grpc::Service::MarkMethodStreamed(88,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetJointControlGainReq, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetJointControlGainReq, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* streamer) {
                       return this->StreamedSetJointControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetJointControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetJointControlGainReq,::IndyFramework::Protobuf::HRI::SetJointControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointControlGain() {
      ::grpc::Service::MarkMethodStreamed(89,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetJointControlGainReq, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetJointControlGainReq, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* streamer) {
                       return this->StreamedGetJointControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetJointControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetJointControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetJointControlGainReq,::IndyFramework::Protobuf::HRI::GetJointControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTaskControlGain() {
      ::grpc::Service::MarkMethodStreamed(90,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* streamer) {
                       return this->StreamedSetTaskControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTaskControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetTaskControlGainReq,::IndyFramework::Protobuf::HRI::SetTaskControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTaskControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTaskControlGain() {
      ::grpc::Service::MarkMethodStreamed(91,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* streamer) {
                       return this->StreamedGetTaskControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTaskControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTaskControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetTaskControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTaskControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetTaskControlGainReq,::IndyFramework::Protobuf::HRI::GetTaskControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetImpedanceControlGain() {
      ::grpc::Service::MarkMethodStreamed(92,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* streamer) {
                       return this->StreamedSetImpedanceControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetImpedanceControlGainReq,::IndyFramework::Protobuf::HRI::SetImpedanceControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetImpedanceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetImpedanceControlGain() {
      ::grpc::Service::MarkMethodStreamed(93,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* streamer) {
                       return this->StreamedGetImpedanceControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetImpedanceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetImpedanceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetImpedanceControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetImpedanceControlGainReq,::IndyFramework::Protobuf::HRI::GetImpedanceControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetForceControlGain() {
      ::grpc::Service::MarkMethodStreamed(94,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetForceControlGainReq, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetForceControlGainReq, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* streamer) {
                       return this->StreamedSetForceControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetForceControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetForceControlGainReq,::IndyFramework::Protobuf::HRI::SetForceControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetForceControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetForceControlGain() {
      ::grpc::Service::MarkMethodStreamed(95,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetForceControlGainReq, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetForceControlGainReq, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* streamer) {
                       return this->StreamedGetForceControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetForceControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetForceControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetForceControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetForceControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetForceControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetForceControlGainReq,::IndyFramework::Protobuf::HRI::GetForceControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetExtAxisControlGain() {
      ::grpc::Service::MarkMethodStreamed(96,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* streamer) {
                       return this->StreamedSetExtAxisControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetExtAxisControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetExtAxisControlGainReq,::IndyFramework::Protobuf::HRI::SetExtAxisControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExtAxisControlGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetExtAxisControlGain() {
      ::grpc::Service::MarkMethodStreamed(97,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* streamer) {
                       return this->StreamedGetExtAxisControlGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetExtAxisControlGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExtAxisControlGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExtAxisControlGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetExtAxisControlGainReq,::IndyFramework::Protobuf::HRI::GetExtAxisControlGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodStreamed(98,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* streamer) {
                       return this->StreamedSetSensorlessComplianceControlJointGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq,::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSensorlessComplianceControlJointGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSensorlessComplianceControlJointGain() {
      ::grpc::Service::MarkMethodStreamed(99,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* streamer) {
                       return this->StreamedGetSensorlessComplianceControlJointGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSensorlessComplianceControlJointGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSensorlessComplianceControlJointGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSensorlessComplianceControlJointGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq,::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodStreamed(100,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* streamer) {
                       return this->StreamedSetSensorlessComplianceControlTaskGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainReq,::IndyFramework::Protobuf::HRI::SetSensorlessComplianceGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSensorlessComplianceControlTaskGain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSensorlessComplianceControlTaskGain() {
      ::grpc::Service::MarkMethodStreamed(101,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* streamer) {
                       return this->StreamedGetSensorlessComplianceControlTaskGain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSensorlessComplianceControlTaskGain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSensorlessComplianceControlTaskGain(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSensorlessComplianceControlTaskGain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainReq,::IndyFramework::Protobuf::HRI::GetSensorlessComplianceGainRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetFricComp() {
      ::grpc::Service::MarkMethodStreamed(102,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetFricCompReq, ::IndyFramework::Protobuf::HRI::SetFricCompRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetFricCompReq, ::IndyFramework::Protobuf::HRI::SetFricCompRes>* streamer) {
                       return this->StreamedSetFricComp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetFricComp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetFricCompReq,::IndyFramework::Protobuf::HRI::SetFricCompRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFricComp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFricComp() {
      ::grpc::Service::MarkMethodStreamed(103,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetFricCompReq, ::IndyFramework::Protobuf::HRI::GetFricCompRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetFricCompReq, ::IndyFramework::Protobuf::HRI::GetFricCompRes>* streamer) {
                       return this->StreamedGetFricComp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFricComp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFricComp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFricCompReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetFricCompRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFricComp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetFricCompReq,::IndyFramework::Protobuf::HRI::GetFricCompRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetHomePos() {
      ::grpc::Service::MarkMethodStreamed(104,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetHomePosReq, ::IndyFramework::Protobuf::HRI::SetHomePosRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetHomePosReq, ::IndyFramework::Protobuf::HRI::SetHomePosRes>* streamer) {
                       return this->StreamedSetHomePos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetHomePos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetHomePosReq,::IndyFramework::Protobuf::HRI::SetHomePosRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetHomePos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetHomePos() {
      ::grpc::Service::MarkMethodStreamed(105,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetHomePosReq, ::IndyFramework::Protobuf::HRI::GetHomePosRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetHomePosReq, ::IndyFramework::Protobuf::HRI::GetHomePosRes>* streamer) {
                       return this->StreamedGetHomePos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetHomePos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetHomePos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetHomePosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetHomePosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetHomePos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetHomePosReq,::IndyFramework::Protobuf::HRI::GetHomePosRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetMountPos() {
      ::grpc::Service::MarkMethodStreamed(106,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetMountPosReq, ::IndyFramework::Protobuf::HRI::SetMountPosRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetMountPosReq, ::IndyFramework::Protobuf::HRI::SetMountPosRes>* streamer) {
                       return this->StreamedSetMountPos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetMountPos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetMountPosReq,::IndyFramework::Protobuf::HRI::SetMountPosRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMountPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMountPos() {
      ::grpc::Service::MarkMethodStreamed(107,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetMountPosReq, ::IndyFramework::Protobuf::HRI::GetMountPosRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetMountPosReq, ::IndyFramework::Protobuf::HRI::GetMountPosRes>* streamer) {
                       return this->StreamedGetMountPos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMountPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMountPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetMountPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetMountPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMountPos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetMountPosReq,::IndyFramework::Protobuf::HRI::GetMountPosRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPackagingPos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPackagingPos() {
      ::grpc::Service::MarkMethodStreamed(108,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetPackagingPosReq, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetPackagingPosReq, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* streamer) {
                       return this->StreamedGetPackagingPos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPackagingPos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPackagingPos(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetPackagingPosReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetPackagingPosRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPackagingPos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetPackagingPosReq,::IndyFramework::Protobuf::HRI::GetPackagingPosRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetToolProperty() {
      ::grpc::Service::MarkMethodStreamed(109,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetToolPropertyReq, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetToolPropertyReq, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* streamer) {
                       return this->StreamedSetToolProperty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetToolProperty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetToolPropertyReq,::IndyFramework::Protobuf::HRI::SetToolPropertyRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetToolProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetToolProperty() {
      ::grpc::Service::MarkMethodStreamed(110,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetToolPropertyReq, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetToolPropertyReq, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* streamer) {
                       return this->StreamedGetToolProperty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetToolProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetToolProperty(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetToolPropertyReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetToolPropertyRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetToolProperty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetToolPropertyReq,::IndyFramework::Protobuf::HRI::GetToolPropertyRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodStreamed(111,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* streamer) {
                       return this->StreamedGetOnStartProgramConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOnStartProgramConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigReq,::IndyFramework::Protobuf::HRI::GetOnStartProgramConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetOnStartProgramConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetOnStartProgramConfig() {
      ::grpc::Service::MarkMethodStreamed(112,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* streamer) {
                       return this->StreamedSetOnStartProgramConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetOnStartProgramConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetOnStartProgramConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetOnStartProgramConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigReq,::IndyFramework::Protobuf::HRI::SetOnStartProgramConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodStreamed(113,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* streamer) {
                       return this->StreamedGetSafetyLimitConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigReq,::IndyFramework::Protobuf::HRI::GetSafetyLimitConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSafetyLimitConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSafetyLimitConfig() {
      ::grpc::Service::MarkMethodStreamed(114,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* streamer) {
                       return this->StreamedSetSafetyLimitConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSafetyLimitConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSafetyLimitConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSafetyLimitConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigReq,::IndyFramework::Protobuf::HRI::SetSafetyLimitConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyStopConfig() {
      ::grpc::Service::MarkMethodStreamed(115,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* streamer) {
                       return this->StreamedGetSafetyStopConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetSafetyStopConfigReq,::IndyFramework::Protobuf::HRI::GetSafetyStopConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSafetyStopConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSafetyStopConfig() {
      ::grpc::Service::MarkMethodStreamed(116,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* streamer) {
                       return this->StreamedSetSafetyStopConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSafetyStopConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSafetyStopConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSafetyStopConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetSafetyStopConfigReq,::IndyFramework::Protobuf::HRI::SetSafetyStopConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyConfigHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyConfigHash() {
      ::grpc::Service::MarkMethodStreamed(117,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* streamer) {
                       return this->StreamedGetSafetyConfigHash(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSafetyConfigHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyConfigHash(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq* /*request*/, ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyConfigHash(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GetSafetyConfigHashReq,::IndyFramework::Protobuf::HRI::GetSafetyConfigHashRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetKinematicsParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetKinematicsParams() {
      ::grpc::Service::MarkMethodStreamed(118,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::KinematicsParams>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::KinematicsParams>* streamer) {
                       return this->StreamedGetKinematicsParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetKinematicsParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetKinematicsParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::KinematicsParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetKinematicsParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::KinematicsParams>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KeyInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KeyInit() {
      ::grpc::Service::MarkMethodStreamed(119,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::KeyInitReq, ::IndyFramework::Protobuf::HRI::KeyInitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::KeyInitReq, ::IndyFramework::Protobuf::HRI::KeyInitRes>* streamer) {
                       return this->StreamedKeyInit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KeyInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KeyInit(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyInitReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyInitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKeyInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::KeyInitReq,::IndyFramework::Protobuf::HRI::KeyInitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KeyData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KeyData() {
      ::grpc::Service::MarkMethodStreamed(120,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::KeyDataReq, ::IndyFramework::Protobuf::HRI::KeyDataRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::KeyDataReq, ::IndyFramework::Protobuf::HRI::KeyDataRes>* streamer) {
                       return this->StreamedKeyData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KeyData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KeyData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::KeyDataReq* /*request*/, ::IndyFramework::Protobuf::HRI::KeyDataRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKeyData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::KeyDataReq,::IndyFramework::Protobuf::HRI::KeyDataRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProgramUpdateKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProgramUpdateKey() {
      ::grpc::Service::MarkMethodStreamed(121,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ProgramData>* streamer) {
                       return this->StreamedProgramUpdateKey(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProgramUpdateKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProgramUpdateKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ProgramData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProgramUpdateKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::ProgramData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDirectTeachingModeKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDirectTeachingModeKey() {
      ::grpc::Service::MarkMethodStreamed(122,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* streamer) {
                       return this->StreamedSetDirectTeachingModeKey(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDirectTeachingModeKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDirectTeachingModeKey(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDirectTeachingModeKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetDirectTeachingModeReq,::IndyFramework::Protobuf::HRI::SetDirectTeachingModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAutoModeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAutoModeConfig() {
      ::grpc::Service::MarkMethodStreamed(123,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* streamer) {
                       return this->StreamedGetAutoModeConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAutoModeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAutoModeConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAutoModeConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::GetAutoModeConfigRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAutoMode() {
      ::grpc::Service::MarkMethodStreamed(124,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetAutoModeReq, ::IndyFramework::Protobuf::HRI::SetAutoModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetAutoModeReq, ::IndyFramework::Protobuf::HRI::SetAutoModeRes>* streamer) {
                       return this->StreamedSetAutoMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetAutoModeReq* /*request*/, ::IndyFramework::Protobuf::HRI::SetAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAutoMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetAutoModeReq,::IndyFramework::Protobuf::HRI::SetAutoModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckAutoMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckAutoMode() {
      ::grpc::Service::MarkMethodStreamed(125,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* streamer) {
                       return this->StreamedCheckAutoMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckAutoMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckAutoMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckAutoModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckAutoMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::CheckAutoModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckReducedMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckReducedMode() {
      ::grpc::Service::MarkMethodStreamed(126,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* streamer) {
                       return this->StreamedCheckReducedMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckReducedMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckReducedMode(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CheckReducedModeRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckReducedMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::CheckReducedModeRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetReducedRatio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetReducedRatio() {
      ::grpc::Service::MarkMethodStreamed(127,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* streamer) {
                       return this->StreamedGetReducedRatio(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetReducedRatio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetReducedRatio(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedRatioRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetReducedRatio(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::GetReducedRatioRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetReducedSpeed() {
      ::grpc::Service::MarkMethodStreamed(128,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* streamer) {
                       return this->StreamedGetReducedSpeed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetReducedSpeedRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetReducedSpeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::GetReducedSpeedRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetReducedSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetReducedSpeed() {
      ::grpc::Service::MarkMethodStreamed(129,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetReducedSpeed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetReducedSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetReducedSpeed(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetReducedSpeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SetReducedSpeedReq,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStopState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStopState() {
      ::grpc::Service::MarkMethodStreamed(130,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::StopState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::StopState>* streamer) {
                       return this->StreamedGetStopState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStopState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStopState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::StopState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStopState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::StopState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSafetyFunctionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSafetyFunctionState() {
      ::grpc::Service::MarkMethodStreamed(131,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SafetyFunctionState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SafetyFunctionState>* streamer) {
                       return this->StreamedGetSafetyFunctionState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSafetyFunctionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSafetyFunctionState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSafetyFunctionState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::SafetyFunctionState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestSafetyFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RequestSafetyFunction() {
      ::grpc::Service::MarkMethodStreamed(132,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SafetyFunctionState, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SafetyFunctionState, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedRequestSafetyFunction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RequestSafetyFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestSafetyFunction(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SafetyFunctionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestSafetyFunction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SafetyFunctionState,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayProgram() {
      ::grpc::Service::MarkMethodStreamed(133,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::PlayProgramReq, ::IndyFramework::Protobuf::HRI::PlayProgramRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::PlayProgramReq, ::IndyFramework::Protobuf::HRI::PlayProgramRes>* streamer) {
                       return this->StreamedPlayProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::PlayProgramReq,::IndyFramework::Protobuf::HRI::PlayProgramRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayIndexProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayIndexProgram() {
      ::grpc::Service::MarkMethodStreamed(134,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* streamer) {
                       return this->StreamedPlayIndexProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayIndexProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayIndexProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayIndexProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayIndexProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::PlayIndexProgramReq,::IndyFramework::Protobuf::HRI::PlayIndexProgramRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayProgramLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayProgramLine() {
      ::grpc::Service::MarkMethodStreamed(135,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::PlayProgramLineReq, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::PlayProgramLineReq, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* streamer) {
                       return this->StreamedPlayProgramLine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayProgramLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayProgramLine(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PlayProgramLineReq* /*request*/, ::IndyFramework::Protobuf::HRI::PlayProgramLineRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayProgramLine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::PlayProgramLineReq,::IndyFramework::Protobuf::HRI::PlayProgramLineRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResumeProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResumeProgram() {
      ::grpc::Service::MarkMethodStreamed(136,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::ResumeProgramReq, ::IndyFramework::Protobuf::HRI::ResumeProgramRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::ResumeProgramReq, ::IndyFramework::Protobuf::HRI::ResumeProgramRes>* streamer) {
                       return this->StreamedResumeProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResumeProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResumeProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ResumeProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::ResumeProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResumeProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::ResumeProgramReq,::IndyFramework::Protobuf::HRI::ResumeProgramRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopProgram() {
      ::grpc::Service::MarkMethodStreamed(137,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::StopProgramReq, ::IndyFramework::Protobuf::HRI::StopProgramRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::StopProgramReq, ::IndyFramework::Protobuf::HRI::StopProgramRes>* streamer) {
                       return this->StreamedStopProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::StopProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::StopProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::StopProgramReq,::IndyFramework::Protobuf::HRI::StopProgramRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseProgram() {
      ::grpc::Service::MarkMethodStreamed(138,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::PauseProgramReq, ::IndyFramework::Protobuf::HRI::PauseProgramRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::PauseProgramReq, ::IndyFramework::Protobuf::HRI::PauseProgramRes>* streamer) {
                       return this->StreamedPauseProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::PauseProgramReq* /*request*/, ::IndyFramework::Protobuf::HRI::PauseProgramRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::PauseProgramReq,::IndyFramework::Protobuf::HRI::PauseProgramRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDO() {
      ::grpc::Service::MarkMethodStreamed(139,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::DOSignals, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::DOSignals, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::DOSignals,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAO() {
      ::grpc::Service::MarkMethodStreamed(140,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetAO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::AOSignals,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndDO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndDO() {
      ::grpc::Service::MarkMethodStreamed(141,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::EndtoolSignalList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::EndtoolSignalList, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetEndDO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndDO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndDO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::EndtoolSignalList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndDO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::EndtoolSignalList,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEndAO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEndAO() {
      ::grpc::Service::MarkMethodStreamed(142,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::AOSignals, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetEndAO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEndAO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEndAO(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AOSignals* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEndAO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::AOSignals,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetToolList() {
      ::grpc::Service::MarkMethodStreamed(143,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::ToolList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::ToolList, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetToolList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::ToolList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetToolList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::ToolList,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetToolList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetToolList() {
      ::grpc::Service::MarkMethodStreamed(144,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ToolList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::ToolList>* streamer) {
                       return this->StreamedGetToolList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetToolList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetToolList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::ToolList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetToolList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::ToolList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDIConfigList() {
      ::grpc::Service::MarkMethodStreamed(145,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::DIConfigList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::DIConfigList, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetDIConfigList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DIConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDIConfigList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::DIConfigList,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDIConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDIConfigList() {
      ::grpc::Service::MarkMethodStreamed(146,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DIConfigList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DIConfigList>* streamer) {
                       return this->StreamedGetDIConfigList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDIConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDIConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DIConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDIConfigList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::DIConfigList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetDOConfigList() {
      ::grpc::Service::MarkMethodStreamed(147,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::DOConfigList, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::DOConfigList, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetDOConfigList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::DOConfigList* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDOConfigList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::DOConfigList,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDOConfigList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDOConfigList() {
      ::grpc::Service::MarkMethodStreamed(148,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DOConfigList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::DOConfigList>* streamer) {
                       return this->StreamedGetDOConfigList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDOConfigList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDOConfigList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::DOConfigList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDOConfigList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::DOConfigList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCollSensLevel() {
      ::grpc::Service::MarkMethodStreamed(149,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::CollisionSensLevel, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::CollisionSensLevel, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetCollSensLevel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCollSensLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::CollisionSensLevel,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollSensLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollSensLevel() {
      ::grpc::Service::MarkMethodStreamed(150,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionSensLevel>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionSensLevel>* streamer) {
                       return this->StreamedGetCollSensLevel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCollSensLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollSensLevel(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionSensLevel* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollSensLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::CollisionSensLevel>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCollPolicy() {
      ::grpc::Service::MarkMethodStreamed(151,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::CollisionPolicy, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::CollisionPolicy, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetCollPolicy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCollPolicy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::CollisionPolicy,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollPolicy() {
      ::grpc::Service::MarkMethodStreamed(152,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionPolicy>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionPolicy>* streamer) {
                       return this->StreamedGetCollPolicy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCollPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollPolicy(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionPolicy* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollPolicy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::CollisionPolicy>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCollSensParam() {
      ::grpc::Service::MarkMethodStreamed(153,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::CollisionThresholds, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::CollisionThresholds, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetCollSensParam(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCollSensParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::CollisionThresholds,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollSensParam() {
      ::grpc::Service::MarkMethodStreamed(154,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionThresholds>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::CollisionThresholds>* streamer) {
                       return this->StreamedGetCollSensParam(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollSensParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::CollisionThresholds>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InitCollSensParam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InitCollSensParam() {
      ::grpc::Service::MarkMethodStreamed(155,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedInitCollSensParam(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InitCollSensParam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InitCollSensParam(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInitCollSensParam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayTuningProgram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayTuningProgram() {
      ::grpc::Service::MarkMethodStreamed(156,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::TuningProgram, ::IndyFramework::Protobuf::HRI::CollisionThresholds>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::TuningProgram, ::IndyFramework::Protobuf::HRI::CollisionThresholds>* streamer) {
                       return this->StreamedPlayTuningProgram(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayTuningProgram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayTuningProgram(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TuningProgram* /*request*/, ::IndyFramework::Protobuf::HRI::CollisionThresholds* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayTuningProgram(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::TuningProgram,::IndyFramework::Protobuf::HRI::CollisionThresholds>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTeleOpDevice() {
      ::grpc::Service::MarkMethodStreamed(157,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpDevice>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpDevice>* streamer) {
                       return this->StreamedGetTeleOpDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTeleOpDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::TeleOpDevice>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTeleOpState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTeleOpState() {
      ::grpc::Service::MarkMethodStreamed(158,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpState>* streamer) {
                       return this->StreamedGetTeleOpState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTeleOpState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTeleOpState(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTeleOpState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::TeleOpState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodStreamed(159,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::TeleOpDevice, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::TeleOpDevice, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedConnectTeleOpDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::TeleOpDevice,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisConnectTeleOpDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisConnectTeleOpDevice() {
      ::grpc::Service::MarkMethodStreamed(160,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedDisConnectTeleOpDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisConnectTeleOpDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisConnectTeleOpDevice(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisConnectTeleOpDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadTeleOpInput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadTeleOpInput() {
      ::grpc::Service::MarkMethodStreamed(161,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleP>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleP>* streamer) {
                       return this->StreamedReadTeleOpInput(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadTeleOpInput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadTeleOpInput(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleP* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadTeleOpInput(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::TeleP>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartTeleCalib : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartTeleCalib() {
      ::grpc::Service::MarkMethodStreamed(162,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedStartTeleCalib(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartTeleCalib() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTeleCalib(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartTeleCalib(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartTeleRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartTeleRecord() {
      ::grpc::Service::MarkMethodStreamed(163,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedStartTeleRecord(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartTeleRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTeleRecord(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartTeleRecord(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartTelePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartTelePlay() {
      ::grpc::Service::MarkMethodStreamed(164,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedStartTelePlay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartTelePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTelePlay(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartTelePlay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartTeleJogL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartTeleJogL() {
      ::grpc::Service::MarkMethodStreamed(165,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedStartTeleJogL(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartTeleJogL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTeleJogL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartTeleJogL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartTeleJogJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartTeleJogJ() {
      ::grpc::Service::MarkMethodStreamed(166,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedStartTeleJogJ(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartTeleJogJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartTeleJogJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartTeleJogJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopTeleOp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopTeleOp() {
      ::grpc::Service::MarkMethodStreamed(167,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedStopTeleOp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopTeleOp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopTeleOp(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopTeleOp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPlayRate() {
      ::grpc::Service::MarkMethodStreamed(168,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::TelePlayRate, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::TelePlayRate, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetPlayRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TelePlayRate* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPlayRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::TelePlayRate,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayRate() {
      ::grpc::Service::MarkMethodStreamed(169,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TelePlayRate>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TelePlayRate>* streamer) {
                       return this->StreamedGetPlayRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayRate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TelePlayRate* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::TelePlayRate>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTeleFileList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTeleFileList() {
      ::grpc::Service::MarkMethodStreamed(170,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpFileList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpFileList>* streamer) {
                       return this->StreamedGetTeleFileList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTeleFileList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTeleFileList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpFileList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTeleFileList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::TeleOpFileList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SaveTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SaveTeleMotion() {
      ::grpc::Service::MarkMethodStreamed(171,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSaveTeleMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SaveTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SaveTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSaveTeleMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::TeleFileReq,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadTeleMotion() {
      ::grpc::Service::MarkMethodStreamed(172,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedLoadTeleMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoadTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadTeleMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::TeleFileReq,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteTeleMotion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteTeleMotion() {
      ::grpc::Service::MarkMethodStreamed(173,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::TeleFileReq, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedDeleteTeleMotion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteTeleMotion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteTeleMotion(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleFileReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteTeleMotion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::TeleFileReq,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveTeleJ : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveTeleJ() {
      ::grpc::Service::MarkMethodStreamed(174,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::MoveTeleJReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::MoveTeleJReq, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedMoveTeleJ(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveTeleJ() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveTeleJ(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleJReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveTeleJ(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::MoveTeleJReq,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveTeleL : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MoveTeleL() {
      ::grpc::Service::MarkMethodStreamed(175,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::MoveTeleLReq, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::MoveTeleLReq, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedMoveTeleL(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MoveTeleL() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveTeleL(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::MoveTeleLReq* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveTeleL(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::MoveTeleLReq,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTeleOpParams() {
      ::grpc::Service::MarkMethodStreamed(176,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::TeleOpParams, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::TeleOpParams, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetTeleOpParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::TeleOpParams* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTeleOpParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::TeleOpParams,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTeleOpParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTeleOpParams() {
      ::grpc::Service::MarkMethodStreamed(177,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpParams>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TeleOpParams>* streamer) {
                       return this->StreamedGetTeleOpParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTeleOpParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTeleOpParams(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TeleOpParams* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTeleOpParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::TeleOpParams>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetFTSensorConfig() {
      ::grpc::Service::MarkMethodStreamed(178,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::FTSensorDevice, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::FTSensorDevice, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetFTSensorConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetFTSensorConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::FTSensorDevice,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFTSensorConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFTSensorConfig() {
      ::grpc::Service::MarkMethodStreamed(179,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorDevice>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorDevice>* streamer) {
                       return this->StreamedGetFTSensorConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFTSensorConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFTSensorConfig(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorDevice* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFTSensorConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::FTSensorDevice>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFTSensorData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFTSensorData() {
      ::grpc::Service::MarkMethodStreamed(180,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::FTSensorData>* streamer) {
                       return this->StreamedGetFTSensorData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFTSensorData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFTSensorData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::FTSensorData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFTSensorData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::FTSensorData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLoadFactors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLoadFactors() {
      ::grpc::Service::MarkMethodStreamed(181,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* streamer) {
                       return this->StreamedGetLoadFactors(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLoadFactors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLoadFactors(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GetLoadFactorsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLoadFactors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::GetLoadFactorsRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSanderCommand() {
      ::grpc::Service::MarkMethodStreamed(182,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SanderCommand, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SanderCommand, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetSanderCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SanderCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSanderCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SanderCommand,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSanderCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSanderCommand() {
      ::grpc::Service::MarkMethodStreamed(183,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SanderCommand>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SanderCommand>* streamer) {
                       return this->StreamedGetSanderCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSanderCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSanderCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SanderCommand* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSanderCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::SanderCommand>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSandingStopCondition() {
      ::grpc::Service::MarkMethodStreamed(184,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SandingStopConditionState, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SandingStopConditionState, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetSandingStopCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSandingStopCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SandingStopConditionState,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSandingStopCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSandingStopCondition() {
      ::grpc::Service::MarkMethodStreamed(185,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SandingStopConditionState>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SandingStopConditionState>* streamer) {
                       return this->StreamedGetSandingStopCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSandingStopCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSandingStopCondition(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SandingStopConditionState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSandingStopCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::SandingStopConditionState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGripperData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGripperData() {
      ::grpc::Service::MarkMethodStreamed(186,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GripperData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::GripperData>* streamer) {
                       return this->StreamedGetGripperData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGripperData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGripperData(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::GripperData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGripperData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::GripperData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetGripperCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetGripperCommand() {
      ::grpc::Service::MarkMethodStreamed(187,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::GripperCommand, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::GripperCommand, ::IndyFramework::Protobuf::HRI::Empty>* streamer) {
                       return this->StreamedSetGripperCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetGripperCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetGripperCommand(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GripperCommand* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetGripperCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::GripperCommand,::IndyFramework::Protobuf::HRI::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSFDActivate() {
      ::grpc::Service::MarkMethodStreamed(188,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetSFDActivate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSFDActivate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::State,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsSFDActivate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsSFDActivate() {
      ::grpc::Service::MarkMethodStreamed(189,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>* streamer) {
                       return this->StreamedIsSFDActivate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsSFDActivate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsSFDActivate(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsSFDActivate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::State>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SFDLogin() {
      ::grpc::Service::MarkMethodStreamed(190,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SFDAccount, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SFDAccount, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSFDLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDAccount* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSFDLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SFDAccount,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsSFDLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsSFDLogin() {
      ::grpc::Service::MarkMethodStreamed(191,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::State>* streamer) {
                       return this->StreamedIsSFDLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsSFDLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsSFDLogin(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::State* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsSFDLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::State>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSFDTarget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSFDTarget() {
      ::grpc::Service::MarkMethodStreamed(192,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::SFDCriTarget, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::SFDCriTarget, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetSFDTarget(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSFDTarget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSFDTarget(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::SFDCriTarget* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSFDTarget(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::SFDCriTarget,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSFDOption : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSFDOption() {
      ::grpc::Service::MarkMethodStreamed(193,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::State, ::IndyFramework::Protobuf::HRI::Response>* streamer) {
                       return this->StreamedSetSFDOption(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSFDOption() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSFDOption(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::State* /*request*/, ::IndyFramework::Protobuf::HRI::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSFDOption(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::State,::IndyFramework::Protobuf::HRI::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSFDProjList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSFDProjList() {
      ::grpc::Service::MarkMethodStreamed(194,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDProjectList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDProjectList>* streamer) {
                       return this->StreamedGetSFDProjList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSFDProjList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSFDProjList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDProjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSFDProjList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::SFDProjectList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSFDCRI : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSFDCRI() {
      ::grpc::Service::MarkMethodStreamed(195,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDCriData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::SFDCriData>* streamer) {
                       return this->StreamedGetSFDCRI(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSFDCRI() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSFDCRI(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::SFDCriData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSFDCRI(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::SFDCriData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTactTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTactTime() {
      ::grpc::Service::MarkMethodStreamed(196,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TactTime>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::Empty, ::IndyFramework::Protobuf::HRI::TactTime>* streamer) {
                       return this->StreamedGetTactTime(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTactTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTactTime(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::Empty* /*request*/, ::IndyFramework::Protobuf::HRI::TactTime* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTactTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::Empty,::IndyFramework::Protobuf::HRI::TactTime>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddPhotoneoCalibPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddPhotoneoCalibPoint() {
      ::grpc::Service::MarkMethodStreamed(197,
        new ::grpc::internal::StreamedUnaryHandler<
          ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq, ::IndyFramework::Protobuf::HRI::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq, ::IndyFramework::Protobuf::HRI::Empty>* streamer) {
                       return this->StreamedAddPhotoneoCalibPoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddPhotoneoCalibPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddPhotoneoCalibPoint(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq* /*request*/, ::IndyFramework::Protobuf::HRI::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddPhotoneoCalibPoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IndyFramework::Protobuf::HRI::AddPhotoneoCalibPointReq,::IndyFramework::Protobuf::HRI::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ContyInit<WithStreamedUnaryMethod_RobotUpdate<WithStreamedUnaryMethod_ProgramUpdate<WithStreamedUnaryMethod_ControlUpdate<WithStreamedUnaryMethod_LinearUpdate<WithStreamedUnaryMethod_JogJoint<WithStreamedUnaryMethod_JogTask<WithStreamedUnaryMethod_JogAxis<WithStreamedUnaryMethod_HoldToMoveJ<WithStreamedUnaryMethod_HoldToMoveL<WithStreamedUnaryMethod_HoldToAxisJ<WithStreamedUnaryMethod_StopMotion<WithStreamedUnaryMethod_SetRefFrame<WithStreamedUnaryMethod_SetRefFramePlanar<WithStreamedUnaryMethod_SetToolFrame<WithStreamedUnaryMethod_SetSpeedRatio<WithStreamedUnaryMethod_SetSimulationMode<WithStreamedUnaryMethod_SetDirectTeachingMode<WithStreamedUnaryMethod_SetCustomControlMode<WithStreamedUnaryMethod_GetCustomControlMode<WithStreamedUnaryMethod_SetSensorlessComplianceMode<WithStreamedUnaryMethod_GetBrakeControlStyle<WithStreamedUnaryMethod_SetBrake<WithStreamedUnaryMethod_SetServo<WithStreamedUnaryMethod_SetAutoServoOff<WithStreamedUnaryMethod_GetAutoServoOff<WithStreamedUnaryMethod_ExecuteTool<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_CalculateRelativePose<WithStreamedUnaryMethod_CalculateCurrentPoseRel<WithStreamedUnaryMethod_SetManualRecoverMode<WithStreamedUnaryMethod_SetServoRecover<WithStreamedUnaryMethod_JogJointRecover<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_Reboot<WithStreamedUnaryMethod_PowerOff<WithStreamedUnaryMethod_RenameFile<WithStreamedUnaryMethod_RemoveFile<WithStreamedUnaryMethod_GetIndexProgramList<WithStreamedUnaryMethod_GetProgramList<WithStreamedUnaryMethod_GetLogList<WithStreamedUnaryMethod_GetVariableList<WithStreamedUnaryMethod_GetMonitoringVariableList<WithStreamedUnaryMethod_SetMonitoringVariableList<WithStreamedUnaryMethod_GetPalletMakerList<WithStreamedUnaryMethod_SetPalletMakerList<WithStreamedUnaryMethod_CheckAproachRetractValid<WithStreamedUnaryMethod_GetPalletPointList<WithStreamedUnaryMethod_SetPalletPointList<WithStreamedUnaryMethod_GetConveyor<WithStreamedUnaryMethod_SetConveyorName<WithStreamedUnaryMethod_SetConveyorByName<WithStreamedUnaryMethod_SetConveyorEncoder<WithStreamedUnaryMethod_SetConveyorTrigger<WithStreamedUnaryMethod_SetConveyorOffset<WithStreamedUnaryMethod_SetConveyorStartingPose<WithStreamedUnaryMethod_SetConveyorTerminalPose<WithStreamedUnaryMethod_GetConveyorState<WithStreamedUnaryMethod_HoldToMoveConveyor<WithStreamedUnaryMethod_GetConveyorList<WithStreamedUnaryMethod_SetConveyorList<WithStreamedUnaryMethod_SetInching<WithStreamedUnaryMethod_StopInching<WithStreamedUnaryMethod_SetArc<WithStreamedUnaryMethod_SetTouch<WithStreamedUnaryMethod_SetGas<WithStreamedUnaryMethod_IsTouched<WithStreamedUnaryMethod_GetVisionServerList<WithStreamedUnaryMethod_SetVisionServerList<WithStreamedUnaryMethod_GetVisionObjectList<WithStreamedUnaryMethod_GetVisionDetection<WithStreamedUnaryMethod_GetVisionRetrieval<WithStreamedUnaryMethod_GetGcodeMotionList<WithStreamedUnaryMethod_GetModbusServerList<WithStreamedUnaryMethod_SetModbusServerList<WithStreamedUnaryMethod_CheckModbusConnection<WithStreamedUnaryMethod_GetToolFrameList<WithStreamedUnaryMethod_SetToolFrameList<WithStreamedUnaryMethod_GetRefFrameList<WithStreamedUnaryMethod_SetRefFrameList<WithStreamedUnaryMethod_GetCustomPosList<WithStreamedUnaryMethod_SetCustomPosList<WithStreamedUnaryMethod_SetJointControlGain<WithStreamedUnaryMethod_GetJointControlGain<WithStreamedUnaryMethod_SetTaskControlGain<WithStreamedUnaryMethod_GetTaskControlGain<WithStreamedUnaryMethod_SetImpedanceControlGain<WithStreamedUnaryMethod_GetImpedanceControlGain<WithStreamedUnaryMethod_SetForceControlGain<WithStreamedUnaryMethod_GetForceControlGain<WithStreamedUnaryMethod_SetExtAxisControlGain<WithStreamedUnaryMethod_GetExtAxisControlGain<WithStreamedUnaryMethod_SetSensorlessComplianceControlJointGain<WithStreamedUnaryMethod_GetSensorlessComplianceControlJointGain<WithStreamedUnaryMethod_SetSensorlessComplianceControlTaskGain<WithStreamedUnaryMethod_GetSensorlessComplianceControlTaskGain<WithStreamedUnaryMethod_SetFricComp<WithStreamedUnaryMethod_GetFricComp<WithStreamedUnaryMethod_SetHomePos<WithStreamedUnaryMethod_GetHomePos<WithStreamedUnaryMethod_SetMountPos<WithStreamedUnaryMethod_GetMountPos<WithStreamedUnaryMethod_GetPackagingPos<WithStreamedUnaryMethod_SetToolProperty<WithStreamedUnaryMethod_GetToolProperty<WithStreamedUnaryMethod_GetOnStartProgramConfig<WithStreamedUnaryMethod_SetOnStartProgramConfig<WithStreamedUnaryMethod_GetSafetyLimitConfig<WithStreamedUnaryMethod_SetSafetyLimitConfig<WithStreamedUnaryMethod_GetSafetyStopConfig<WithStreamedUnaryMethod_SetSafetyStopConfig<WithStreamedUnaryMethod_GetSafetyConfigHash<WithStreamedUnaryMethod_GetKinematicsParams<WithStreamedUnaryMethod_KeyInit<WithStreamedUnaryMethod_KeyData<WithStreamedUnaryMethod_ProgramUpdateKey<WithStreamedUnaryMethod_SetDirectTeachingModeKey<WithStreamedUnaryMethod_GetAutoModeConfig<WithStreamedUnaryMethod_SetAutoMode<WithStreamedUnaryMethod_CheckAutoMode<WithStreamedUnaryMethod_CheckReducedMode<WithStreamedUnaryMethod_GetReducedRatio<WithStreamedUnaryMethod_GetReducedSpeed<WithStreamedUnaryMethod_SetReducedSpeed<WithStreamedUnaryMethod_GetStopState<WithStreamedUnaryMethod_GetSafetyFunctionState<WithStreamedUnaryMethod_RequestSafetyFunction<WithStreamedUnaryMethod_PlayProgram<WithStreamedUnaryMethod_PlayIndexProgram<WithStreamedUnaryMethod_PlayProgramLine<WithStreamedUnaryMethod_ResumeProgram<WithStreamedUnaryMethod_StopProgram<WithStreamedUnaryMethod_PauseProgram<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_SetAO<WithStreamedUnaryMethod_SetEndDO<WithStreamedUnaryMethod_SetEndAO<WithStreamedUnaryMethod_SetToolList<WithStreamedUnaryMethod_GetToolList<WithStreamedUnaryMethod_SetDIConfigList<WithStreamedUnaryMethod_GetDIConfigList<WithStreamedUnaryMethod_SetDOConfigList<WithStreamedUnaryMethod_GetDOConfigList<WithStreamedUnaryMethod_SetCollSensLevel<WithStreamedUnaryMethod_GetCollSensLevel<WithStreamedUnaryMethod_SetCollPolicy<WithStreamedUnaryMethod_GetCollPolicy<WithStreamedUnaryMethod_SetCollSensParam<WithStreamedUnaryMethod_GetCollSensParam<WithStreamedUnaryMethod_InitCollSensParam<WithStreamedUnaryMethod_PlayTuningProgram<WithStreamedUnaryMethod_GetTeleOpDevice<WithStreamedUnaryMethod_GetTeleOpState<WithStreamedUnaryMethod_ConnectTeleOpDevice<WithStreamedUnaryMethod_DisConnectTeleOpDevice<WithStreamedUnaryMethod_ReadTeleOpInput<WithStreamedUnaryMethod_StartTeleCalib<WithStreamedUnaryMethod_StartTeleRecord<WithStreamedUnaryMethod_StartTelePlay<WithStreamedUnaryMethod_StartTeleJogL<WithStreamedUnaryMethod_StartTeleJogJ<WithStreamedUnaryMethod_StopTeleOp<WithStreamedUnaryMethod_SetPlayRate<WithStreamedUnaryMethod_GetPlayRate<WithStreamedUnaryMethod_GetTeleFileList<WithStreamedUnaryMethod_SaveTeleMotion<WithStreamedUnaryMethod_LoadTeleMotion<WithStreamedUnaryMethod_DeleteTeleMotion<WithStreamedUnaryMethod_MoveTeleJ<WithStreamedUnaryMethod_MoveTeleL<WithStreamedUnaryMethod_SetTeleOpParams<WithStreamedUnaryMethod_GetTeleOpParams<WithStreamedUnaryMethod_SetFTSensorConfig<WithStreamedUnaryMethod_GetFTSensorConfig<WithStreamedUnaryMethod_GetFTSensorData<WithStreamedUnaryMethod_GetLoadFactors<WithStreamedUnaryMethod_SetSanderCommand<WithStreamedUnaryMethod_GetSanderCommand<WithStreamedUnaryMethod_SetSandingStopCondition<WithStreamedUnaryMethod_GetSandingStopCondition<WithStreamedUnaryMethod_GetGripperData<WithStreamedUnaryMethod_SetGripperCommand<WithStreamedUnaryMethod_SetSFDActivate<WithStreamedUnaryMethod_IsSFDActivate<WithStreamedUnaryMethod_SFDLogin<WithStreamedUnaryMethod_IsSFDLogin<WithStreamedUnaryMethod_SetSFDTarget<WithStreamedUnaryMethod_SetSFDOption<WithStreamedUnaryMethod_GetSFDProjList<WithStreamedUnaryMethod_GetSFDCRI<WithStreamedUnaryMethod_GetTactTime<WithStreamedUnaryMethod_AddPhotoneoCalibPoint<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetFile() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::IndyFramework::Protobuf::HRI::GetFileReq, ::IndyFramework::Protobuf::HRI::GetFileRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::IndyFramework::Protobuf::HRI::GetFileReq, ::IndyFramework::Protobuf::HRI::GetFileRes>* streamer) {
                       return this->StreamedGetFile(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetFileReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetFileRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetFile(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::IndyFramework::Protobuf::HRI::GetFileReq,::IndyFramework::Protobuf::HRI::GetFileRes>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetLogContent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetLogContent() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::IndyFramework::Protobuf::HRI::GetLogContentReq, ::IndyFramework::Protobuf::HRI::GetLogContentRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::IndyFramework::Protobuf::HRI::GetLogContentReq, ::IndyFramework::Protobuf::HRI::GetLogContentRes>* streamer) {
                       return this->StreamedGetLogContent(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetLogContent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLogContent(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetLogContent(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::IndyFramework::Protobuf::HRI::GetLogContentReq,::IndyFramework::Protobuf::HRI::GetLogContentRes>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetLogContentList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetLogContentList() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::IndyFramework::Protobuf::HRI::GetLogContentListReq, ::IndyFramework::Protobuf::HRI::GetLogContentListRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::IndyFramework::Protobuf::HRI::GetLogContentListReq, ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* streamer) {
                       return this->StreamedGetLogContentList(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetLogContentList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLogContentList(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogContentListReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogContentListRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetLogContentList(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::IndyFramework::Protobuf::HRI::GetLogContentListReq,::IndyFramework::Protobuf::HRI::GetLogContentListRes>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetLog() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::IndyFramework::Protobuf::HRI::GetLogReq, ::IndyFramework::Protobuf::HRI::GetLogRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::IndyFramework::Protobuf::HRI::GetLogReq, ::IndyFramework::Protobuf::HRI::GetLogRes>* streamer) {
                       return this->StreamedGetLog(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLog(::grpc::ServerContext* /*context*/, const ::IndyFramework::Protobuf::HRI::GetLogReq* /*request*/, ::grpc::ServerWriter< ::IndyFramework::Protobuf::HRI::GetLogRes>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetLog(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::IndyFramework::Protobuf::HRI::GetLogReq,::IndyFramework::Protobuf::HRI::GetLogRes>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetFile<WithSplitStreamingMethod_GetLogContent<WithSplitStreamingMethod_GetLogContentList<WithSplitStreamingMethod_GetLog<Service > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_ContyInit<WithStreamedUnaryMethod_RobotUpdate<WithStreamedUnaryMethod_ProgramUpdate<WithStreamedUnaryMethod_ControlUpdate<WithStreamedUnaryMethod_LinearUpdate<WithStreamedUnaryMethod_JogJoint<WithStreamedUnaryMethod_JogTask<WithStreamedUnaryMethod_JogAxis<WithStreamedUnaryMethod_HoldToMoveJ<WithStreamedUnaryMethod_HoldToMoveL<WithStreamedUnaryMethod_HoldToAxisJ<WithStreamedUnaryMethod_StopMotion<WithStreamedUnaryMethod_SetRefFrame<WithStreamedUnaryMethod_SetRefFramePlanar<WithStreamedUnaryMethod_SetToolFrame<WithStreamedUnaryMethod_SetSpeedRatio<WithStreamedUnaryMethod_SetSimulationMode<WithStreamedUnaryMethod_SetDirectTeachingMode<WithStreamedUnaryMethod_SetCustomControlMode<WithStreamedUnaryMethod_GetCustomControlMode<WithStreamedUnaryMethod_SetSensorlessComplianceMode<WithStreamedUnaryMethod_GetBrakeControlStyle<WithStreamedUnaryMethod_SetBrake<WithStreamedUnaryMethod_SetServo<WithStreamedUnaryMethod_SetAutoServoOff<WithStreamedUnaryMethod_GetAutoServoOff<WithStreamedUnaryMethod_ExecuteTool<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_CalculateRelativePose<WithStreamedUnaryMethod_CalculateCurrentPoseRel<WithStreamedUnaryMethod_SetManualRecoverMode<WithStreamedUnaryMethod_SetServoRecover<WithStreamedUnaryMethod_JogJointRecover<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_Reboot<WithStreamedUnaryMethod_PowerOff<WithSplitStreamingMethod_GetFile<WithStreamedUnaryMethod_RenameFile<WithStreamedUnaryMethod_RemoveFile<WithStreamedUnaryMethod_GetIndexProgramList<WithStreamedUnaryMethod_GetProgramList<WithStreamedUnaryMethod_GetLogList<WithSplitStreamingMethod_GetLogContent<WithSplitStreamingMethod_GetLogContentList<WithSplitStreamingMethod_GetLog<WithStreamedUnaryMethod_GetVariableList<WithStreamedUnaryMethod_GetMonitoringVariableList<WithStreamedUnaryMethod_SetMonitoringVariableList<WithStreamedUnaryMethod_GetPalletMakerList<WithStreamedUnaryMethod_SetPalletMakerList<WithStreamedUnaryMethod_CheckAproachRetractValid<WithStreamedUnaryMethod_GetPalletPointList<WithStreamedUnaryMethod_SetPalletPointList<WithStreamedUnaryMethod_GetConveyor<WithStreamedUnaryMethod_SetConveyorName<WithStreamedUnaryMethod_SetConveyorByName<WithStreamedUnaryMethod_SetConveyorEncoder<WithStreamedUnaryMethod_SetConveyorTrigger<WithStreamedUnaryMethod_SetConveyorOffset<WithStreamedUnaryMethod_SetConveyorStartingPose<WithStreamedUnaryMethod_SetConveyorTerminalPose<WithStreamedUnaryMethod_GetConveyorState<WithStreamedUnaryMethod_HoldToMoveConveyor<WithStreamedUnaryMethod_GetConveyorList<WithStreamedUnaryMethod_SetConveyorList<WithStreamedUnaryMethod_SetInching<WithStreamedUnaryMethod_StopInching<WithStreamedUnaryMethod_SetArc<WithStreamedUnaryMethod_SetTouch<WithStreamedUnaryMethod_SetGas<WithStreamedUnaryMethod_IsTouched<WithStreamedUnaryMethod_GetVisionServerList<WithStreamedUnaryMethod_SetVisionServerList<WithStreamedUnaryMethod_GetVisionObjectList<WithStreamedUnaryMethod_GetVisionDetection<WithStreamedUnaryMethod_GetVisionRetrieval<WithStreamedUnaryMethod_GetGcodeMotionList<WithStreamedUnaryMethod_GetModbusServerList<WithStreamedUnaryMethod_SetModbusServerList<WithStreamedUnaryMethod_CheckModbusConnection<WithStreamedUnaryMethod_GetToolFrameList<WithStreamedUnaryMethod_SetToolFrameList<WithStreamedUnaryMethod_GetRefFrameList<WithStreamedUnaryMethod_SetRefFrameList<WithStreamedUnaryMethod_GetCustomPosList<WithStreamedUnaryMethod_SetCustomPosList<WithStreamedUnaryMethod_SetJointControlGain<WithStreamedUnaryMethod_GetJointControlGain<WithStreamedUnaryMethod_SetTaskControlGain<WithStreamedUnaryMethod_GetTaskControlGain<WithStreamedUnaryMethod_SetImpedanceControlGain<WithStreamedUnaryMethod_GetImpedanceControlGain<WithStreamedUnaryMethod_SetForceControlGain<WithStreamedUnaryMethod_GetForceControlGain<WithStreamedUnaryMethod_SetExtAxisControlGain<WithStreamedUnaryMethod_GetExtAxisControlGain<WithStreamedUnaryMethod_SetSensorlessComplianceControlJointGain<WithStreamedUnaryMethod_GetSensorlessComplianceControlJointGain<WithStreamedUnaryMethod_SetSensorlessComplianceControlTaskGain<WithStreamedUnaryMethod_GetSensorlessComplianceControlTaskGain<WithStreamedUnaryMethod_SetFricComp<WithStreamedUnaryMethod_GetFricComp<WithStreamedUnaryMethod_SetHomePos<WithStreamedUnaryMethod_GetHomePos<WithStreamedUnaryMethod_SetMountPos<WithStreamedUnaryMethod_GetMountPos<WithStreamedUnaryMethod_GetPackagingPos<WithStreamedUnaryMethod_SetToolProperty<WithStreamedUnaryMethod_GetToolProperty<WithStreamedUnaryMethod_GetOnStartProgramConfig<WithStreamedUnaryMethod_SetOnStartProgramConfig<WithStreamedUnaryMethod_GetSafetyLimitConfig<WithStreamedUnaryMethod_SetSafetyLimitConfig<WithStreamedUnaryMethod_GetSafetyStopConfig<WithStreamedUnaryMethod_SetSafetyStopConfig<WithStreamedUnaryMethod_GetSafetyConfigHash<WithStreamedUnaryMethod_GetKinematicsParams<WithStreamedUnaryMethod_KeyInit<WithStreamedUnaryMethod_KeyData<WithStreamedUnaryMethod_ProgramUpdateKey<WithStreamedUnaryMethod_SetDirectTeachingModeKey<WithStreamedUnaryMethod_GetAutoModeConfig<WithStreamedUnaryMethod_SetAutoMode<WithStreamedUnaryMethod_CheckAutoMode<WithStreamedUnaryMethod_CheckReducedMode<WithStreamedUnaryMethod_GetReducedRatio<WithStreamedUnaryMethod_GetReducedSpeed<WithStreamedUnaryMethod_SetReducedSpeed<WithStreamedUnaryMethod_GetStopState<WithStreamedUnaryMethod_GetSafetyFunctionState<WithStreamedUnaryMethod_RequestSafetyFunction<WithStreamedUnaryMethod_PlayProgram<WithStreamedUnaryMethod_PlayIndexProgram<WithStreamedUnaryMethod_PlayProgramLine<WithStreamedUnaryMethod_ResumeProgram<WithStreamedUnaryMethod_StopProgram<WithStreamedUnaryMethod_PauseProgram<WithStreamedUnaryMethod_SetDO<WithStreamedUnaryMethod_SetAO<WithStreamedUnaryMethod_SetEndDO<WithStreamedUnaryMethod_SetEndAO<WithStreamedUnaryMethod_SetToolList<WithStreamedUnaryMethod_GetToolList<WithStreamedUnaryMethod_SetDIConfigList<WithStreamedUnaryMethod_GetDIConfigList<WithStreamedUnaryMethod_SetDOConfigList<WithStreamedUnaryMethod_GetDOConfigList<WithStreamedUnaryMethod_SetCollSensLevel<WithStreamedUnaryMethod_GetCollSensLevel<WithStreamedUnaryMethod_SetCollPolicy<WithStreamedUnaryMethod_GetCollPolicy<WithStreamedUnaryMethod_SetCollSensParam<WithStreamedUnaryMethod_GetCollSensParam<WithStreamedUnaryMethod_InitCollSensParam<WithStreamedUnaryMethod_PlayTuningProgram<WithStreamedUnaryMethod_GetTeleOpDevice<WithStreamedUnaryMethod_GetTeleOpState<WithStreamedUnaryMethod_ConnectTeleOpDevice<WithStreamedUnaryMethod_DisConnectTeleOpDevice<WithStreamedUnaryMethod_ReadTeleOpInput<WithStreamedUnaryMethod_StartTeleCalib<WithStreamedUnaryMethod_StartTeleRecord<WithStreamedUnaryMethod_StartTelePlay<WithStreamedUnaryMethod_StartTeleJogL<WithStreamedUnaryMethod_StartTeleJogJ<WithStreamedUnaryMethod_StopTeleOp<WithStreamedUnaryMethod_SetPlayRate<WithStreamedUnaryMethod_GetPlayRate<WithStreamedUnaryMethod_GetTeleFileList<WithStreamedUnaryMethod_SaveTeleMotion<WithStreamedUnaryMethod_LoadTeleMotion<WithStreamedUnaryMethod_DeleteTeleMotion<WithStreamedUnaryMethod_MoveTeleJ<WithStreamedUnaryMethod_MoveTeleL<WithStreamedUnaryMethod_SetTeleOpParams<WithStreamedUnaryMethod_GetTeleOpParams<WithStreamedUnaryMethod_SetFTSensorConfig<WithStreamedUnaryMethod_GetFTSensorConfig<WithStreamedUnaryMethod_GetFTSensorData<WithStreamedUnaryMethod_GetLoadFactors<WithStreamedUnaryMethod_SetSanderCommand<WithStreamedUnaryMethod_GetSanderCommand<WithStreamedUnaryMethod_SetSandingStopCondition<WithStreamedUnaryMethod_GetSandingStopCondition<WithStreamedUnaryMethod_GetGripperData<WithStreamedUnaryMethod_SetGripperCommand<WithStreamedUnaryMethod_SetSFDActivate<WithStreamedUnaryMethod_IsSFDActivate<WithStreamedUnaryMethod_SFDLogin<WithStreamedUnaryMethod_IsSFDLogin<WithStreamedUnaryMethod_SetSFDTarget<WithStreamedUnaryMethod_SetSFDOption<WithStreamedUnaryMethod_GetSFDProjList<WithStreamedUnaryMethod_GetSFDCRI<WithStreamedUnaryMethod_GetTactTime<WithStreamedUnaryMethod_AddPhotoneoCalibPoint<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};
// ---------------------------------------------------------------- //
// Conty
// ---------------------------------------------------------------- //

}  // namespace HRI
}  // namespace Protobuf
}  // namespace IndyFramework


#endif  // GRPC_hri_2eproto__INCLUDED
